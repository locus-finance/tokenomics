/*! For license information please see main.js.LICENSE.txt */
(()=>{var e={424:(e,t,n)=>{"use strict";n.r(t),n.d(t,{default:()=>o});var a=n(81),i=n.n(a),s=n(645),r=n.n(s)()(i());r.push([e.id,"@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);"]),r.push([e.id,"\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n",""]);const o=r},645:e=>{"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",a=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),a&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),a&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,a,i,s){"string"==typeof e&&(e=[[null,e,void 0]]);var r={};if(a)for(var o=0;o<this.length;o++){var u=this[o][0];null!=u&&(r[u]=!0)}for(var d=0;d<e.length;d++){var p=[].concat(e[d]);a&&r[p[0]]||(void 0!==s&&(void 0===p[5]||(p[1]="@layer".concat(p[5].length>0?" ".concat(p[5]):""," {").concat(p[1],"}")),p[5]=s),n&&(p[2]?(p[1]="@media ".concat(p[2]," {").concat(p[1],"}"),p[2]=n):p[2]=n),i&&(p[4]?(p[1]="@supports (".concat(p[4],") {").concat(p[1],"}"),p[4]=i):p[4]="".concat(i)),t.push(p))}},t}},81:e=>{"use strict";e.exports=function(e){return e[1]}},838:(e,t,n)=>{var a=n(424);a.__esModule&&(a=a.default),"string"==typeof a&&(a=[[e.id,a,""]]),a.locals&&(e.exports=a.locals),(0,n(346).Z)("20211576",a,!1,{})},346:(e,t,n)=>{"use strict";function a(e,t){for(var n=[],a={},i=0;i<t.length;i++){var s=t[i],r=s[0],o={id:e+":"+i,css:s[1],media:s[2],sourceMap:s[3]};a[r]?a[r].parts.push(o):n.push(a[r]={id:r,parts:[o]})}return n}n.d(t,{Z:()=>m});var i="undefined"!=typeof document;if("undefined"!=typeof DEBUG&&DEBUG&&!i)throw new Error("vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.");var s={},r=i&&(document.head||document.getElementsByTagName("head")[0]),o=null,u=0,d=!1,p=function(){},l=null,c="data-vue-ssr-id",y="undefined"!=typeof navigator&&/msie [6-9]\b/.test(navigator.userAgent.toLowerCase());function m(e,t,n,i){d=n,l=i||{};var r=a(e,t);return f(r),function(t){for(var n=[],i=0;i<r.length;i++){var o=r[i];(u=s[o.id]).refs--,n.push(u)}for(t?f(r=a(e,t)):r=[],i=0;i<n.length;i++){var u;if(0===(u=n[i]).refs){for(var d=0;d<u.parts.length;d++)u.parts[d]();delete s[u.id]}}}}function f(e){for(var t=0;t<e.length;t++){var n=e[t],a=s[n.id];if(a){a.refs++;for(var i=0;i<a.parts.length;i++)a.parts[i](n.parts[i]);for(;i<n.parts.length;i++)a.parts.push(b(n.parts[i]));a.parts.length>n.parts.length&&(a.parts.length=n.parts.length)}else{var r=[];for(i=0;i<n.parts.length;i++)r.push(b(n.parts[i]));s[n.id]={id:n.id,refs:1,parts:r}}}}function h(){var e=document.createElement("style");return e.type="text/css",r.appendChild(e),e}function b(e){var t,n,a=document.querySelector("style["+c+'~="'+e.id+'"]');if(a){if(d)return p;a.parentNode.removeChild(a)}if(y){var i=u++;a=o||(o=h()),t=T.bind(null,a,i,!1),n=T.bind(null,a,i,!0)}else a=h(),t=w.bind(null,a),n=function(){a.parentNode.removeChild(a)};return t(e),function(a){if(a){if(a.css===e.css&&a.media===e.media&&a.sourceMap===e.sourceMap)return;t(e=a)}else n()}}var v,g=(v=[],function(e,t){return v[e]=t,v.filter(Boolean).join("\n")});function T(e,t,n,a){var i=n?"":a.css;if(e.styleSheet)e.styleSheet.cssText=g(t,i);else{var s=document.createTextNode(i),r=e.childNodes;r[t]&&e.removeChild(r[t]),r.length?e.insertBefore(s,r[t]):e.appendChild(s)}}function w(e,t){var n=t.css,a=t.media,i=t.sourceMap;if(a&&e.setAttribute("media",a),l.ssrId&&e.setAttribute(c,t.id),i&&(n+="\n/*# sourceURL="+i.sources[0]+" */",n+="\n/*# sourceMappingURL=data:application/json;base64,"+btoa(unescape(encodeURIComponent(JSON.stringify(i))))+" */"),e.styleSheet)e.styleSheet.cssText=n;else{for(;e.firstChild;)e.removeChild(e.firstChild);e.appendChild(document.createTextNode(n))}}}},t={};function n(a){var i=t[a];if(void 0!==i)return i.exports;var s=t[a]={id:a,exports:{}};return e[a](s,s.exports,n),s.exports}n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},(()=>{"use strict";var e=Object.freeze({}),t=Array.isArray;function a(e){return null==e}function i(e){return null!=e}function s(e){return!0===e}function r(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function o(e){return"function"==typeof e}function u(e){return null!==e&&"object"==typeof e}var d=Object.prototype.toString;function p(e){return"[object Object]"===d.call(e)}function l(e){var t=parseFloat(String(e));return t>=0&&Math.floor(t)===t&&isFinite(e)}function c(e){return i(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function y(e){return null==e?"":Array.isArray(e)||p(e)&&e.toString===d?JSON.stringify(e,null,2):String(e)}function m(e){var t=parseFloat(e);return isNaN(t)?e:t}function f(e,t){for(var n=Object.create(null),a=e.split(","),i=0;i<a.length;i++)n[a[i]]=!0;return t?function(e){return n[e.toLowerCase()]}:function(e){return n[e]}}var h=f("slot,component",!0),b=f("key,ref,slot,slot-scope,is");function v(e,t){var n=e.length;if(n){if(t===e[n-1])return void(e.length=n-1);var a=e.indexOf(t);if(a>-1)return e.splice(a,1)}}var g=Object.prototype.hasOwnProperty;function T(e,t){return g.call(e,t)}function w(e){var t=Object.create(null);return function(n){return t[n]||(t[n]=e(n))}}var k=/-(\w)/g,A=w((function(e){return e.replace(k,(function(e,t){return t?t.toUpperCase():""}))})),R=w((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),S=/\B([A-Z])/g,M=w((function(e){return e.replace(S,"-$1").toLowerCase()})),_=Function.prototype.bind?function(e,t){return e.bind(t)}:function(e,t){function n(n){var a=arguments.length;return a?a>1?e.apply(t,arguments):e.call(t,n):e.call(t)}return n._length=e.length,n};function D(e,t){t=t||0;for(var n=e.length-t,a=new Array(n);n--;)a[n]=e[n+t];return a}function I(e,t){for(var n in t)e[n]=t[n];return e}function E(e){for(var t={},n=0;n<e.length;n++)e[n]&&I(t,e[n]);return t}function x(e,t,n){}var L=function(e,t,n){return!1},C=function(e){return e};function O(e,t){if(e===t)return!0;var n=u(e),a=u(t);if(!n||!a)return!n&&!a&&String(e)===String(t);try{var i=Array.isArray(e),s=Array.isArray(t);if(i&&s)return e.length===t.length&&e.every((function(e,n){return O(e,t[n])}));if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(i||s)return!1;var r=Object.keys(e),o=Object.keys(t);return r.length===o.length&&r.every((function(n){return O(e[n],t[n])}))}catch(e){return!1}}function P(e,t){for(var n=0;n<e.length;n++)if(O(e[n],t))return n;return-1}function F(e){var t=!1;return function(){t||(t=!0,e.apply(this,arguments))}}var z="data-server-rendered",N=["component","directive","filter"],$=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],B={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:L,isReservedAttr:L,isUnknownElement:L,getTagNamespace:x,parsePlatformTagName:C,mustUseProp:L,async:!0,_lifecycleHooks:$},q=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function j(e){var t=(e+"").charCodeAt(0);return 36===t||95===t}function V(e,t,n,a){Object.defineProperty(e,t,{value:n,enumerable:!!a,writable:!0,configurable:!0})}var U=new RegExp("[^".concat(q.source,".$_\\d]")),H="__proto__"in{},W="undefined"!=typeof window,G=W&&window.navigator.userAgent.toLowerCase(),Q=G&&/msie|trident/.test(G),Z=G&&G.indexOf("msie 9.0")>0,Y=G&&G.indexOf("edge/")>0;G&&G.indexOf("android");var K=G&&/iphone|ipad|ipod|ios/.test(G);G&&/chrome\/\d+/.test(G),G&&/phantomjs/.test(G);var X,J=G&&G.match(/firefox\/(\d+)/),ee={}.watch,te=!1;if(W)try{var ne={};Object.defineProperty(ne,"passive",{get:function(){te=!0}}),window.addEventListener("test-passive",null,ne)}catch(e){}var ae=function(){return void 0===X&&(X=!W&&void 0!==n.g&&n.g.process&&"server"===n.g.process.env.VUE_ENV),X},ie=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function se(e){return"function"==typeof e&&/native code/.test(e.toString())}var re,oe="undefined"!=typeof Symbol&&se(Symbol)&&"undefined"!=typeof Reflect&&se(Reflect.ownKeys);re="undefined"!=typeof Set&&se(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var ue=null;function de(e){void 0===e&&(e=null),e||ue&&ue._scope.off(),ue=e,e&&e._scope.on()}var pe=function(){function e(e,t,n,a,i,s,r,o){this.tag=e,this.data=t,this.children=n,this.text=a,this.elm=i,this.ns=void 0,this.context=s,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=t&&t.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=o,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(e.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),e}(),le=function(e){void 0===e&&(e="");var t=new pe;return t.text=e,t.isComment=!0,t};function ce(e){return new pe(void 0,void 0,void 0,String(e))}function ye(e){var t=new pe(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return t.ns=e.ns,t.isStatic=e.isStatic,t.key=e.key,t.isComment=e.isComment,t.fnContext=e.fnContext,t.fnOptions=e.fnOptions,t.fnScopeId=e.fnScopeId,t.asyncMeta=e.asyncMeta,t.isCloned=!0,t}var me=0,fe=[],he=function(){for(var e=0;e<fe.length;e++){var t=fe[e];t.subs=t.subs.filter((function(e){return e})),t._pending=!1}fe.length=0},be=function(){function e(){this._pending=!1,this.id=me++,this.subs=[]}return e.prototype.addSub=function(e){this.subs.push(e)},e.prototype.removeSub=function(e){this.subs[this.subs.indexOf(e)]=null,this._pending||(this._pending=!0,fe.push(this))},e.prototype.depend=function(t){e.target&&e.target.addDep(this)},e.prototype.notify=function(e){for(var t=this.subs.filter((function(e){return e})),n=0,a=t.length;n<a;n++)t[n].update()},e}();be.target=null;var ve=[];function ge(e){ve.push(e),be.target=e}function Te(){ve.pop(),be.target=ve[ve.length-1]}var we=Array.prototype,ke=Object.create(we);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var t=we[e];V(ke,e,(function(){for(var n=[],a=0;a<arguments.length;a++)n[a]=arguments[a];var i,s=t.apply(this,n),r=this.__ob__;switch(e){case"push":case"unshift":i=n;break;case"splice":i=n.slice(2)}return i&&r.observeArray(i),r.dep.notify(),s}))}));var Ae=Object.getOwnPropertyNames(ke),Re={},Se=!0;function Me(e){Se=e}var _e={notify:x,depend:x,addSub:x,removeSub:x},De=function(){function e(e,n,a){if(void 0===n&&(n=!1),void 0===a&&(a=!1),this.value=e,this.shallow=n,this.mock=a,this.dep=a?_e:new be,this.vmCount=0,V(e,"__ob__",this),t(e)){if(!a)if(H)e.__proto__=ke;else for(var i=0,s=Ae.length;i<s;i++)V(e,o=Ae[i],ke[o]);n||this.observeArray(e)}else{var r=Object.keys(e);for(i=0;i<r.length;i++){var o;Ee(e,o=r[i],Re,void 0,n,a)}}}return e.prototype.observeArray=function(e){for(var t=0,n=e.length;t<n;t++)Ie(e[t],!1,this.mock)},e}();function Ie(e,n,a){return e&&T(e,"__ob__")&&e.__ob__ instanceof De?e.__ob__:!Se||!a&&ae()||!t(e)&&!p(e)||!Object.isExtensible(e)||e.__v_skip||Fe(e)||e instanceof pe?void 0:new De(e,n,a)}function Ee(e,n,a,i,s,r){var o=new be,u=Object.getOwnPropertyDescriptor(e,n);if(!u||!1!==u.configurable){var d=u&&u.get,p=u&&u.set;d&&!p||a!==Re&&2!==arguments.length||(a=e[n]);var l=!s&&Ie(a,!1,r);return Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var n=d?d.call(e):a;return be.target&&(o.depend(),l&&(l.dep.depend(),t(n)&&Ce(n))),Fe(n)&&!s?n.value:n},set:function(t){var n,i,u=d?d.call(e):a;if((n=u)===(i=t)?0===n&&1/n!=1/i:n==n||i==i){if(p)p.call(e,t);else{if(d)return;if(!s&&Fe(u)&&!Fe(t))return void(u.value=t);a=t}l=!s&&Ie(t,!1,r),o.notify()}}}),o}}function xe(e,n,a){if(!Pe(e)){var i=e.__ob__;return t(e)&&l(n)?(e.length=Math.max(e.length,n),e.splice(n,1,a),i&&!i.shallow&&i.mock&&Ie(a,!1,!0),a):n in e&&!(n in Object.prototype)?(e[n]=a,a):e._isVue||i&&i.vmCount?a:i?(Ee(i.value,n,a,void 0,i.shallow,i.mock),i.dep.notify(),a):(e[n]=a,a)}}function Le(e,n){if(t(e)&&l(n))e.splice(n,1);else{var a=e.__ob__;e._isVue||a&&a.vmCount||Pe(e)||T(e,n)&&(delete e[n],a&&a.dep.notify())}}function Ce(e){for(var n=void 0,a=0,i=e.length;a<i;a++)(n=e[a])&&n.__ob__&&n.__ob__.dep.depend(),t(n)&&Ce(n)}function Oe(e){return function(e,t){Pe(e)||Ie(e,t,ae())}(e,!0),V(e,"__v_isShallow",!0),e}function Pe(e){return!(!e||!e.__v_isReadonly)}function Fe(e){return!(!e||!0!==e.__v_isRef)}function ze(e,t,n){Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var e=t[n];if(Fe(e))return e.value;var a=e&&e.__ob__;return a&&a.dep.depend(),e},set:function(e){var a=t[n];Fe(a)&&!Fe(e)?a.value=e:t[n]=e}})}var Ne=w((function(e){var t="&"===e.charAt(0),n="~"===(e=t?e.slice(1):e).charAt(0),a="!"===(e=n?e.slice(1):e).charAt(0);return{name:e=a?e.slice(1):e,once:n,capture:a,passive:t}}));function $e(e,n){function a(){var e=a.fns;if(!t(e))return Zt(e,null,arguments,n,"v-on handler");for(var i=e.slice(),s=0;s<i.length;s++)Zt(i[s],null,arguments,n,"v-on handler")}return a.fns=e,a}function Be(e,t,n,i,r,o){var u,d,p,l;for(u in e)d=e[u],p=t[u],l=Ne(u),a(d)||(a(p)?(a(d.fns)&&(d=e[u]=$e(d,o)),s(l.once)&&(d=e[u]=r(l.name,d,l.capture)),n(l.name,d,l.capture,l.passive,l.params)):d!==p&&(p.fns=d,e[u]=p));for(u in t)a(e[u])&&i((l=Ne(u)).name,t[u],l.capture)}function qe(e,t,n){var r;e instanceof pe&&(e=e.data.hook||(e.data.hook={}));var o=e[t];function u(){n.apply(this,arguments),v(r.fns,u)}a(o)?r=$e([u]):i(o.fns)&&s(o.merged)?(r=o).fns.push(u):r=$e([o,u]),r.merged=!0,e[t]=r}function je(e,t,n,a,s){if(i(t)){if(T(t,n))return e[n]=t[n],s||delete t[n],!0;if(T(t,a))return e[n]=t[a],s||delete t[a],!0}return!1}function Ve(e){return r(e)?[ce(e)]:t(e)?He(e):void 0}function Ue(e){return i(e)&&i(e.text)&&!1===e.isComment}function He(e,n){var o,u,d,p,l=[];for(o=0;o<e.length;o++)a(u=e[o])||"boolean"==typeof u||(p=l[d=l.length-1],t(u)?u.length>0&&(Ue((u=He(u,"".concat(n||"","_").concat(o)))[0])&&Ue(p)&&(l[d]=ce(p.text+u[0].text),u.shift()),l.push.apply(l,u)):r(u)?Ue(p)?l[d]=ce(p.text+u):""!==u&&l.push(ce(u)):Ue(u)&&Ue(p)?l[d]=ce(p.text+u.text):(s(e._isVList)&&i(u.tag)&&a(u.key)&&i(n)&&(u.key="__vlist".concat(n,"_").concat(o,"__")),l.push(u)));return l}var We=1,Ge=2;function Qe(e,n,a,d,p,l){return(t(a)||r(a))&&(p=d,d=a,a=void 0),s(l)&&(p=Ge),function(e,n,a,s,r){if(i(a)&&i(a.__ob__))return le();if(i(a)&&i(a.is)&&(n=a.is),!n)return le();var d,p;if(t(s)&&o(s[0])&&((a=a||{}).scopedSlots={default:s[0]},s.length=0),r===Ge?s=Ve(s):r===We&&(s=function(e){for(var n=0;n<e.length;n++)if(t(e[n]))return Array.prototype.concat.apply([],e);return e}(s)),"string"==typeof n){var l=void 0;p=e.$vnode&&e.$vnode.ns||B.getTagNamespace(n),d=B.isReservedTag(n)?new pe(B.parsePlatformTagName(n),a,s,void 0,void 0,e):a&&a.pre||!i(l=jn(e.$options,"components",n))?new pe(n,a,s,void 0,void 0,e):Ln(l,a,e,s,n)}else d=Ln(n,a,e,s);return t(d)?d:i(d)?(i(p)&&Ze(d,p),i(a)&&function(e){u(e.style)&&ln(e.style),u(e.class)&&ln(e.class)}(a),d):le()}(e,n,a,d,p)}function Ze(e,t,n){if(e.ns=t,"foreignObject"===e.tag&&(t=void 0,n=!0),i(e.children))for(var r=0,o=e.children.length;r<o;r++){var u=e.children[r];i(u.tag)&&(a(u.ns)||s(n)&&"svg"!==u.tag)&&Ze(u,t,n)}}function Ye(e,n){var a,s,r,o,d=null;if(t(e)||"string"==typeof e)for(d=new Array(e.length),a=0,s=e.length;a<s;a++)d[a]=n(e[a],a);else if("number"==typeof e)for(d=new Array(e),a=0;a<e;a++)d[a]=n(a+1,a);else if(u(e))if(oe&&e[Symbol.iterator]){d=[];for(var p=e[Symbol.iterator](),l=p.next();!l.done;)d.push(n(l.value,d.length)),l=p.next()}else for(r=Object.keys(e),d=new Array(r.length),a=0,s=r.length;a<s;a++)o=r[a],d[a]=n(e[o],o,a);return i(d)||(d=[]),d._isVList=!0,d}function Ke(e,t,n,a){var i,s=this.$scopedSlots[e];s?(n=n||{},a&&(n=I(I({},a),n)),i=s(n)||(o(t)?t():t)):i=this.$slots[e]||(o(t)?t():t);var r=n&&n.slot;return r?this.$createElement("template",{slot:r},i):i}function Xe(e){return jn(this.$options,"filters",e)||C}function Je(e,n){return t(e)?-1===e.indexOf(n):e!==n}function et(e,t,n,a,i){var s=B.keyCodes[t]||n;return i&&a&&!B.keyCodes[t]?Je(i,a):s?Je(s,e):a?M(a)!==t:void 0===e}function tt(e,n,a,i,s){if(a&&u(a)){t(a)&&(a=E(a));var r=void 0,o=function(t){if("class"===t||"style"===t||b(t))r=e;else{var o=e.attrs&&e.attrs.type;r=i||B.mustUseProp(n,o,t)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var u=A(t),d=M(t);u in r||d in r||(r[t]=a[t],s&&((e.on||(e.on={}))["update:".concat(t)]=function(e){a[t]=e}))};for(var d in a)o(d)}return e}function nt(e,t){var n=this._staticTrees||(this._staticTrees=[]),a=n[e];return a&&!t||it(a=n[e]=this.$options.staticRenderFns[e].call(this._renderProxy,this._c,this),"__static__".concat(e),!1),a}function at(e,t,n){return it(e,"__once__".concat(t).concat(n?"_".concat(n):""),!0),e}function it(e,n,a){if(t(e))for(var i=0;i<e.length;i++)e[i]&&"string"!=typeof e[i]&&st(e[i],"".concat(n,"_").concat(i),a);else st(e,n,a)}function st(e,t,n){e.isStatic=!0,e.key=t,e.isOnce=n}function rt(e,t){if(t&&p(t)){var n=e.on=e.on?I({},e.on):{};for(var a in t){var i=n[a],s=t[a];n[a]=i?[].concat(i,s):s}}return e}function ot(e,n,a,i){n=n||{$stable:!a};for(var s=0;s<e.length;s++){var r=e[s];t(r)?ot(r,n,a):r&&(r.proxy&&(r.fn.proxy=!0),n[r.key]=r.fn)}return i&&(n.$key=i),n}function ut(e,t){for(var n=0;n<t.length;n+=2){var a=t[n];"string"==typeof a&&a&&(e[t[n]]=t[n+1])}return e}function dt(e,t){return"string"==typeof e?t+e:e}function pt(e){e._o=at,e._n=m,e._s=y,e._l=Ye,e._t=Ke,e._q=O,e._i=P,e._m=nt,e._f=Xe,e._k=et,e._b=tt,e._v=ce,e._e=le,e._u=ot,e._g=rt,e._d=ut,e._p=dt}function lt(e,t){if(!e||!e.length)return{};for(var n={},a=0,i=e.length;a<i;a++){var s=e[a],r=s.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,s.context!==t&&s.fnContext!==t||!r||null==r.slot)(n.default||(n.default=[])).push(s);else{var o=r.slot,u=n[o]||(n[o]=[]);"template"===s.tag?u.push.apply(u,s.children||[]):u.push(s)}}for(var d in n)n[d].every(ct)&&delete n[d];return n}function ct(e){return e.isComment&&!e.asyncFactory||" "===e.text}function yt(e){return e.isComment&&e.asyncFactory}function mt(t,n,a,i){var s,r=Object.keys(a).length>0,o=n?!!n.$stable:!r,u=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(o&&i&&i!==e&&u===i.$key&&!r&&!i.$hasNormal)return i;for(var d in s={},n)n[d]&&"$"!==d[0]&&(s[d]=ft(t,a,d,n[d]))}else s={};for(var p in a)p in s||(s[p]=ht(a,p));return n&&Object.isExtensible(n)&&(n._normalized=s),V(s,"$stable",o),V(s,"$key",u),V(s,"$hasNormal",r),s}function ft(e,n,a,i){var s=function(){var n=ue;de(e);var a=arguments.length?i.apply(null,arguments):i({}),s=(a=a&&"object"==typeof a&&!t(a)?[a]:Ve(a))&&a[0];return de(n),a&&(!s||1===a.length&&s.isComment&&!yt(s))?void 0:a};return i.proxy&&Object.defineProperty(n,a,{get:s,enumerable:!0,configurable:!0}),s}function ht(e,t){return function(){return e[t]}}function bt(e,t,n,a,i){var s=!1;for(var r in t)r in e?t[r]!==n[r]&&(s=!0):(s=!0,vt(e,r,a,i));for(var r in e)r in t||(s=!0,delete e[r]);return s}function vt(e,t,n,a){Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){return n[a][t]}})}function gt(e,t){for(var n in t)e[n]=t[n];for(var n in e)n in t||delete e[n]}var Tt,wt=null;function kt(e,t){return(e.__esModule||oe&&"Module"===e[Symbol.toStringTag])&&(e=e.default),u(e)?t.extend(e):e}function At(e){if(t(e))for(var n=0;n<e.length;n++){var a=e[n];if(i(a)&&(i(a.componentOptions)||yt(a)))return a}}function Rt(e,t){Tt.$on(e,t)}function St(e,t){Tt.$off(e,t)}function Mt(e,t){var n=Tt;return function a(){null!==t.apply(null,arguments)&&n.$off(e,a)}}function _t(e,t,n){Tt=e,Be(t,n||{},Rt,St,Mt,e),Tt=void 0}var Dt=null;function It(e){var t=Dt;return Dt=e,function(){Dt=t}}function Et(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function xt(e,t){if(t){if(e._directInactive=!1,Et(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var n=0;n<e.$children.length;n++)xt(e.$children[n]);Ct(e,"activated")}}function Lt(e,t){if(!(t&&(e._directInactive=!0,Et(e))||e._inactive)){e._inactive=!0;for(var n=0;n<e.$children.length;n++)Lt(e.$children[n]);Ct(e,"deactivated")}}function Ct(e,t,n,a){void 0===a&&(a=!0),ge();var i=ue;a&&de(e);var s=e.$options[t],r="".concat(t," hook");if(s)for(var o=0,u=s.length;o<u;o++)Zt(s[o],e,n||null,e,r);e._hasHookEvent&&e.$emit("hook:"+t),a&&de(i),Te()}var Ot=[],Pt=[],Ft={},zt=!1,Nt=!1,$t=0,Bt=0,qt=Date.now;if(W&&!Q){var jt=window.performance;jt&&"function"==typeof jt.now&&qt()>document.createEvent("Event").timeStamp&&(qt=function(){return jt.now()})}var Vt=function(e,t){if(e.post){if(!t.post)return 1}else if(t.post)return-1;return e.id-t.id};function Ut(){var e,t;for(Bt=qt(),Nt=!0,Ot.sort(Vt),$t=0;$t<Ot.length;$t++)(e=Ot[$t]).before&&e.before(),t=e.id,Ft[t]=null,e.run();var n=Pt.slice(),a=Ot.slice();$t=Ot.length=Pt.length=0,Ft={},zt=Nt=!1,function(e){for(var t=0;t<e.length;t++)e[t]._inactive=!0,xt(e[t],!0)}(n),function(e){for(var t=e.length;t--;){var n=e[t],a=n.vm;a&&a._watcher===n&&a._isMounted&&!a._isDestroyed&&Ct(a,"updated")}}(a),he(),ie&&B.devtools&&ie.emit("flush")}var Ht,Wt="watcher";"".concat(Wt," callback"),"".concat(Wt," getter"),"".concat(Wt," cleanup");var Gt=function(){function e(e){void 0===e&&(e=!1),this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Ht,!e&&Ht&&(this.index=(Ht.scopes||(Ht.scopes=[])).push(this)-1)}return e.prototype.run=function(e){if(this.active){var t=Ht;try{return Ht=this,e()}finally{Ht=t}}},e.prototype.on=function(){Ht=this},e.prototype.off=function(){Ht=this.parent},e.prototype.stop=function(e){if(this.active){var t=void 0,n=void 0;for(t=0,n=this.effects.length;t<n;t++)this.effects[t].teardown();for(t=0,n=this.cleanups.length;t<n;t++)this.cleanups[t]();if(this.scopes)for(t=0,n=this.scopes.length;t<n;t++)this.scopes[t].stop(!0);if(!this.detached&&this.parent&&!e){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},e}();function Qt(e,t,n){ge();try{if(t)for(var a=t;a=a.$parent;){var i=a.$options.errorCaptured;if(i)for(var s=0;s<i.length;s++)try{if(!1===i[s].call(a,e,t,n))return}catch(e){Yt(e,a,"errorCaptured hook")}}Yt(e,t,n)}finally{Te()}}function Zt(e,t,n,a,i){var s;try{(s=n?e.apply(t,n):e.call(t))&&!s._isVue&&c(s)&&!s._handled&&(s.catch((function(e){return Qt(e,a,i+" (Promise/async)")})),s._handled=!0)}catch(e){Qt(e,a,i)}return s}function Yt(e,t,n){if(B.errorHandler)try{return B.errorHandler.call(null,e,t,n)}catch(t){t!==e&&Kt(t)}Kt(e)}function Kt(e,t,n){if(!W||"undefined"==typeof console)throw e;console.error(e)}var Xt,Jt=!1,en=[],tn=!1;function nn(){tn=!1;var e=en.slice(0);en.length=0;for(var t=0;t<e.length;t++)e[t]()}if("undefined"!=typeof Promise&&se(Promise)){var an=Promise.resolve();Xt=function(){an.then(nn),K&&setTimeout(x)},Jt=!0}else if(Q||"undefined"==typeof MutationObserver||!se(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Xt="undefined"!=typeof setImmediate&&se(setImmediate)?function(){setImmediate(nn)}:function(){setTimeout(nn,0)};else{var sn=1,rn=new MutationObserver(nn),on=document.createTextNode(String(sn));rn.observe(on,{characterData:!0}),Xt=function(){sn=(sn+1)%2,on.data=String(sn)},Jt=!0}function un(e,t){var n;if(en.push((function(){if(e)try{e.call(t)}catch(e){Qt(e,t,"nextTick")}else n&&n(t)})),tn||(tn=!0,Xt()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){n=e}))}function dn(e){return function(t,n){if(void 0===n&&(n=ue),n)return function(e,t,n){var a=e.$options;a[t]=Nn(a[t],n)}(n,e,t)}}dn("beforeMount"),dn("mounted"),dn("beforeUpdate"),dn("updated"),dn("beforeDestroy"),dn("destroyed"),dn("activated"),dn("deactivated"),dn("serverPrefetch"),dn("renderTracked"),dn("renderTriggered"),dn("errorCaptured");var pn=new re;function ln(e){return cn(e,pn),pn.clear(),e}function cn(e,n){var a,i,s=t(e);if(!(!s&&!u(e)||e.__v_skip||Object.isFrozen(e)||e instanceof pe)){if(e.__ob__){var r=e.__ob__.dep.id;if(n.has(r))return;n.add(r)}if(s)for(a=e.length;a--;)cn(e[a],n);else if(Fe(e))cn(e.value,n);else for(a=(i=Object.keys(e)).length;a--;)cn(e[i[a]],n)}}var yn=0,mn=function(){function e(e,t,n,a,i){var s;void 0===(s=Ht&&!Ht._vm?Ht:e?e._scope:void 0)&&(s=Ht),s&&s.active&&s.effects.push(this),(this.vm=e)&&i&&(e._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=n,this.id=++yn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new re,this.newDepIds=new re,this.expression="",o(t)?this.getter=t:(this.getter=function(e){if(!U.test(e)){var t=e.split(".");return function(e){for(var n=0;n<t.length;n++){if(!e)return;e=e[t[n]]}return e}}}(t),this.getter||(this.getter=x)),this.value=this.lazy?void 0:this.get()}return e.prototype.get=function(){var e;ge(this);var t=this.vm;try{e=this.getter.call(t,t)}catch(e){if(!this.user)throw e;Qt(e,t,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&ln(e),Te(),this.cleanupDeps()}return e},e.prototype.addDep=function(e){var t=e.id;this.newDepIds.has(t)||(this.newDepIds.add(t),this.newDeps.push(e),this.depIds.has(t)||e.addSub(this))},e.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var t=this.deps[e];this.newDepIds.has(t.id)||t.removeSub(this)}var n=this.depIds;this.depIds=this.newDepIds,this.newDepIds=n,this.newDepIds.clear(),n=this.deps,this.deps=this.newDeps,this.newDeps=n,this.newDeps.length=0},e.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(e){var t=e.id;if(null==Ft[t]&&(e!==be.target||!e.noRecurse)){if(Ft[t]=!0,Nt){for(var n=Ot.length-1;n>$t&&Ot[n].id>e.id;)n--;Ot.splice(n+1,0,e)}else Ot.push(e);zt||(zt=!0,un(Ut))}}(this)},e.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||u(e)||this.deep){var t=this.value;if(this.value=e,this.user){var n='callback for watcher "'.concat(this.expression,'"');Zt(this.cb,this.vm,[e,t],this.vm,n)}else this.cb.call(this.vm,e,t)}}},e.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},e.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},e.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&v(this.vm._scope.effects,this),this.active){for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},e}(),fn={enumerable:!0,configurable:!0,get:x,set:x};function hn(e,t,n){fn.get=function(){return this[t][n]},fn.set=function(e){this[t][n]=e},Object.defineProperty(e,n,fn)}function bn(n){var a=n.$options;if(a.props&&function(e,t){var n=e.$options.propsData||{},a=e._props=Oe({}),i=e.$options._propKeys=[];!e.$parent||Me(!1);var s=function(s){i.push(s);var r=Vn(s,t,n,e);Ee(a,s,r),s in e||hn(e,"_props",s)};for(var r in t)s(r);Me(!0)}(n,a.props),function(t){var n=t.$options,a=n.setup;if(a){var i=t._setupContext=function(t){return{get attrs(){if(!t._attrsProxy){var n=t._attrsProxy={};V(n,"_v_attr_proxy",!0),bt(n,t.$attrs,e,t,"$attrs")}return t._attrsProxy},get listeners(){return t._listenersProxy||bt(t._listenersProxy={},t.$listeners,e,t,"$listeners"),t._listenersProxy},get slots(){return function(e){return e._slotsProxy||gt(e._slotsProxy={},e.$scopedSlots),e._slotsProxy}(t)},emit:_(t.$emit,t),expose:function(e){e&&Object.keys(e).forEach((function(n){return ze(t,e,n)}))}}}(t);de(t),ge();var s=Zt(a,null,[t._props||Oe({}),i],t,"setup");if(Te(),de(),o(s))n.render=s;else if(u(s))if(t._setupState=s,s.__sfc){var r=t._setupProxy={};for(var d in s)"__sfc"!==d&&ze(r,s,d)}else for(var d in s)j(d)||ze(t,s,d)}}(n),a.methods&&function(e,t){for(var n in e.$options.props,t)e[n]="function"!=typeof t[n]?x:_(t[n],e)}(n,a.methods),a.data)!function(e){var t=e.$options.data;p(t=e._data=o(t)?function(e,t){ge();try{return e.call(t,t)}catch(e){return Qt(e,t,"data()"),{}}finally{Te()}}(t,e):t||{})||(t={});for(var n=Object.keys(t),a=e.$options.props,i=(e.$options.methods,n.length);i--;){var s=n[i];a&&T(a,s)||j(s)||hn(e,"_data",s)}var r=Ie(t);r&&r.vmCount++}(n);else{var i=Ie(n._data={});i&&i.vmCount++}a.computed&&function(e,t){var n=e._computedWatchers=Object.create(null),a=ae();for(var i in t){var s=t[i],r=o(s)?s:s.get;a||(n[i]=new mn(e,r||x,x,vn)),i in e||gn(e,i,s)}}(n,a.computed),a.watch&&a.watch!==ee&&function(e,n){for(var a in n){var i=n[a];if(t(i))for(var s=0;s<i.length;s++)kn(e,a,i[s]);else kn(e,a,i)}}(n,a.watch)}var vn={lazy:!0};function gn(e,t,n){var a=!ae();o(n)?(fn.get=a?Tn(t):wn(n),fn.set=x):(fn.get=n.get?a&&!1!==n.cache?Tn(t):wn(n.get):x,fn.set=n.set||x),Object.defineProperty(e,t,fn)}function Tn(e){return function(){var t=this._computedWatchers&&this._computedWatchers[e];if(t)return t.dirty&&t.evaluate(),be.target&&t.depend(),t.value}}function wn(e){return function(){return e.call(this,this)}}function kn(e,t,n,a){return p(n)&&(a=n,n=n.handler),"string"==typeof n&&(n=e[n]),e.$watch(t,n,a)}function An(e,t){if(e){for(var n=Object.create(null),a=oe?Reflect.ownKeys(e):Object.keys(e),i=0;i<a.length;i++){var s=a[i];if("__ob__"!==s){var r=e[s].from;if(r in t._provided)n[s]=t._provided[r];else if("default"in e[s]){var u=e[s].default;n[s]=o(u)?u.call(t):u}}}return n}}var Rn=0;function Sn(e){var t=e.options;if(e.super){var n=Sn(e.super);if(n!==e.superOptions){e.superOptions=n;var a=function(e){var t,n=e.options,a=e.sealedOptions;for(var i in n)n[i]!==a[i]&&(t||(t={}),t[i]=n[i]);return t}(e);a&&I(e.extendOptions,a),(t=e.options=qn(n,e.extendOptions)).name&&(t.components[t.name]=e)}}return t}function Mn(n,a,i,r,o){var u,d=this,p=o.options;T(r,"_uid")?(u=Object.create(r))._original=r:(u=r,r=r._original);var l=s(p._compiled),c=!l;this.data=n,this.props=a,this.children=i,this.parent=r,this.listeners=n.on||e,this.injections=An(p.inject,r),this.slots=function(){return d.$slots||mt(r,n.scopedSlots,d.$slots=lt(i,r)),d.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return mt(r,n.scopedSlots,this.slots())}}),l&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=mt(r,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(e,n,a,i){var s=Qe(u,e,n,a,i,c);return s&&!t(s)&&(s.fnScopeId=p._scopeId,s.fnContext=r),s}:this._c=function(e,t,n,a){return Qe(u,e,t,n,a,c)}}function _n(e,t,n,a,i){var s=ye(e);return s.fnContext=n,s.fnOptions=a,t.slot&&((s.data||(s.data={})).slot=t.slot),s}function Dn(e,t){for(var n in t)e[A(n)]=t[n]}function In(e){return e.name||e.__name||e._componentTag}pt(Mn.prototype);var En={init:function(e,t){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var n=e;En.prepatch(n,n)}else(e.componentInstance=function(e,t){var n={_isComponent:!0,_parentVnode:e,parent:t},a=e.data.inlineTemplate;return i(a)&&(n.render=a.render,n.staticRenderFns=a.staticRenderFns),new e.componentOptions.Ctor(n)}(e,Dt)).$mount(t?e.elm:void 0,t)},prepatch:function(t,n){var a=n.componentOptions;!function(t,n,a,i,s){var r=i.data.scopedSlots,o=t.$scopedSlots,u=!!(r&&!r.$stable||o!==e&&!o.$stable||r&&t.$scopedSlots.$key!==r.$key||!r&&t.$scopedSlots.$key),d=!!(s||t.$options._renderChildren||u),p=t.$vnode;t.$options._parentVnode=i,t.$vnode=i,t._vnode&&(t._vnode.parent=i),t.$options._renderChildren=s;var l=i.data.attrs||e;t._attrsProxy&&bt(t._attrsProxy,l,p.data&&p.data.attrs||e,t,"$attrs")&&(d=!0),t.$attrs=l,a=a||e;var c=t.$options._parentListeners;if(t._listenersProxy&&bt(t._listenersProxy,a,c||e,t,"$listeners"),t.$listeners=t.$options._parentListeners=a,_t(t,a,c),n&&t.$options.props){Me(!1);for(var y=t._props,m=t.$options._propKeys||[],f=0;f<m.length;f++){var h=m[f],b=t.$options.props;y[h]=Vn(h,b,n,t)}Me(!0),t.$options.propsData=n}d&&(t.$slots=lt(s,i.context),t.$forceUpdate())}(n.componentInstance=t.componentInstance,a.propsData,a.listeners,n,a.children)},insert:function(e){var t,n=e.context,a=e.componentInstance;a._isMounted||(a._isMounted=!0,Ct(a,"mounted")),e.data.keepAlive&&(n._isMounted?((t=a)._inactive=!1,Pt.push(t)):xt(a,!0))},destroy:function(e){var t=e.componentInstance;t._isDestroyed||(e.data.keepAlive?Lt(t,!0):t.$destroy())}},xn=Object.keys(En);function Ln(n,r,o,d,p){if(!a(n)){var l=o.$options._base;if(u(n)&&(n=l.extend(n)),"function"==typeof n){var y;if(a(n.cid)&&(n=function(e,t){if(s(e.error)&&i(e.errorComp))return e.errorComp;if(i(e.resolved))return e.resolved;var n=wt;if(n&&i(e.owners)&&-1===e.owners.indexOf(n)&&e.owners.push(n),s(e.loading)&&i(e.loadingComp))return e.loadingComp;if(n&&!i(e.owners)){var r=e.owners=[n],o=!0,d=null,p=null;n.$on("hook:destroyed",(function(){return v(r,n)}));var l=function(e){for(var t=0,n=r.length;t<n;t++)r[t].$forceUpdate();e&&(r.length=0,null!==d&&(clearTimeout(d),d=null),null!==p&&(clearTimeout(p),p=null))},y=F((function(n){e.resolved=kt(n,t),o?r.length=0:l(!0)})),m=F((function(t){i(e.errorComp)&&(e.error=!0,l(!0))})),f=e(y,m);return u(f)&&(c(f)?a(e.resolved)&&f.then(y,m):c(f.component)&&(f.component.then(y,m),i(f.error)&&(e.errorComp=kt(f.error,t)),i(f.loading)&&(e.loadingComp=kt(f.loading,t),0===f.delay?e.loading=!0:d=setTimeout((function(){d=null,a(e.resolved)&&a(e.error)&&(e.loading=!0,l(!1))}),f.delay||200)),i(f.timeout)&&(p=setTimeout((function(){p=null,a(e.resolved)&&m(null)}),f.timeout)))),o=!1,e.loading?e.loadingComp:e.resolved}}(y=n,l),void 0===n))return function(e,t,n,a,i){var s=le();return s.asyncFactory=e,s.asyncMeta={data:t,context:n,children:a,tag:i},s}(y,r,o,d,p);r=r||{},Sn(n),i(r.model)&&function(e,n){var a=e.model&&e.model.prop||"value",s=e.model&&e.model.event||"input";(n.attrs||(n.attrs={}))[a]=n.model.value;var r=n.on||(n.on={}),o=r[s],u=n.model.callback;i(o)?(t(o)?-1===o.indexOf(u):o!==u)&&(r[s]=[u].concat(o)):r[s]=u}(n.options,r);var m=function(e,t,n){var s=t.options.props;if(!a(s)){var r={},o=e.attrs,u=e.props;if(i(o)||i(u))for(var d in s){var p=M(d);je(r,u,d,p,!0)||je(r,o,d,p,!1)}return r}}(r,n);if(s(n.options.functional))return function(n,a,s,r,o){var u=n.options,d={},p=u.props;if(i(p))for(var l in p)d[l]=Vn(l,p,a||e);else i(s.attrs)&&Dn(d,s.attrs),i(s.props)&&Dn(d,s.props);var c=new Mn(s,d,o,r,n),y=u.render.call(null,c._c,c);if(y instanceof pe)return _n(y,s,c.parent,u);if(t(y)){for(var m=Ve(y)||[],f=new Array(m.length),h=0;h<m.length;h++)f[h]=_n(m[h],s,c.parent,u);return f}}(n,m,r,o,d);var f=r.on;if(r.on=r.nativeOn,s(n.options.abstract)){var h=r.slot;r={},h&&(r.slot=h)}!function(e){for(var t=e.hook||(e.hook={}),n=0;n<xn.length;n++){var a=xn[n],i=t[a],s=En[a];i===s||i&&i._merged||(t[a]=i?Cn(s,i):s)}}(r);var b=In(n.options)||p;return new pe("vue-component-".concat(n.cid).concat(b?"-".concat(b):""),r,void 0,void 0,void 0,o,{Ctor:n,propsData:m,listeners:f,tag:p,children:d},y)}}}function Cn(e,t){var n=function(n,a){e(n,a),t(n,a)};return n._merged=!0,n}var On=x,Pn=B.optionMergeStrategies;function Fn(e,t,n){if(void 0===n&&(n=!0),!t)return e;for(var a,i,s,r=oe?Reflect.ownKeys(t):Object.keys(t),o=0;o<r.length;o++)"__ob__"!==(a=r[o])&&(i=e[a],s=t[a],n&&T(e,a)?i!==s&&p(i)&&p(s)&&Fn(i,s):xe(e,a,s));return e}function zn(e,t,n){return n?function(){var a=o(t)?t.call(n,n):t,i=o(e)?e.call(n,n):e;return a?Fn(a,i):i}:t?e?function(){return Fn(o(t)?t.call(this,this):t,o(e)?e.call(this,this):e)}:t:e}function Nn(e,n){var a=n?e?e.concat(n):t(n)?n:[n]:e;return a?function(e){for(var t=[],n=0;n<e.length;n++)-1===t.indexOf(e[n])&&t.push(e[n]);return t}(a):a}function $n(e,t,n,a){var i=Object.create(e||null);return t?I(i,t):i}Pn.data=function(e,t,n){return n?zn(e,t,n):t&&"function"!=typeof t?e:zn(e,t)},$.forEach((function(e){Pn[e]=Nn})),N.forEach((function(e){Pn[e+"s"]=$n})),Pn.watch=function(e,n,a,i){if(e===ee&&(e=void 0),n===ee&&(n=void 0),!n)return Object.create(e||null);if(!e)return n;var s={};for(var r in I(s,e),n){var o=s[r],u=n[r];o&&!t(o)&&(o=[o]),s[r]=o?o.concat(u):t(u)?u:[u]}return s},Pn.props=Pn.methods=Pn.inject=Pn.computed=function(e,t,n,a){if(!e)return t;var i=Object.create(null);return I(i,e),t&&I(i,t),i},Pn.provide=function(e,t){return e?function(){var n=Object.create(null);return Fn(n,o(e)?e.call(this):e),t&&Fn(n,o(t)?t.call(this):t,!1),n}:t};var Bn=function(e,t){return void 0===t?e:t};function qn(e,n,a){if(o(n)&&(n=n.options),function(e,n){var a=e.props;if(a){var i,s,r={};if(t(a))for(i=a.length;i--;)"string"==typeof(s=a[i])&&(r[A(s)]={type:null});else if(p(a))for(var o in a)s=a[o],r[A(o)]=p(s)?s:{type:s};e.props=r}}(n),function(e,n){var a=e.inject;if(a){var i=e.inject={};if(t(a))for(var s=0;s<a.length;s++)i[a[s]]={from:a[s]};else if(p(a))for(var r in a){var o=a[r];i[r]=p(o)?I({from:r},o):{from:o}}}}(n),function(e){var t=e.directives;if(t)for(var n in t){var a=t[n];o(a)&&(t[n]={bind:a,update:a})}}(n),!n._base&&(n.extends&&(e=qn(e,n.extends,a)),n.mixins))for(var i=0,s=n.mixins.length;i<s;i++)e=qn(e,n.mixins[i],a);var r,u={};for(r in e)d(r);for(r in n)T(e,r)||d(r);function d(t){var i=Pn[t]||Bn;u[t]=i(e[t],n[t],a,t)}return u}function jn(e,t,n,a){if("string"==typeof n){var i=e[t];if(T(i,n))return i[n];var s=A(n);if(T(i,s))return i[s];var r=R(s);return T(i,r)?i[r]:i[n]||i[s]||i[r]}}function Vn(e,t,n,a){var i=t[e],s=!T(n,e),r=n[e],u=Gn(Boolean,i.type);if(u>-1)if(s&&!T(i,"default"))r=!1;else if(""===r||r===M(e)){var d=Gn(String,i.type);(d<0||u<d)&&(r=!0)}if(void 0===r){r=function(e,t,n){if(T(t,"default")){var a=t.default;return e&&e.$options.propsData&&void 0===e.$options.propsData[n]&&void 0!==e._props[n]?e._props[n]:o(a)&&"Function"!==Hn(t.type)?a.call(e):a}}(a,i,e);var p=Se;Me(!0),Ie(r),Me(p)}return r}var Un=/^\s*function (\w+)/;function Hn(e){var t=e&&e.toString().match(Un);return t?t[1]:""}function Wn(e,t){return Hn(e)===Hn(t)}function Gn(e,n){if(!t(n))return Wn(n,e)?0:-1;for(var a=0,i=n.length;a<i;a++)if(Wn(n[a],e))return a;return-1}function Qn(e){this._init(e)}function Zn(e){return e&&(In(e.Ctor.options)||e.tag)}function Yn(e,n){return t(e)?e.indexOf(n)>-1:"string"==typeof e?e.split(",").indexOf(n)>-1:(a=e,!("[object RegExp]"!==d.call(a))&&e.test(n));var a}function Kn(e,t){var n=e.cache,a=e.keys,i=e._vnode;for(var s in n){var r=n[s];if(r){var o=r.name;o&&!t(o)&&Xn(n,s,a,i)}}}function Xn(e,t,n,a){var i=e[t];!i||a&&i.tag===a.tag||i.componentInstance.$destroy(),e[t]=null,v(n,t)}!function(t){t.prototype._init=function(t){var n=this;n._uid=Rn++,n._isVue=!0,n.__v_skip=!0,n._scope=new Gt(!0),n._scope._vm=!0,t&&t._isComponent?function(e,t){var n=e.$options=Object.create(e.constructor.options),a=t._parentVnode;n.parent=t.parent,n._parentVnode=a;var i=a.componentOptions;n.propsData=i.propsData,n._parentListeners=i.listeners,n._renderChildren=i.children,n._componentTag=i.tag,t.render&&(n.render=t.render,n.staticRenderFns=t.staticRenderFns)}(n,t):n.$options=qn(Sn(n.constructor),t||{},n),n._renderProxy=n,n._self=n,function(e){var t=e.$options,n=t.parent;if(n&&!t.abstract){for(;n.$options.abstract&&n.$parent;)n=n.$parent;n.$children.push(e)}e.$parent=n,e.$root=n?n.$root:e,e.$children=[],e.$refs={},e._provided=n?n._provided:Object.create(null),e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var t=e.$options._parentListeners;t&&_t(e,t)}(n),function(t){t._vnode=null,t._staticTrees=null;var n=t.$options,a=t.$vnode=n._parentVnode,i=a&&a.context;t.$slots=lt(n._renderChildren,i),t.$scopedSlots=a?mt(t.$parent,a.data.scopedSlots,t.$slots):e,t._c=function(e,n,a,i){return Qe(t,e,n,a,i,!1)},t.$createElement=function(e,n,a,i){return Qe(t,e,n,a,i,!0)};var s=a&&a.data;Ee(t,"$attrs",s&&s.attrs||e,null,!0),Ee(t,"$listeners",n._parentListeners||e,null,!0)}(n),Ct(n,"beforeCreate",void 0,!1),function(e){var t=An(e.$options.inject,e);t&&(Me(!1),Object.keys(t).forEach((function(n){Ee(e,n,t[n])})),Me(!0))}(n),bn(n),function(e){var t=e.$options.provide;if(t){var n=o(t)?t.call(e):t;if(!u(n))return;for(var a=function(e){var t=e._provided,n=e.$parent&&e.$parent._provided;return n===t?e._provided=Object.create(n):t}(e),i=oe?Reflect.ownKeys(n):Object.keys(n),s=0;s<i.length;s++){var r=i[s];Object.defineProperty(a,r,Object.getOwnPropertyDescriptor(n,r))}}}(n),Ct(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(Qn),function(e){Object.defineProperty(e.prototype,"$data",{get:function(){return this._data}}),Object.defineProperty(e.prototype,"$props",{get:function(){return this._props}}),e.prototype.$set=xe,e.prototype.$delete=Le,e.prototype.$watch=function(e,t,n){var a=this;if(p(t))return kn(a,e,t,n);(n=n||{}).user=!0;var i=new mn(a,e,t,n);if(n.immediate){var s='callback for immediate watcher "'.concat(i.expression,'"');ge(),Zt(t,a,[i.value],a,s),Te()}return function(){i.teardown()}}}(Qn),function(e){var n=/^hook:/;e.prototype.$on=function(e,a){var i=this;if(t(e))for(var s=0,r=e.length;s<r;s++)i.$on(e[s],a);else(i._events[e]||(i._events[e]=[])).push(a),n.test(e)&&(i._hasHookEvent=!0);return i},e.prototype.$once=function(e,t){var n=this;function a(){n.$off(e,a),t.apply(n,arguments)}return a.fn=t,n.$on(e,a),n},e.prototype.$off=function(e,n){var a=this;if(!arguments.length)return a._events=Object.create(null),a;if(t(e)){for(var i=0,s=e.length;i<s;i++)a.$off(e[i],n);return a}var r,o=a._events[e];if(!o)return a;if(!n)return a._events[e]=null,a;for(var u=o.length;u--;)if((r=o[u])===n||r.fn===n){o.splice(u,1);break}return a},e.prototype.$emit=function(e){var t=this,n=t._events[e];if(n){n=n.length>1?D(n):n;for(var a=D(arguments,1),i='event handler for "'.concat(e,'"'),s=0,r=n.length;s<r;s++)Zt(n[s],t,a,t,i)}return t}}(Qn),function(e){e.prototype._update=function(e,t){var n=this,a=n.$el,i=n._vnode,s=It(n);n._vnode=e,n.$el=i?n.__patch__(i,e):n.__patch__(n.$el,e,t,!1),s(),a&&(a.__vue__=null),n.$el&&(n.$el.__vue__=n);for(var r=n;r&&r.$vnode&&r.$parent&&r.$vnode===r.$parent._vnode;)r.$parent.$el=r.$el,r=r.$parent},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){Ct(e,"beforeDestroy"),e._isBeingDestroyed=!0;var t=e.$parent;!t||t._isBeingDestroyed||e.$options.abstract||v(t.$children,e),e._scope.stop(),e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),Ct(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Qn),function(e){pt(e.prototype),e.prototype.$nextTick=function(e){return un(e,this)},e.prototype._render=function(){var e,n=this,a=n.$options,i=a.render,s=a._parentVnode;s&&n._isMounted&&(n.$scopedSlots=mt(n.$parent,s.data.scopedSlots,n.$slots,n.$scopedSlots),n._slotsProxy&&gt(n._slotsProxy,n.$scopedSlots)),n.$vnode=s;try{de(n),wt=n,e=i.call(n._renderProxy,n.$createElement)}catch(t){Qt(t,n,"render"),e=n._vnode}finally{wt=null,de()}return t(e)&&1===e.length&&(e=e[0]),e instanceof pe||(e=le()),e.parent=s,e}}(Qn);var Jn=[String,RegExp,Array],ea={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Jn,exclude:Jn,max:[String,Number]},methods:{cacheVNode:function(){var e=this,t=e.cache,n=e.keys,a=e.vnodeToCache,i=e.keyToCache;if(a){var s=a.tag,r=a.componentInstance,o=a.componentOptions;t[i]={name:Zn(o),tag:s,componentInstance:r},n.push(i),this.max&&n.length>parseInt(this.max)&&Xn(t,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Xn(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(t){Kn(e,(function(e){return Yn(t,e)}))})),this.$watch("exclude",(function(t){Kn(e,(function(e){return!Yn(t,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,t=At(e),n=t&&t.componentOptions;if(n){var a=Zn(n),i=this.include,s=this.exclude;if(i&&(!a||!Yn(i,a))||s&&a&&Yn(s,a))return t;var r=this.cache,o=this.keys,u=null==t.key?n.Ctor.cid+(n.tag?"::".concat(n.tag):""):t.key;r[u]?(t.componentInstance=r[u].componentInstance,v(o,u),o.push(u)):(this.vnodeToCache=t,this.keyToCache=u),t.data.keepAlive=!0}return t||e&&e[0]}}};!function(e){var t={get:function(){return B}};Object.defineProperty(e,"config",t),e.util={warn:On,extend:I,mergeOptions:qn,defineReactive:Ee},e.set=xe,e.delete=Le,e.nextTick=un,e.observable=function(e){return Ie(e),e},e.options=Object.create(null),N.forEach((function(t){e.options[t+"s"]=Object.create(null)})),e.options._base=e,I(e.options.components,ea),function(e){e.use=function(e){var t=this._installedPlugins||(this._installedPlugins=[]);if(t.indexOf(e)>-1)return this;var n=D(arguments,1);return n.unshift(this),o(e.install)?e.install.apply(e,n):o(e)&&e.apply(null,n),t.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=qn(this.options,e),this}}(e),function(e){e.cid=0;var t=1;e.extend=function(e){e=e||{};var n=this,a=n.cid,i=e._Ctor||(e._Ctor={});if(i[a])return i[a];var s=In(e)||In(n.options),r=function(e){this._init(e)};return(r.prototype=Object.create(n.prototype)).constructor=r,r.cid=t++,r.options=qn(n.options,e),r.super=n,r.options.props&&function(e){var t=e.options.props;for(var n in t)hn(e.prototype,"_props",n)}(r),r.options.computed&&function(e){var t=e.options.computed;for(var n in t)gn(e.prototype,n,t[n])}(r),r.extend=n.extend,r.mixin=n.mixin,r.use=n.use,N.forEach((function(e){r[e]=n[e]})),s&&(r.options.components[s]=r),r.superOptions=n.options,r.extendOptions=e,r.sealedOptions=I({},r.options),i[a]=r,r}}(e),function(e){N.forEach((function(t){e[t]=function(e,n){return n?("component"===t&&p(n)&&(n.name=n.name||e,n=this.options._base.extend(n)),"directive"===t&&o(n)&&(n={bind:n,update:n}),this.options[t+"s"][e]=n,n):this.options[t+"s"][e]}}))}(e)}(Qn),Object.defineProperty(Qn.prototype,"$isServer",{get:ae}),Object.defineProperty(Qn.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Qn,"FunctionalRenderContext",{value:Mn}),Qn.version="2.7.14";var ta=f("style,class"),na=f("input,textarea,option,select,progress"),aa=function(e,t,n){return"value"===n&&na(e)&&"button"!==t||"selected"===n&&"option"===e||"checked"===n&&"input"===e||"muted"===n&&"video"===e},ia=f("contenteditable,draggable,spellcheck"),sa=f("events,caret,typing,plaintext-only"),ra=function(e,t){return la(t)||"false"===t?"false":"contenteditable"===e&&sa(t)?t:"true"},oa=f("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ua="http://www.w3.org/1999/xlink",da=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},pa=function(e){return da(e)?e.slice(6,e.length):""},la=function(e){return null==e||!1===e};function ca(e,t){return{staticClass:ya(e.staticClass,t.staticClass),class:i(e.class)?[e.class,t.class]:t.class}}function ya(e,t){return e?t?e+" "+t:e:t||""}function ma(e){return Array.isArray(e)?function(e){for(var t,n="",a=0,s=e.length;a<s;a++)i(t=ma(e[a]))&&""!==t&&(n&&(n+=" "),n+=t);return n}(e):u(e)?function(e){var t="";for(var n in e)e[n]&&(t&&(t+=" "),t+=n);return t}(e):"string"==typeof e?e:""}var fa={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ha=f("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ba=f("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),va=function(e){return ha(e)||ba(e)};function ga(e){return ba(e)?"svg":"math"===e?"math":void 0}var Ta=Object.create(null),wa=f("text,number,password,search,email,tel,url");function ka(e){return"string"==typeof e?document.querySelector(e)||document.createElement("div"):e}var Aa=Object.freeze({__proto__:null,createElement:function(e,t){var n=document.createElement(e);return"select"!==e||t.data&&t.data.attrs&&void 0!==t.data.attrs.multiple&&n.setAttribute("multiple","multiple"),n},createElementNS:function(e,t){return document.createElementNS(fa[e],t)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,t,n){e.insertBefore(t,n)},removeChild:function(e,t){e.removeChild(t)},appendChild:function(e,t){e.appendChild(t)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,t){e.textContent=t},setStyleScope:function(e,t){e.setAttribute(t,"")}}),Ra={create:function(e,t){Sa(t)},update:function(e,t){e.data.ref!==t.data.ref&&(Sa(e,!0),Sa(t))},destroy:function(e){Sa(e,!0)}};function Sa(e,n){var a=e.data.ref;if(i(a)){var s=e.context,r=e.componentInstance||e.elm,u=n?null:r,d=n?void 0:r;if(o(a))Zt(a,s,[u],s,"template ref function");else{var p=e.data.refInFor,l="string"==typeof a||"number"==typeof a,c=Fe(a),y=s.$refs;if(l||c)if(p){var m=l?y[a]:a.value;n?t(m)&&v(m,r):t(m)?m.includes(r)||m.push(r):l?(y[a]=[r],Ma(s,a,y[a])):a.value=[r]}else if(l){if(n&&y[a]!==r)return;y[a]=d,Ma(s,a,u)}else if(c){if(n&&a.value!==r)return;a.value=u}}}}function Ma(e,t,n){var a=e._setupState;a&&T(a,t)&&(Fe(a[t])?a[t].value=n:a[t]=n)}var _a=new pe("",{},[]),Da=["create","activate","update","remove","destroy"];function Ia(e,t){return e.key===t.key&&e.asyncFactory===t.asyncFactory&&(e.tag===t.tag&&e.isComment===t.isComment&&i(e.data)===i(t.data)&&function(e,t){if("input"!==e.tag)return!0;var n,a=i(n=e.data)&&i(n=n.attrs)&&n.type,s=i(n=t.data)&&i(n=n.attrs)&&n.type;return a===s||wa(a)&&wa(s)}(e,t)||s(e.isAsyncPlaceholder)&&a(t.asyncFactory.error))}function Ea(e,t,n){var a,s,r={};for(a=t;a<=n;++a)i(s=e[a].key)&&(r[s]=a);return r}var xa={create:La,update:La,destroy:function(e){La(e,_a)}};function La(e,t){(e.data.directives||t.data.directives)&&function(e,t){var n,a,i,s=e===_a,r=t===_a,o=Oa(e.data.directives,e.context),u=Oa(t.data.directives,t.context),d=[],p=[];for(n in u)a=o[n],i=u[n],a?(i.oldValue=a.value,i.oldArg=a.arg,Fa(i,"update",t,e),i.def&&i.def.componentUpdated&&p.push(i)):(Fa(i,"bind",t,e),i.def&&i.def.inserted&&d.push(i));if(d.length){var l=function(){for(var n=0;n<d.length;n++)Fa(d[n],"inserted",t,e)};s?qe(t,"insert",l):l()}if(p.length&&qe(t,"postpatch",(function(){for(var n=0;n<p.length;n++)Fa(p[n],"componentUpdated",t,e)})),!s)for(n in o)u[n]||Fa(o[n],"unbind",e,e,r)}(e,t)}var Ca=Object.create(null);function Oa(e,t){var n,a,i=Object.create(null);if(!e)return i;for(n=0;n<e.length;n++){if((a=e[n]).modifiers||(a.modifiers=Ca),i[Pa(a)]=a,t._setupState&&t._setupState.__sfc){var s=a.def||jn(t,"_setupState","v-"+a.name);a.def="function"==typeof s?{bind:s,update:s}:s}a.def=a.def||jn(t.$options,"directives",a.name)}return i}function Pa(e){return e.rawName||"".concat(e.name,".").concat(Object.keys(e.modifiers||{}).join("."))}function Fa(e,t,n,a,i){var s=e.def&&e.def[t];if(s)try{s(n.elm,e,n,a,i)}catch(a){Qt(a,n.context,"directive ".concat(e.name," ").concat(t," hook"))}}var za=[Ra,xa];function Na(e,t){var n=t.componentOptions;if(!(i(n)&&!1===n.Ctor.options.inheritAttrs||a(e.data.attrs)&&a(t.data.attrs))){var r,o,u=t.elm,d=e.data.attrs||{},p=t.data.attrs||{};for(r in(i(p.__ob__)||s(p._v_attr_proxy))&&(p=t.data.attrs=I({},p)),p)o=p[r],d[r]!==o&&$a(u,r,o,t.data.pre);for(r in(Q||Y)&&p.value!==d.value&&$a(u,"value",p.value),d)a(p[r])&&(da(r)?u.removeAttributeNS(ua,pa(r)):ia(r)||u.removeAttribute(r))}}function $a(e,t,n,a){a||e.tagName.indexOf("-")>-1?Ba(e,t,n):oa(t)?la(n)?e.removeAttribute(t):(n="allowfullscreen"===t&&"EMBED"===e.tagName?"true":t,e.setAttribute(t,n)):ia(t)?e.setAttribute(t,ra(t,n)):da(t)?la(n)?e.removeAttributeNS(ua,pa(t)):e.setAttributeNS(ua,t,n):Ba(e,t,n)}function Ba(e,t,n){if(la(n))e.removeAttribute(t);else{if(Q&&!Z&&"TEXTAREA"===e.tagName&&"placeholder"===t&&""!==n&&!e.__ieph){var a=function(t){t.stopImmediatePropagation(),e.removeEventListener("input",a)};e.addEventListener("input",a),e.__ieph=!0}e.setAttribute(t,n)}}var qa={create:Na,update:Na};function ja(e,t){var n=t.elm,s=t.data,r=e.data;if(!(a(s.staticClass)&&a(s.class)&&(a(r)||a(r.staticClass)&&a(r.class)))){var o=function(e){for(var t=e.data,n=e,a=e;i(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(t=ca(a.data,t));for(;i(n=n.parent);)n&&n.data&&(t=ca(t,n.data));return s=t.staticClass,r=t.class,i(s)||i(r)?ya(s,ma(r)):"";var s,r}(t),u=n._transitionClasses;i(u)&&(o=ya(o,ma(u))),o!==n._prevClass&&(n.setAttribute("class",o),n._prevClass=o)}}var Va,Ua,Ha,Wa,Ga,Qa,Za={create:ja,update:ja},Ya=/[\w).+\-_$\]]/;function Ka(e){var t,n,a,i,s,r=!1,o=!1,u=!1,d=!1,p=0,l=0,c=0,y=0;for(a=0;a<e.length;a++)if(n=t,t=e.charCodeAt(a),r)39===t&&92!==n&&(r=!1);else if(o)34===t&&92!==n&&(o=!1);else if(u)96===t&&92!==n&&(u=!1);else if(d)47===t&&92!==n&&(d=!1);else if(124!==t||124===e.charCodeAt(a+1)||124===e.charCodeAt(a-1)||p||l||c){switch(t){case 34:o=!0;break;case 39:r=!0;break;case 96:u=!0;break;case 40:c++;break;case 41:c--;break;case 91:l++;break;case 93:l--;break;case 123:p++;break;case 125:p--}if(47===t){for(var m=a-1,f=void 0;m>=0&&" "===(f=e.charAt(m));m--);f&&Ya.test(f)||(d=!0)}}else void 0===i?(y=a+1,i=e.slice(0,a).trim()):h();function h(){(s||(s=[])).push(e.slice(y,a).trim()),y=a+1}if(void 0===i?i=e.slice(0,a).trim():0!==y&&h(),s)for(a=0;a<s.length;a++)i=Xa(i,s[a]);return i}function Xa(e,t){var n=t.indexOf("(");if(n<0)return'_f("'.concat(t,'")(').concat(e,")");var a=t.slice(0,n),i=t.slice(n+1);return'_f("'.concat(a,'")(').concat(e).concat(")"!==i?","+i:i)}function Ja(e,t){console.error("[Vue compiler]: ".concat(e))}function ei(e,t){return e?e.map((function(e){return e[t]})).filter((function(e){return e})):[]}function ti(e,t,n,a,i){(e.props||(e.props=[])).push(pi({name:t,value:n,dynamic:i},a)),e.plain=!1}function ni(e,t,n,a,i){(i?e.dynamicAttrs||(e.dynamicAttrs=[]):e.attrs||(e.attrs=[])).push(pi({name:t,value:n,dynamic:i},a)),e.plain=!1}function ai(e,t,n,a){e.attrsMap[t]=n,e.attrsList.push(pi({name:t,value:n},a))}function ii(e,t,n,a,i,s,r,o){(e.directives||(e.directives=[])).push(pi({name:t,rawName:n,value:a,arg:i,isDynamicArg:s,modifiers:r},o)),e.plain=!1}function si(e,t,n){return n?"_p(".concat(t,',"').concat(e,'")'):e+t}function ri(t,n,a,i,s,r,o,u){var d;(i=i||e).right?u?n="(".concat(n,")==='click'?'contextmenu':(").concat(n,")"):"click"===n&&(n="contextmenu",delete i.right):i.middle&&(u?n="(".concat(n,")==='click'?'mouseup':(").concat(n,")"):"click"===n&&(n="mouseup")),i.capture&&(delete i.capture,n=si("!",n,u)),i.once&&(delete i.once,n=si("~",n,u)),i.passive&&(delete i.passive,n=si("&",n,u)),i.native?(delete i.native,d=t.nativeEvents||(t.nativeEvents={})):d=t.events||(t.events={});var p=pi({value:a.trim(),dynamic:u},o);i!==e&&(p.modifiers=i);var l=d[n];Array.isArray(l)?s?l.unshift(p):l.push(p):d[n]=l?s?[p,l]:[l,p]:p,t.plain=!1}function oi(e,t,n){var a=ui(e,":"+t)||ui(e,"v-bind:"+t);if(null!=a)return Ka(a);if(!1!==n){var i=ui(e,t);if(null!=i)return JSON.stringify(i)}}function ui(e,t,n){var a;if(null!=(a=e.attrsMap[t]))for(var i=e.attrsList,s=0,r=i.length;s<r;s++)if(i[s].name===t){i.splice(s,1);break}return n&&delete e.attrsMap[t],a}function di(e,t){for(var n=e.attrsList,a=0,i=n.length;a<i;a++){var s=n[a];if(t.test(s.name))return n.splice(a,1),s}}function pi(e,t){return t&&(null!=t.start&&(e.start=t.start),null!=t.end&&(e.end=t.end)),e}function li(e,t,n){var a=n||{},i=a.number,s="$$v",r=s;a.trim&&(r="(typeof ".concat(s," === 'string'")+"? ".concat(s,".trim()")+": ".concat(s,")")),i&&(r="_n(".concat(r,")"));var o=ci(t,r);e.model={value:"(".concat(t,")"),expression:JSON.stringify(t),callback:"function (".concat(s,") {").concat(o,"}")}}function ci(e,t){var n=function(e){if(e=e.trim(),Va=e.length,e.indexOf("[")<0||e.lastIndexOf("]")<Va-1)return(Wa=e.lastIndexOf("."))>-1?{exp:e.slice(0,Wa),key:'"'+e.slice(Wa+1)+'"'}:{exp:e,key:null};for(Ua=e,Wa=Ga=Qa=0;!mi();)fi(Ha=yi())?bi(Ha):91===Ha&&hi(Ha);return{exp:e.slice(0,Ga),key:e.slice(Ga+1,Qa)}}(e);return null===n.key?"".concat(e,"=").concat(t):"$set(".concat(n.exp,", ").concat(n.key,", ").concat(t,")")}function yi(){return Ua.charCodeAt(++Wa)}function mi(){return Wa>=Va}function fi(e){return 34===e||39===e}function hi(e){var t=1;for(Ga=Wa;!mi();)if(fi(e=yi()))bi(e);else if(91===e&&t++,93===e&&t--,0===t){Qa=Wa;break}}function bi(e){for(var t=e;!mi()&&(e=yi())!==t;);}var vi,gi="__r",Ti="__c";function wi(e,t,n){var a=vi;return function i(){null!==t.apply(null,arguments)&&Ri(e,i,n,a)}}var ki=Jt&&!(J&&Number(J[1])<=53);function Ai(e,t,n,a){if(ki){var i=Bt,s=t;t=s._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return s.apply(this,arguments)}}vi.addEventListener(e,t,te?{capture:n,passive:a}:n)}function Ri(e,t,n,a){(a||vi).removeEventListener(e,t._wrapper||t,n)}function Si(e,t){if(!a(e.data.on)||!a(t.data.on)){var n=t.data.on||{},s=e.data.on||{};vi=t.elm||e.elm,function(e){if(i(e[gi])){var t=Q?"change":"input";e[t]=[].concat(e[gi],e[t]||[]),delete e[gi]}i(e[Ti])&&(e.change=[].concat(e[Ti],e.change||[]),delete e[Ti])}(n),Be(n,s,Ai,Ri,wi,t.context),vi=void 0}}var Mi,_i={create:Si,update:Si,destroy:function(e){return Si(e,_a)}};function Di(e,t){if(!a(e.data.domProps)||!a(t.data.domProps)){var n,r,o=t.elm,u=e.data.domProps||{},d=t.data.domProps||{};for(n in(i(d.__ob__)||s(d._v_attr_proxy))&&(d=t.data.domProps=I({},d)),u)n in d||(o[n]="");for(n in d){if(r=d[n],"textContent"===n||"innerHTML"===n){if(t.children&&(t.children.length=0),r===u[n])continue;1===o.childNodes.length&&o.removeChild(o.childNodes[0])}if("value"===n&&"PROGRESS"!==o.tagName){o._value=r;var p=a(r)?"":String(r);Ii(o,p)&&(o.value=p)}else if("innerHTML"===n&&ba(o.tagName)&&a(o.innerHTML)){(Mi=Mi||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var l=Mi.firstChild;o.firstChild;)o.removeChild(o.firstChild);for(;l.firstChild;)o.appendChild(l.firstChild)}else if(r!==u[n])try{o[n]=r}catch(e){}}}}function Ii(e,t){return!e.composing&&("OPTION"===e.tagName||function(e,t){var n=!0;try{n=document.activeElement!==e}catch(e){}return n&&e.value!==t}(e,t)||function(e,t){var n=e.value,a=e._vModifiers;if(i(a)){if(a.number)return m(n)!==m(t);if(a.trim)return n.trim()!==t.trim()}return n!==t}(e,t))}var Ei={create:Di,update:Di},xi=w((function(e){var t={},n=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var a=e.split(n);a.length>1&&(t[a[0].trim()]=a[1].trim())}})),t}));function Li(e){var t=Ci(e.style);return e.staticStyle?I(e.staticStyle,t):t}function Ci(e){return Array.isArray(e)?E(e):"string"==typeof e?xi(e):e}var Oi,Pi=/^--/,Fi=/\s*!important$/,zi=function(e,t,n){if(Pi.test(t))e.style.setProperty(t,n);else if(Fi.test(n))e.style.setProperty(M(t),n.replace(Fi,""),"important");else{var a=$i(t);if(Array.isArray(n))for(var i=0,s=n.length;i<s;i++)e.style[a]=n[i];else e.style[a]=n}},Ni=["Webkit","Moz","ms"],$i=w((function(e){if(Oi=Oi||document.createElement("div").style,"filter"!==(e=A(e))&&e in Oi)return e;for(var t=e.charAt(0).toUpperCase()+e.slice(1),n=0;n<Ni.length;n++){var a=Ni[n]+t;if(a in Oi)return a}}));function Bi(e,t){var n=t.data,s=e.data;if(!(a(n.staticStyle)&&a(n.style)&&a(s.staticStyle)&&a(s.style))){var r,o,u=t.elm,d=s.staticStyle,p=s.normalizedStyle||s.style||{},l=d||p,c=Ci(t.data.style)||{};t.data.normalizedStyle=i(c.__ob__)?I({},c):c;var y=function(e,t){for(var n,a={},i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(n=Li(i.data))&&I(a,n);(n=Li(e.data))&&I(a,n);for(var s=e;s=s.parent;)s.data&&(n=Li(s.data))&&I(a,n);return a}(t);for(o in l)a(y[o])&&zi(u,o,"");for(o in y)(r=y[o])!==l[o]&&zi(u,o,null==r?"":r)}}var qi={create:Bi,update:Bi},ji=/\s+/;function Vi(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(ji).forEach((function(t){return e.classList.add(t)})):e.classList.add(t);else{var n=" ".concat(e.getAttribute("class")||""," ");n.indexOf(" "+t+" ")<0&&e.setAttribute("class",(n+t).trim())}}function Ui(e,t){if(t&&(t=t.trim()))if(e.classList)t.indexOf(" ")>-1?t.split(ji).forEach((function(t){return e.classList.remove(t)})):e.classList.remove(t),e.classList.length||e.removeAttribute("class");else{for(var n=" ".concat(e.getAttribute("class")||""," "),a=" "+t+" ";n.indexOf(a)>=0;)n=n.replace(a," ");(n=n.trim())?e.setAttribute("class",n):e.removeAttribute("class")}}function Hi(e){if(e){if("object"==typeof e){var t={};return!1!==e.css&&I(t,Wi(e.name||"v")),I(t,e),t}return"string"==typeof e?Wi(e):void 0}}var Wi=w((function(e){return{enterClass:"".concat(e,"-enter"),enterToClass:"".concat(e,"-enter-to"),enterActiveClass:"".concat(e,"-enter-active"),leaveClass:"".concat(e,"-leave"),leaveToClass:"".concat(e,"-leave-to"),leaveActiveClass:"".concat(e,"-leave-active")}})),Gi=W&&!Z,Qi="transition",Zi="animation",Yi="transition",Ki="transitionend",Xi="animation",Ji="animationend";Gi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Yi="WebkitTransition",Ki="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Xi="WebkitAnimation",Ji="webkitAnimationEnd"));var es=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function ts(e){es((function(){es(e)}))}function ns(e,t){var n=e._transitionClasses||(e._transitionClasses=[]);n.indexOf(t)<0&&(n.push(t),Vi(e,t))}function as(e,t){e._transitionClasses&&v(e._transitionClasses,t),Ui(e,t)}function is(e,t,n){var a=rs(e,t),i=a.type,s=a.timeout,r=a.propCount;if(!i)return n();var o=i===Qi?Ki:Ji,u=0,d=function(){e.removeEventListener(o,p),n()},p=function(t){t.target===e&&++u>=r&&d()};setTimeout((function(){u<r&&d()}),s+1),e.addEventListener(o,p)}var ss=/\b(transform|all)(,|$)/;function rs(e,t){var n,a=window.getComputedStyle(e),i=(a[Yi+"Delay"]||"").split(", "),s=(a[Yi+"Duration"]||"").split(", "),r=os(i,s),o=(a[Xi+"Delay"]||"").split(", "),u=(a[Xi+"Duration"]||"").split(", "),d=os(o,u),p=0,l=0;return t===Qi?r>0&&(n=Qi,p=r,l=s.length):t===Zi?d>0&&(n=Zi,p=d,l=u.length):l=(n=(p=Math.max(r,d))>0?r>d?Qi:Zi:null)?n===Qi?s.length:u.length:0,{type:n,timeout:p,propCount:l,hasTransform:n===Qi&&ss.test(a[Yi+"Property"])}}function os(e,t){for(;e.length<t.length;)e=e.concat(e);return Math.max.apply(null,t.map((function(t,n){return us(t)+us(e[n])})))}function us(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function ds(e,t){var n=e.elm;i(n._leaveCb)&&(n._leaveCb.cancelled=!0,n._leaveCb());var s=Hi(e.data.transition);if(!a(s)&&!i(n._enterCb)&&1===n.nodeType){for(var r=s.css,d=s.type,p=s.enterClass,l=s.enterToClass,c=s.enterActiveClass,y=s.appearClass,f=s.appearToClass,h=s.appearActiveClass,b=s.beforeEnter,v=s.enter,g=s.afterEnter,T=s.enterCancelled,w=s.beforeAppear,k=s.appear,A=s.afterAppear,R=s.appearCancelled,S=s.duration,M=Dt,_=Dt.$vnode;_&&_.parent;)M=_.context,_=_.parent;var D=!M._isMounted||!e.isRootInsert;if(!D||k||""===k){var I=D&&y?y:p,E=D&&h?h:c,x=D&&f?f:l,L=D&&w||b,C=D&&o(k)?k:v,O=D&&A||g,P=D&&R||T,z=m(u(S)?S.enter:S),N=!1!==r&&!Z,$=cs(C),B=n._enterCb=F((function(){N&&(as(n,x),as(n,E)),B.cancelled?(N&&as(n,I),P&&P(n)):O&&O(n),n._enterCb=null}));e.data.show||qe(e,"insert",(function(){var t=n.parentNode,a=t&&t._pending&&t._pending[e.key];a&&a.tag===e.tag&&a.elm._leaveCb&&a.elm._leaveCb(),C&&C(n,B)})),L&&L(n),N&&(ns(n,I),ns(n,E),ts((function(){as(n,I),B.cancelled||(ns(n,x),$||(ls(z)?setTimeout(B,z):is(n,d,B)))}))),e.data.show&&(t&&t(),C&&C(n,B)),N||$||B()}}}function ps(e,t){var n=e.elm;i(n._enterCb)&&(n._enterCb.cancelled=!0,n._enterCb());var s=Hi(e.data.transition);if(a(s)||1!==n.nodeType)return t();if(!i(n._leaveCb)){var r=s.css,o=s.type,d=s.leaveClass,p=s.leaveToClass,l=s.leaveActiveClass,c=s.beforeLeave,y=s.leave,f=s.afterLeave,h=s.leaveCancelled,b=s.delayLeave,v=s.duration,g=!1!==r&&!Z,T=cs(y),w=m(u(v)?v.leave:v),k=n._leaveCb=F((function(){n.parentNode&&n.parentNode._pending&&(n.parentNode._pending[e.key]=null),g&&(as(n,p),as(n,l)),k.cancelled?(g&&as(n,d),h&&h(n)):(t(),f&&f(n)),n._leaveCb=null}));b?b(A):A()}function A(){k.cancelled||(!e.data.show&&n.parentNode&&((n.parentNode._pending||(n.parentNode._pending={}))[e.key]=e),c&&c(n),g&&(ns(n,d),ns(n,l),ts((function(){as(n,d),k.cancelled||(ns(n,p),T||(ls(w)?setTimeout(k,w):is(n,o,k)))}))),y&&y(n,k),g||T||k())}}function ls(e){return"number"==typeof e&&!isNaN(e)}function cs(e){if(a(e))return!1;var t=e.fns;return i(t)?cs(Array.isArray(t)?t[0]:t):(e._length||e.length)>1}function ys(e,t){!0!==t.data.show&&ds(t)}var ms=function(e){var n,o,u={},d=e.modules,p=e.nodeOps;for(n=0;n<Da.length;++n)for(u[Da[n]]=[],o=0;o<d.length;++o)i(d[o][Da[n]])&&u[Da[n]].push(d[o][Da[n]]);function l(e){var t=p.parentNode(e);i(t)&&p.removeChild(t,e)}function c(e,t,n,a,r,o,d){if(i(e.elm)&&i(o)&&(e=o[d]=ye(e)),e.isRootInsert=!r,!function(e,t,n,a){var r=e.data;if(i(r)){var o=i(e.componentInstance)&&r.keepAlive;if(i(r=r.hook)&&i(r=r.init)&&r(e,!1),i(e.componentInstance))return y(e,t),m(n,e.elm,a),s(o)&&function(e,t,n,a){for(var s,r=e;r.componentInstance;)if(i(s=(r=r.componentInstance._vnode).data)&&i(s=s.transition)){for(s=0;s<u.activate.length;++s)u.activate[s](_a,r);t.push(r);break}m(n,e.elm,a)}(e,t,n,a),!0}}(e,t,n,a)){var l=e.data,c=e.children,f=e.tag;i(f)?(e.elm=e.ns?p.createElementNS(e.ns,f):p.createElement(f,e),g(e),h(e,c,t),i(l)&&v(e,t),m(n,e.elm,a)):s(e.isComment)?(e.elm=p.createComment(e.text),m(n,e.elm,a)):(e.elm=p.createTextNode(e.text),m(n,e.elm,a))}}function y(e,t){i(e.data.pendingInsert)&&(t.push.apply(t,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,b(e)?(v(e,t),g(e)):(Sa(e),t.push(e))}function m(e,t,n){i(e)&&(i(n)?p.parentNode(n)===e&&p.insertBefore(e,t,n):p.appendChild(e,t))}function h(e,n,a){if(t(n))for(var i=0;i<n.length;++i)c(n[i],a,e.elm,null,!0,n,i);else r(e.text)&&p.appendChild(e.elm,p.createTextNode(String(e.text)))}function b(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return i(e.tag)}function v(e,t){for(var a=0;a<u.create.length;++a)u.create[a](_a,e);i(n=e.data.hook)&&(i(n.create)&&n.create(_a,e),i(n.insert)&&t.push(e))}function g(e){var t;if(i(t=e.fnScopeId))p.setStyleScope(e.elm,t);else for(var n=e;n;)i(t=n.context)&&i(t=t.$options._scopeId)&&p.setStyleScope(e.elm,t),n=n.parent;i(t=Dt)&&t!==e.context&&t!==e.fnContext&&i(t=t.$options._scopeId)&&p.setStyleScope(e.elm,t)}function T(e,t,n,a,i,s){for(;a<=i;++a)c(n[a],s,e,t,!1,n,a)}function w(e){var t,n,a=e.data;if(i(a))for(i(t=a.hook)&&i(t=t.destroy)&&t(e),t=0;t<u.destroy.length;++t)u.destroy[t](e);if(i(t=e.children))for(n=0;n<e.children.length;++n)w(e.children[n])}function k(e,t,n){for(;t<=n;++t){var a=e[t];i(a)&&(i(a.tag)?(A(a),w(a)):l(a.elm))}}function A(e,t){if(i(t)||i(e.data)){var n,a=u.remove.length+1;for(i(t)?t.listeners+=a:t=function(e,t){function n(){0==--n.listeners&&l(e)}return n.listeners=t,n}(e.elm,a),i(n=e.componentInstance)&&i(n=n._vnode)&&i(n.data)&&A(n,t),n=0;n<u.remove.length;++n)u.remove[n](e,t);i(n=e.data.hook)&&i(n=n.remove)?n(e,t):t()}else l(e.elm)}function R(e,t,n,a){for(var s=n;s<a;s++){var r=t[s];if(i(r)&&Ia(e,r))return s}}function S(e,t,n,r,o,d){if(e!==t){i(t.elm)&&i(r)&&(t=r[o]=ye(t));var l=t.elm=e.elm;if(s(e.isAsyncPlaceholder))i(t.asyncFactory.resolved)?D(e.elm,t,n):t.isAsyncPlaceholder=!0;else if(s(t.isStatic)&&s(e.isStatic)&&t.key===e.key&&(s(t.isCloned)||s(t.isOnce)))t.componentInstance=e.componentInstance;else{var y,m=t.data;i(m)&&i(y=m.hook)&&i(y=y.prepatch)&&y(e,t);var f=e.children,h=t.children;if(i(m)&&b(t)){for(y=0;y<u.update.length;++y)u.update[y](e,t);i(y=m.hook)&&i(y=y.update)&&y(e,t)}a(t.text)?i(f)&&i(h)?f!==h&&function(e,t,n,s,r){for(var o,u,d,l=0,y=0,m=t.length-1,f=t[0],h=t[m],b=n.length-1,v=n[0],g=n[b],w=!r;l<=m&&y<=b;)a(f)?f=t[++l]:a(h)?h=t[--m]:Ia(f,v)?(S(f,v,s,n,y),f=t[++l],v=n[++y]):Ia(h,g)?(S(h,g,s,n,b),h=t[--m],g=n[--b]):Ia(f,g)?(S(f,g,s,n,b),w&&p.insertBefore(e,f.elm,p.nextSibling(h.elm)),f=t[++l],g=n[--b]):Ia(h,v)?(S(h,v,s,n,y),w&&p.insertBefore(e,h.elm,f.elm),h=t[--m],v=n[++y]):(a(o)&&(o=Ea(t,l,m)),a(u=i(v.key)?o[v.key]:R(v,t,l,m))?c(v,s,e,f.elm,!1,n,y):Ia(d=t[u],v)?(S(d,v,s,n,y),t[u]=void 0,w&&p.insertBefore(e,d.elm,f.elm)):c(v,s,e,f.elm,!1,n,y),v=n[++y]);l>m?T(e,a(n[b+1])?null:n[b+1].elm,n,y,b,s):y>b&&k(t,l,m)}(l,f,h,n,d):i(h)?(i(e.text)&&p.setTextContent(l,""),T(l,null,h,0,h.length-1,n)):i(f)?k(f,0,f.length-1):i(e.text)&&p.setTextContent(l,""):e.text!==t.text&&p.setTextContent(l,t.text),i(m)&&i(y=m.hook)&&i(y=y.postpatch)&&y(e,t)}}}function M(e,t,n){if(s(n)&&i(e.parent))e.parent.data.pendingInsert=t;else for(var a=0;a<t.length;++a)t[a].data.hook.insert(t[a])}var _=f("attrs,class,staticClass,staticStyle,key");function D(e,t,n,a){var r,o=t.tag,u=t.data,d=t.children;if(a=a||u&&u.pre,t.elm=e,s(t.isComment)&&i(t.asyncFactory))return t.isAsyncPlaceholder=!0,!0;if(i(u)&&(i(r=u.hook)&&i(r=r.init)&&r(t,!0),i(r=t.componentInstance)))return y(t,n),!0;if(i(o)){if(i(d))if(e.hasChildNodes())if(i(r=u)&&i(r=r.domProps)&&i(r=r.innerHTML)){if(r!==e.innerHTML)return!1}else{for(var p=!0,l=e.firstChild,c=0;c<d.length;c++){if(!l||!D(l,d[c],n,a)){p=!1;break}l=l.nextSibling}if(!p||l)return!1}else h(t,d,n);if(i(u)){var m=!1;for(var f in u)if(!_(f)){m=!0,v(t,n);break}!m&&u.class&&ln(u.class)}}else e.data!==t.text&&(e.data=t.text);return!0}return function(e,t,n,r){if(!a(t)){var o,d=!1,l=[];if(a(e))d=!0,c(t,l);else{var y=i(e.nodeType);if(!y&&Ia(e,t))S(e,t,l,null,null,r);else{if(y){if(1===e.nodeType&&e.hasAttribute(z)&&(e.removeAttribute(z),n=!0),s(n)&&D(e,t,l))return M(t,l,!0),e;o=e,e=new pe(p.tagName(o).toLowerCase(),{},[],void 0,o)}var m=e.elm,f=p.parentNode(m);if(c(t,l,m._leaveCb?null:f,p.nextSibling(m)),i(t.parent))for(var h=t.parent,v=b(t);h;){for(var g=0;g<u.destroy.length;++g)u.destroy[g](h);if(h.elm=t.elm,v){for(var T=0;T<u.create.length;++T)u.create[T](_a,h);var A=h.data.hook.insert;if(A.merged)for(var R=1;R<A.fns.length;R++)A.fns[R]()}else Sa(h);h=h.parent}i(f)?k([e],0,0):i(e.tag)&&w(e)}}return M(t,l,d),t.elm}i(e)&&w(e)}}({nodeOps:Aa,modules:[qa,Za,_i,Ei,qi,W?{create:ys,activate:ys,remove:function(e,t){!0!==e.data.show?ps(e,t):t()}}:{}].concat(za)});Z&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&ks(e,"input")}));var fs={inserted:function(e,t,n,a){"select"===n.tag?(a.elm&&!a.elm._vOptions?qe(n,"postpatch",(function(){fs.componentUpdated(e,t,n)})):hs(e,t,n.context),e._vOptions=[].map.call(e.options,gs)):("textarea"===n.tag||wa(e.type))&&(e._vModifiers=t.modifiers,t.modifiers.lazy||(e.addEventListener("compositionstart",Ts),e.addEventListener("compositionend",ws),e.addEventListener("change",ws),Z&&(e.vmodel=!0)))},componentUpdated:function(e,t,n){if("select"===n.tag){hs(e,t,n.context);var a=e._vOptions,i=e._vOptions=[].map.call(e.options,gs);i.some((function(e,t){return!O(e,a[t])}))&&(e.multiple?t.value.some((function(e){return vs(e,i)})):t.value!==t.oldValue&&vs(t.value,i))&&ks(e,"change")}}};function hs(e,t,n){bs(e,t),(Q||Y)&&setTimeout((function(){bs(e,t)}),0)}function bs(e,t,n){var a=t.value,i=e.multiple;if(!i||Array.isArray(a)){for(var s,r,o=0,u=e.options.length;o<u;o++)if(r=e.options[o],i)s=P(a,gs(r))>-1,r.selected!==s&&(r.selected=s);else if(O(gs(r),a))return void(e.selectedIndex!==o&&(e.selectedIndex=o));i||(e.selectedIndex=-1)}}function vs(e,t){return t.every((function(t){return!O(t,e)}))}function gs(e){return"_value"in e?e._value:e.value}function Ts(e){e.target.composing=!0}function ws(e){e.target.composing&&(e.target.composing=!1,ks(e.target,"input"))}function ks(e,t){var n=document.createEvent("HTMLEvents");n.initEvent(t,!0,!0),e.dispatchEvent(n)}function As(e){return!e.componentInstance||e.data&&e.data.transition?e:As(e.componentInstance._vnode)}var Rs={model:fs,show:{bind:function(e,t,n){var a=t.value,i=(n=As(n)).data&&n.data.transition,s=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;a&&i?(n.data.show=!0,ds(n,(function(){e.style.display=s}))):e.style.display=a?s:"none"},update:function(e,t,n){var a=t.value;!a!=!t.oldValue&&((n=As(n)).data&&n.data.transition?(n.data.show=!0,a?ds(n,(function(){e.style.display=e.__vOriginalDisplay})):ps(n,(function(){e.style.display="none"}))):e.style.display=a?e.__vOriginalDisplay:"none")},unbind:function(e,t,n,a,i){i||(e.style.display=e.__vOriginalDisplay)}}},Ss={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Ms(e){var t=e&&e.componentOptions;return t&&t.Ctor.options.abstract?Ms(At(t.children)):e}function _s(e){var t={},n=e.$options;for(var a in n.propsData)t[a]=e[a];var i=n._parentListeners;for(var a in i)t[A(a)]=i[a];return t}function Ds(e,t){if(/\d-keep-alive$/.test(t.tag))return e("keep-alive",{props:t.componentOptions.propsData})}var Is=function(e){return e.tag||yt(e)},Es=function(e){return"show"===e.name},xs={name:"transition",props:Ss,abstract:!0,render:function(e){var t=this,n=this.$slots.default;if(n&&(n=n.filter(Is)).length){var a=this.mode,i=n[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var s=Ms(i);if(!s)return i;if(this._leaving)return Ds(e,i);var o="__transition-".concat(this._uid,"-");s.key=null==s.key?s.isComment?o+"comment":o+s.tag:r(s.key)?0===String(s.key).indexOf(o)?s.key:o+s.key:s.key;var u=(s.data||(s.data={})).transition=_s(this),d=this._vnode,p=Ms(d);if(s.data.directives&&s.data.directives.some(Es)&&(s.data.show=!0),p&&p.data&&!function(e,t){return t.key===e.key&&t.tag===e.tag}(s,p)&&!yt(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var l=p.data.transition=I({},u);if("out-in"===a)return this._leaving=!0,qe(l,"afterLeave",(function(){t._leaving=!1,t.$forceUpdate()})),Ds(e,i);if("in-out"===a){if(yt(s))return d;var c,y=function(){c()};qe(u,"afterEnter",y),qe(u,"enterCancelled",y),qe(l,"delayLeave",(function(e){c=e}))}}return i}}},Ls=I({tag:String,moveClass:String},Ss);delete Ls.mode;var Cs={props:Ls,beforeMount:function(){var e=this,t=this._update;this._update=function(n,a){var i=It(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),t.call(e,n,a)}},render:function(e){for(var t=this.tag||this.$vnode.data.tag||"span",n=Object.create(null),a=this.prevChildren=this.children,i=this.$slots.default||[],s=this.children=[],r=_s(this),o=0;o<i.length;o++)(p=i[o]).tag&&null!=p.key&&0!==String(p.key).indexOf("__vlist")&&(s.push(p),n[p.key]=p,(p.data||(p.data={})).transition=r);if(a){var u=[],d=[];for(o=0;o<a.length;o++){var p;(p=a[o]).data.transition=r,p.data.pos=p.elm.getBoundingClientRect(),n[p.key]?u.push(p):d.push(p)}this.kept=e(t,null,u),this.removed=d}return e(t,null,s)},updated:function(){var e=this.prevChildren,t=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,t)&&(e.forEach(Os),e.forEach(Ps),e.forEach(Fs),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var n=e.elm,a=n.style;ns(n,t),a.transform=a.WebkitTransform=a.transitionDuration="",n.addEventListener(Ki,n._moveCb=function e(a){a&&a.target!==n||a&&!/transform$/.test(a.propertyName)||(n.removeEventListener(Ki,e),n._moveCb=null,as(n,t))})}})))},methods:{hasMove:function(e,t){if(!Gi)return!1;if(this._hasMove)return this._hasMove;var n=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){Ui(n,e)})),Vi(n,t),n.style.display="none",this.$el.appendChild(n);var a=rs(n);return this.$el.removeChild(n),this._hasMove=a.hasTransform}}};function Os(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function Ps(e){e.data.newPos=e.elm.getBoundingClientRect()}function Fs(e){var t=e.data.pos,n=e.data.newPos,a=t.left-n.left,i=t.top-n.top;if(a||i){e.data.moved=!0;var s=e.elm.style;s.transform=s.WebkitTransform="translate(".concat(a,"px,").concat(i,"px)"),s.transitionDuration="0s"}}var zs={Transition:xs,TransitionGroup:Cs};Qn.config.mustUseProp=aa,Qn.config.isReservedTag=va,Qn.config.isReservedAttr=ta,Qn.config.getTagNamespace=ga,Qn.config.isUnknownElement=function(e){if(!W)return!0;if(va(e))return!1;if(e=e.toLowerCase(),null!=Ta[e])return Ta[e];var t=document.createElement(e);return e.indexOf("-")>-1?Ta[e]=t.constructor===window.HTMLUnknownElement||t.constructor===window.HTMLElement:Ta[e]=/HTMLUnknownElement/.test(t.toString())},I(Qn.options.directives,Rs),I(Qn.options.components,zs),Qn.prototype.__patch__=W?ms:x,Qn.prototype.$mount=function(e,t){return function(e,t,n){var a;e.$el=t,e.$options.render||(e.$options.render=le),Ct(e,"beforeMount"),a=function(){e._update(e._render(),n)},new mn(e,a,x,{before:function(){e._isMounted&&!e._isDestroyed&&Ct(e,"beforeUpdate")}},!0),n=!1;var i=e._preWatchers;if(i)for(var s=0;s<i.length;s++)i[s].run();return null==e.$vnode&&(e._isMounted=!0,Ct(e,"mounted")),e}(this,e=e&&W?ka(e):void 0,t)},W&&setTimeout((function(){B.devtools&&ie&&ie.emit("init",Qn)}),0);var Ns,$s=/\{\{((?:.|\r?\n)+?)\}\}/g,Bs=/[-.*+?^${}()|[\]\/\\]/g,qs=w((function(e){var t=e[0].replace(Bs,"\\$&"),n=e[1].replace(Bs,"\\$&");return new RegExp(t+"((?:.|\\n)+?)"+n,"g")})),js={staticKeys:["staticClass"],transformNode:function(e,t){t.warn;var n=ui(e,"class");n&&(e.staticClass=JSON.stringify(n.replace(/\s+/g," ").trim()));var a=oi(e,"class",!1);a&&(e.classBinding=a)},genData:function(e){var t="";return e.staticClass&&(t+="staticClass:".concat(e.staticClass,",")),e.classBinding&&(t+="class:".concat(e.classBinding,",")),t}},Vs={staticKeys:["staticStyle"],transformNode:function(e,t){t.warn;var n=ui(e,"style");n&&(e.staticStyle=JSON.stringify(xi(n)));var a=oi(e,"style",!1);a&&(e.styleBinding=a)},genData:function(e){var t="";return e.staticStyle&&(t+="staticStyle:".concat(e.staticStyle,",")),e.styleBinding&&(t+="style:(".concat(e.styleBinding,"),")),t}},Us=f("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),Hs=f("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),Ws=f("address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track"),Gs=/^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Qs=/^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+?\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,Zs="[a-zA-Z_][\\-\\.0-9_a-zA-Z".concat(q.source,"]*"),Ys="((?:".concat(Zs,"\\:)?").concat(Zs,")"),Ks=new RegExp("^<".concat(Ys)),Xs=/^\s*(\/?)>/,Js=new RegExp("^<\\/".concat(Ys,"[^>]*>")),er=/^<!DOCTYPE [^>]+>/i,tr=/^<!\--/,nr=/^<!\[/,ar=f("script,style,textarea",!0),ir={},sr={"&lt;":"<","&gt;":">","&quot;":'"',"&amp;":"&","&#10;":"\n","&#9;":"\t","&#39;":"'"},rr=/&(?:lt|gt|quot|amp|#39);/g,or=/&(?:lt|gt|quot|amp|#39|#10|#9);/g,ur=f("pre,textarea",!0),dr=function(e,t){return e&&ur(e)&&"\n"===t[0]};function pr(e,t){var n=t?or:rr;return e.replace(n,(function(e){return sr[e]}))}var lr,cr,yr,mr,fr,hr,br,vr,gr=/^@|^v-on:/,Tr=/^v-|^@|^:|^#/,wr=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,kr=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,Ar=/^\(|\)$/g,Rr=/^\[.*\]$/,Sr=/:(.*)$/,Mr=/^:|^\.|^v-bind:/,_r=/\.[^.\]]+(?=[^\]]*$)/g,Dr=/^v-slot(:|$)|^#/,Ir=/[\r\n]/,Er=/[ \f\t\r\n]+/g,xr=w((function(e){return(Ns=Ns||document.createElement("div")).innerHTML=e,Ns.textContent})),Lr="_empty_";function Cr(e,t,n){return{type:1,tag:e,attrsList:t,attrsMap:Br(t),rawAttrsMap:{},parent:n,children:[]}}function Or(e,t){lr=t.warn||Ja,hr=t.isPreTag||L,br=t.mustUseProp||L,vr=t.getTagNamespace||L;t.isReservedTag;yr=ei(t.modules,"transformNode"),mr=ei(t.modules,"preTransformNode"),fr=ei(t.modules,"postTransformNode"),cr=t.delimiters;var n,a,i=[],s=!1!==t.preserveWhitespace,r=t.whitespace,o=!1,u=!1;function d(e){if(p(e),o||e.processed||(e=Pr(e,t)),i.length||e===n||n.if&&(e.elseif||e.else)&&zr(n,{exp:e.elseif,block:e}),a&&!e.forbidden)if(e.elseif||e.else)r=e,d=function(e){for(var t=e.length;t--;){if(1===e[t].type)return e[t];e.pop()}}(a.children),d&&d.if&&zr(d,{exp:r.elseif,block:r});else{if(e.slotScope){var s=e.slotTarget||'"default"';(a.scopedSlots||(a.scopedSlots={}))[s]=e}a.children.push(e),e.parent=a}var r,d;e.children=e.children.filter((function(e){return!e.slotScope})),p(e),e.pre&&(o=!1),hr(e.tag)&&(u=!1);for(var l=0;l<fr.length;l++)fr[l](e,t)}function p(e){if(!u)for(var t=void 0;(t=e.children[e.children.length-1])&&3===t.type&&" "===t.text;)e.children.pop()}return function(e,t){for(var n,a,i=[],s=t.expectHTML,r=t.isUnaryTag||L,o=t.canBeLeftOpenTag||L,u=0,d=function(){if(n=e,a&&ar(a)){var d=0,c=a.toLowerCase(),y=ir[c]||(ir[c]=new RegExp("([\\s\\S]*?)(</"+c+"[^>]*>)","i"));k=e.replace(y,(function(e,n,a){return d=a.length,ar(c)||"noscript"===c||(n=n.replace(/<!\--([\s\S]*?)-->/g,"$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g,"$1")),dr(c,n)&&(n=n.slice(1)),t.chars&&t.chars(n),""})),u+=e.length-k.length,e=k,l(c,u-d,u)}else{var m=e.indexOf("<");if(0===m){if(tr.test(e)){var f=e.indexOf("--\x3e");if(f>=0)return t.shouldKeepComment&&t.comment&&t.comment(e.substring(4,f),u,u+f+3),p(f+3),"continue"}if(nr.test(e)){var h=e.indexOf("]>");if(h>=0)return p(h+2),"continue"}var b=e.match(er);if(b)return p(b[0].length),"continue";var v=e.match(Js);if(v){var g=u;return p(v[0].length),l(v[1],g,u),"continue"}var T=function(){var t=e.match(Ks);if(t){var n={tagName:t[1],attrs:[],start:u};p(t[0].length);for(var a=void 0,i=void 0;!(a=e.match(Xs))&&(i=e.match(Qs)||e.match(Gs));)i.start=u,p(i[0].length),i.end=u,n.attrs.push(i);if(a)return n.unarySlash=a[1],p(a[0].length),n.end=u,n}}();if(T)return function(e){var n=e.tagName,u=e.unarySlash;s&&("p"===a&&Ws(n)&&l(a),o(n)&&a===n&&l(n));for(var d=r(n)||!!u,p=e.attrs.length,c=new Array(p),y=0;y<p;y++){var m=e.attrs[y],f=m[3]||m[4]||m[5]||"",h="a"===n&&"href"===m[1]?t.shouldDecodeNewlinesForHref:t.shouldDecodeNewlines;c[y]={name:m[1],value:pr(f,h)}}d||(i.push({tag:n,lowerCasedTag:n.toLowerCase(),attrs:c,start:e.start,end:e.end}),a=n),t.start&&t.start(n,c,d,e.start,e.end)}(T),dr(T.tagName,e)&&p(1),"continue"}var w=void 0,k=void 0,A=void 0;if(m>=0){for(k=e.slice(m);!(Js.test(k)||Ks.test(k)||tr.test(k)||nr.test(k)||(A=k.indexOf("<",1))<0);)m+=A,k=e.slice(m);w=e.substring(0,m)}m<0&&(w=e),w&&p(w.length),t.chars&&w&&t.chars(w,u-w.length,u)}if(e===n)return t.chars&&t.chars(e),"break"};e&&"break"!==d(););function p(t){u+=t,e=e.substring(t)}function l(e,n,s){var r,o;if(null==n&&(n=u),null==s&&(s=u),e)for(o=e.toLowerCase(),r=i.length-1;r>=0&&i[r].lowerCasedTag!==o;r--);else r=0;if(r>=0){for(var d=i.length-1;d>=r;d--)t.end&&t.end(i[d].tag,n,s);i.length=r,a=r&&i[r-1].tag}else"br"===o?t.start&&t.start(e,[],!0,n,s):"p"===o&&(t.start&&t.start(e,[],!1,n,s),t.end&&t.end(e,n,s))}l()}(e,{warn:lr,expectHTML:t.expectHTML,isUnaryTag:t.isUnaryTag,canBeLeftOpenTag:t.canBeLeftOpenTag,shouldDecodeNewlines:t.shouldDecodeNewlines,shouldDecodeNewlinesForHref:t.shouldDecodeNewlinesForHref,shouldKeepComment:t.comments,outputSourceRange:t.outputSourceRange,start:function(e,s,r,p,l){var c=a&&a.ns||vr(e);Q&&"svg"===c&&(s=function(e){for(var t=[],n=0;n<e.length;n++){var a=e[n];qr.test(a.name)||(a.name=a.name.replace(jr,""),t.push(a))}return t}(s));var y,m=Cr(e,s,a);c&&(m.ns=c),"style"!==(y=m).tag&&("script"!==y.tag||y.attrsMap.type&&"text/javascript"!==y.attrsMap.type)||ae()||(m.forbidden=!0);for(var f=0;f<mr.length;f++)m=mr[f](m,t)||m;o||(function(e){null!=ui(e,"v-pre")&&(e.pre=!0)}(m),m.pre&&(o=!0)),hr(m.tag)&&(u=!0),o?function(e){var t=e.attrsList,n=t.length;if(n)for(var a=e.attrs=new Array(n),i=0;i<n;i++)a[i]={name:t[i].name,value:JSON.stringify(t[i].value)},null!=t[i].start&&(a[i].start=t[i].start,a[i].end=t[i].end);else e.pre||(e.plain=!0)}(m):m.processed||(Fr(m),function(e){var t=ui(e,"v-if");if(t)e.if=t,zr(e,{exp:t,block:e});else{null!=ui(e,"v-else")&&(e.else=!0);var n=ui(e,"v-else-if");n&&(e.elseif=n)}}(m),function(e){null!=ui(e,"v-once")&&(e.once=!0)}(m)),n||(n=m),r?d(m):(a=m,i.push(m))},end:function(e,t,n){var s=i[i.length-1];i.length-=1,a=i[i.length-1],d(s)},chars:function(e,t,n){if(a&&(!Q||"textarea"!==a.tag||a.attrsMap.placeholder!==e)){var i,d=a.children;if(e=u||e.trim()?"script"===(i=a).tag||"style"===i.tag?e:xr(e):d.length?r?"condense"===r&&Ir.test(e)?"":" ":s?" ":"":""){u||"condense"!==r||(e=e.replace(Er," "));var p=void 0,l=void 0;!o&&" "!==e&&(p=function(e,t){var n=t?qs(t):$s;if(n.test(e)){for(var a,i,s,r=[],o=[],u=n.lastIndex=0;a=n.exec(e);){(i=a.index)>u&&(o.push(s=e.slice(u,i)),r.push(JSON.stringify(s)));var d=Ka(a[1].trim());r.push("_s(".concat(d,")")),o.push({"@binding":d}),u=i+a[0].length}return u<e.length&&(o.push(s=e.slice(u)),r.push(JSON.stringify(s))),{expression:r.join("+"),tokens:o}}}(e,cr))?l={type:2,expression:p.expression,tokens:p.tokens,text:e}:" "===e&&d.length&&" "===d[d.length-1].text||(l={type:3,text:e}),l&&d.push(l)}}},comment:function(e,t,n){if(a){var i={type:3,text:e,isComment:!0};a.children.push(i)}}}),n}function Pr(e,t){var n;!function(e){var t=oi(e,"key");t&&(e.key=t)}(e),e.plain=!e.key&&!e.scopedSlots&&!e.attrsList.length,function(e){var t=oi(e,"ref");t&&(e.ref=t,e.refInFor=function(e){for(var t=e;t;){if(void 0!==t.for)return!0;t=t.parent}return!1}(e))}(e),function(e){var t;"template"===e.tag?(t=ui(e,"scope"),e.slotScope=t||ui(e,"slot-scope")):(t=ui(e,"slot-scope"))&&(e.slotScope=t);var n,a=oi(e,"slot");if(a&&(e.slotTarget='""'===a?'"default"':a,e.slotTargetDynamic=!(!e.attrsMap[":slot"]&&!e.attrsMap["v-bind:slot"]),"template"===e.tag||e.slotScope||ni(e,"slot",a,function(e,t){return e.rawAttrsMap[":"+t]||e.rawAttrsMap["v-bind:"+t]||e.rawAttrsMap[t]}(e,"slot"))),"template"===e.tag){if(n=di(e,Dr)){var i=Nr(n),s=i.name,r=i.dynamic;e.slotTarget=s,e.slotTargetDynamic=r,e.slotScope=n.value||Lr}}else if(n=di(e,Dr)){var o=e.scopedSlots||(e.scopedSlots={}),u=Nr(n),d=u.name,p=(r=u.dynamic,o[d]=Cr("template",[],e));p.slotTarget=d,p.slotTargetDynamic=r,p.children=e.children.filter((function(e){if(!e.slotScope)return e.parent=p,!0})),p.slotScope=n.value||Lr,e.children=[],e.plain=!1}}(e),"slot"===(n=e).tag&&(n.slotName=oi(n,"name")),function(e){var t;(t=oi(e,"is"))&&(e.component=t),null!=ui(e,"inline-template")&&(e.inlineTemplate=!0)}(e);for(var a=0;a<yr.length;a++)e=yr[a](e,t)||e;return function(e){var t,n,a,i,s,r,o,u,d=e.attrsList;for(t=0,n=d.length;t<n;t++)if(a=i=d[t].name,s=d[t].value,Tr.test(a))if(e.hasBindings=!0,(r=$r(a.replace(Tr,"")))&&(a=a.replace(_r,"")),Mr.test(a))a=a.replace(Mr,""),s=Ka(s),(u=Rr.test(a))&&(a=a.slice(1,-1)),r&&(r.prop&&!u&&"innerHtml"===(a=A(a))&&(a="innerHTML"),r.camel&&!u&&(a=A(a)),r.sync&&(o=ci(s,"$event"),u?ri(e,'"update:"+('.concat(a,")"),o,null,!1,0,d[t],!0):(ri(e,"update:".concat(A(a)),o,null,!1,0,d[t]),M(a)!==A(a)&&ri(e,"update:".concat(M(a)),o,null,!1,0,d[t])))),r&&r.prop||!e.component&&br(e.tag,e.attrsMap.type,a)?ti(e,a,s,d[t],u):ni(e,a,s,d[t],u);else if(gr.test(a))a=a.replace(gr,""),(u=Rr.test(a))&&(a=a.slice(1,-1)),ri(e,a,s,r,!1,0,d[t],u);else{var p=(a=a.replace(Tr,"")).match(Sr),l=p&&p[1];u=!1,l&&(a=a.slice(0,-(l.length+1)),Rr.test(l)&&(l=l.slice(1,-1),u=!0)),ii(e,a,i,s,l,u,r,d[t])}else ni(e,a,JSON.stringify(s),d[t]),!e.component&&"muted"===a&&br(e.tag,e.attrsMap.type,a)&&ti(e,a,"true",d[t])}(e),e}function Fr(e){var t;if(t=ui(e,"v-for")){var n=function(e){var t=e.match(wr);if(t){var n={};n.for=t[2].trim();var a=t[1].trim().replace(Ar,""),i=a.match(kr);return i?(n.alias=a.replace(kr,"").trim(),n.iterator1=i[1].trim(),i[2]&&(n.iterator2=i[2].trim())):n.alias=a,n}}(t);n&&I(e,n)}}function zr(e,t){e.ifConditions||(e.ifConditions=[]),e.ifConditions.push(t)}function Nr(e){var t=e.name.replace(Dr,"");return t||"#"!==e.name[0]&&(t="default"),Rr.test(t)?{name:t.slice(1,-1),dynamic:!0}:{name:'"'.concat(t,'"'),dynamic:!1}}function $r(e){var t=e.match(_r);if(t){var n={};return t.forEach((function(e){n[e.slice(1)]=!0})),n}}function Br(e){for(var t={},n=0,a=e.length;n<a;n++)t[e[n].name]=e[n].value;return t}var qr=/^xmlns:NS\d+/,jr=/^NS\d+:/;function Vr(e){return Cr(e.tag,e.attrsList.slice(),e.parent)}var Ur,Hr,Wr=[js,Vs,{preTransformNode:function(e,t){if("input"===e.tag){var n=e.attrsMap;if(!n["v-model"])return;var a=void 0;if((n[":type"]||n["v-bind:type"])&&(a=oi(e,"type")),n.type||a||!n["v-bind"]||(a="(".concat(n["v-bind"],").type")),a){var i=ui(e,"v-if",!0),s=i?"&&(".concat(i,")"):"",r=null!=ui(e,"v-else",!0),o=ui(e,"v-else-if",!0),u=Vr(e);Fr(u),ai(u,"type","checkbox"),Pr(u,t),u.processed=!0,u.if="(".concat(a,")==='checkbox'")+s,zr(u,{exp:u.if,block:u});var d=Vr(e);ui(d,"v-for",!0),ai(d,"type","radio"),Pr(d,t),zr(u,{exp:"(".concat(a,")==='radio'")+s,block:d});var p=Vr(e);return ui(p,"v-for",!0),ai(p,":type",a),Pr(p,t),zr(u,{exp:i,block:p}),r?u.else=!0:o&&(u.elseif=o),u}}}}],Gr={expectHTML:!0,modules:Wr,directives:{model:function(e,t,n){var a=t.value,i=t.modifiers,s=e.tag,r=e.attrsMap.type;if(e.component)return li(e,a,i),!1;if("select"===s)!function(e,t,n){var a=n&&n.number,i='Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;'+"return ".concat(a?"_n(val)":"val","})"),s="var $$selectedVal = ".concat(i,";");ri(e,"change",s="".concat(s," ").concat(ci(t,"$event.target.multiple ? $$selectedVal : $$selectedVal[0]")),null,!0)}(e,a,i);else if("input"===s&&"checkbox"===r)!function(e,t,n){var a=n&&n.number,i=oi(e,"value")||"null",s=oi(e,"true-value")||"true",r=oi(e,"false-value")||"false";ti(e,"checked","Array.isArray(".concat(t,")")+"?_i(".concat(t,",").concat(i,")>-1")+("true"===s?":(".concat(t,")"):":_q(".concat(t,",").concat(s,")"))),ri(e,"change","var $$a=".concat(t,",")+"$$el=$event.target,"+"$$c=$$el.checked?(".concat(s,"):(").concat(r,");")+"if(Array.isArray($$a)){"+"var $$v=".concat(a?"_n("+i+")":i,",")+"$$i=_i($$a,$$v);"+"if($$el.checked){$$i<0&&(".concat(ci(t,"$$a.concat([$$v])"),")}")+"else{$$i>-1&&(".concat(ci(t,"$$a.slice(0,$$i).concat($$a.slice($$i+1))"),")}")+"}else{".concat(ci(t,"$$c"),"}"),null,!0)}(e,a,i);else if("input"===s&&"radio"===r)!function(e,t,n){var a=n&&n.number,i=oi(e,"value")||"null";i=a?"_n(".concat(i,")"):i,ti(e,"checked","_q(".concat(t,",").concat(i,")")),ri(e,"change",ci(t,i),null,!0)}(e,a,i);else if("input"===s||"textarea"===s)!function(e,t,n){var a=e.attrsMap.type,i=n||{},s=i.lazy,r=i.number,o=i.trim,u=!s&&"range"!==a,d=s?"change":"range"===a?gi:"input",p="$event.target.value";o&&(p="$event.target.value.trim()"),r&&(p="_n(".concat(p,")"));var l=ci(t,p);u&&(l="if($event.target.composing)return;".concat(l)),ti(e,"value","(".concat(t,")")),ri(e,d,l,null,!0),(o||r)&&ri(e,"blur","$forceUpdate()")}(e,a,i);else if(!B.isReservedTag(s))return li(e,a,i),!1;return!0},text:function(e,t){t.value&&ti(e,"textContent","_s(".concat(t.value,")"),t)},html:function(e,t){t.value&&ti(e,"innerHTML","_s(".concat(t.value,")"),t)}},isPreTag:function(e){return"pre"===e},isUnaryTag:Us,mustUseProp:aa,canBeLeftOpenTag:Hs,isReservedTag:va,getTagNamespace:ga,staticKeys:function(e){return e.reduce((function(e,t){return e.concat(t.staticKeys||[])}),[]).join(",")}(Wr)},Qr=w((function(e){return f("type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap"+(e?","+e:""))}));function Zr(e,t){e&&(Ur=Qr(t.staticKeys||""),Hr=t.isReservedTag||L,Yr(e),Kr(e,!1))}function Yr(e){if(e.static=function(e){return 2!==e.type&&(3===e.type||!(!e.pre&&(e.hasBindings||e.if||e.for||h(e.tag)||!Hr(e.tag)||function(e){for(;e.parent;){if("template"!==(e=e.parent).tag)return!1;if(e.for)return!0}return!1}(e)||!Object.keys(e).every(Ur))))}(e),1===e.type){if(!Hr(e.tag)&&"slot"!==e.tag&&null==e.attrsMap["inline-template"])return;for(var t=0,n=e.children.length;t<n;t++){var a=e.children[t];Yr(a),a.static||(e.static=!1)}if(e.ifConditions)for(t=1,n=e.ifConditions.length;t<n;t++){var i=e.ifConditions[t].block;Yr(i),i.static||(e.static=!1)}}}function Kr(e,t){if(1===e.type){if((e.static||e.once)&&(e.staticInFor=t),e.static&&e.children.length&&(1!==e.children.length||3!==e.children[0].type))return void(e.staticRoot=!0);if(e.staticRoot=!1,e.children)for(var n=0,a=e.children.length;n<a;n++)Kr(e.children[n],t||!!e.for);if(e.ifConditions)for(n=1,a=e.ifConditions.length;n<a;n++)Kr(e.ifConditions[n].block,t)}}var Xr=/^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,Jr=/\([^)]*?\);*$/,eo=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,to={esc:27,tab:9,enter:13,space:32,up:38,left:37,right:39,down:40,delete:[8,46]},no={esc:["Esc","Escape"],tab:"Tab",enter:"Enter",space:[" ","Spacebar"],up:["Up","ArrowUp"],left:["Left","ArrowLeft"],right:["Right","ArrowRight"],down:["Down","ArrowDown"],delete:["Backspace","Delete","Del"]},ao=function(e){return"if(".concat(e,")return null;")},io={stop:"$event.stopPropagation();",prevent:"$event.preventDefault();",self:ao("$event.target !== $event.currentTarget"),ctrl:ao("!$event.ctrlKey"),shift:ao("!$event.shiftKey"),alt:ao("!$event.altKey"),meta:ao("!$event.metaKey"),left:ao("'button' in $event && $event.button !== 0"),middle:ao("'button' in $event && $event.button !== 1"),right:ao("'button' in $event && $event.button !== 2")};function so(e,t){var n=t?"nativeOn:":"on:",a="",i="";for(var s in e){var r=ro(e[s]);e[s]&&e[s].dynamic?i+="".concat(s,",").concat(r,","):a+='"'.concat(s,'":').concat(r,",")}return a="{".concat(a.slice(0,-1),"}"),i?n+"_d(".concat(a,",[").concat(i.slice(0,-1),"])"):n+a}function ro(e){if(!e)return"function(){}";if(Array.isArray(e))return"[".concat(e.map((function(e){return ro(e)})).join(","),"]");var t=eo.test(e.value),n=Xr.test(e.value),a=eo.test(e.value.replace(Jr,""));if(e.modifiers){var i="",s="",r=[],o=function(t){if(io[t])s+=io[t],to[t]&&r.push(t);else if("exact"===t){var n=e.modifiers;s+=ao(["ctrl","shift","alt","meta"].filter((function(e){return!n[e]})).map((function(e){return"$event.".concat(e,"Key")})).join("||"))}else r.push(t)};for(var u in e.modifiers)o(u);r.length&&(i+=function(e){return"if(!$event.type.indexOf('key')&&"+"".concat(e.map(oo).join("&&"),")return null;")}(r)),s&&(i+=s);var d=t?"return ".concat(e.value,".apply(null, arguments)"):n?"return (".concat(e.value,").apply(null, arguments)"):a?"return ".concat(e.value):e.value;return"function($event){".concat(i).concat(d,"}")}return t||n?e.value:"function($event){".concat(a?"return ".concat(e.value):e.value,"}")}function oo(e){var t=parseInt(e,10);if(t)return"$event.keyCode!==".concat(t);var n=to[e],a=no[e];return"_k($event.keyCode,"+"".concat(JSON.stringify(e),",")+"".concat(JSON.stringify(n),",")+"$event.key,"+"".concat(JSON.stringify(a))+")"}var uo={on:function(e,t){e.wrapListeners=function(e){return"_g(".concat(e,",").concat(t.value,")")}},bind:function(e,t){e.wrapData=function(n){return"_b(".concat(n,",'").concat(e.tag,"',").concat(t.value,",").concat(t.modifiers&&t.modifiers.prop?"true":"false").concat(t.modifiers&&t.modifiers.sync?",true":"",")")}},cloak:x},po=function(e){this.options=e,this.warn=e.warn||Ja,this.transforms=ei(e.modules,"transformCode"),this.dataGenFns=ei(e.modules,"genData"),this.directives=I(I({},uo),e.directives);var t=e.isReservedTag||L;this.maybeComponent=function(e){return!!e.component||!t(e.tag)},this.onceId=0,this.staticRenderFns=[],this.pre=!1};function lo(e,t){var n=new po(t),a=e?"script"===e.tag?"null":co(e,n):'_c("div")';return{render:"with(this){return ".concat(a,"}"),staticRenderFns:n.staticRenderFns}}function co(e,t){if(e.parent&&(e.pre=e.pre||e.parent.pre),e.staticRoot&&!e.staticProcessed)return yo(e,t);if(e.once&&!e.onceProcessed)return mo(e,t);if(e.for&&!e.forProcessed)return bo(e,t);if(e.if&&!e.ifProcessed)return fo(e,t);if("template"!==e.tag||e.slotTarget||t.pre){if("slot"===e.tag)return function(e,t){var n=e.slotName||'"default"',a=wo(e,t),i="_t(".concat(n).concat(a?",function(){return ".concat(a,"}"):""),s=e.attrs||e.dynamicAttrs?Ro((e.attrs||[]).concat(e.dynamicAttrs||[]).map((function(e){return{name:A(e.name),value:e.value,dynamic:e.dynamic}}))):null,r=e.attrsMap["v-bind"];return!s&&!r||a||(i+=",null"),s&&(i+=",".concat(s)),r&&(i+="".concat(s?"":",null",",").concat(r)),i+")"}(e,t);var n=void 0;if(e.component)n=function(e,t,n){var a=t.inlineTemplate?null:wo(t,n,!0);return"_c(".concat(e,",").concat(vo(t,n)).concat(a?",".concat(a):"",")")}(e.component,e,t);else{var a=void 0,i=t.maybeComponent(e);(!e.plain||e.pre&&i)&&(a=vo(e,t));var s=void 0,r=t.options.bindings;i&&r&&!1!==r.__isScriptSetup&&(s=function(e,t){var n=A(t),a=R(n),i=function(i){return e[t]===i?t:e[n]===i?n:e[a]===i?a:void 0},s=i("setup-const")||i("setup-reactive-const");if(s)return s;var r=i("setup-let")||i("setup-ref")||i("setup-maybe-ref");return r||void 0}(r,e.tag)),s||(s="'".concat(e.tag,"'"));var o=e.inlineTemplate?null:wo(e,t,!0);n="_c(".concat(s).concat(a?",".concat(a):"").concat(o?",".concat(o):"",")")}for(var u=0;u<t.transforms.length;u++)n=t.transforms[u](e,n);return n}return wo(e,t)||"void 0"}function yo(e,t){e.staticProcessed=!0;var n=t.pre;return e.pre&&(t.pre=e.pre),t.staticRenderFns.push("with(this){return ".concat(co(e,t),"}")),t.pre=n,"_m(".concat(t.staticRenderFns.length-1).concat(e.staticInFor?",true":"",")")}function mo(e,t){if(e.onceProcessed=!0,e.if&&!e.ifProcessed)return fo(e,t);if(e.staticInFor){for(var n="",a=e.parent;a;){if(a.for){n=a.key;break}a=a.parent}return n?"_o(".concat(co(e,t),",").concat(t.onceId++,",").concat(n,")"):co(e,t)}return yo(e,t)}function fo(e,t,n,a){return e.ifProcessed=!0,ho(e.ifConditions.slice(),t,n,a)}function ho(e,t,n,a){if(!e.length)return a||"_e()";var i=e.shift();return i.exp?"(".concat(i.exp,")?").concat(s(i.block),":").concat(ho(e,t,n,a)):"".concat(s(i.block));function s(e){return n?n(e,t):e.once?mo(e,t):co(e,t)}}function bo(e,t,n,a){var i=e.for,s=e.alias,r=e.iterator1?",".concat(e.iterator1):"",o=e.iterator2?",".concat(e.iterator2):"";return e.forProcessed=!0,"".concat(a||"_l","((").concat(i,"),")+"function(".concat(s).concat(r).concat(o,"){")+"return ".concat((n||co)(e,t))+"})"}function vo(e,t){var n="{",a=function(e,t){var n=e.directives;if(n){var a,i,s,r,o="directives:[",u=!1;for(a=0,i=n.length;a<i;a++){s=n[a],r=!0;var d=t.directives[s.name];d&&(r=!!d(e,s,t.warn)),r&&(u=!0,o+='{name:"'.concat(s.name,'",rawName:"').concat(s.rawName,'"').concat(s.value?",value:(".concat(s.value,"),expression:").concat(JSON.stringify(s.value)):"").concat(s.arg?",arg:".concat(s.isDynamicArg?s.arg:'"'.concat(s.arg,'"')):"").concat(s.modifiers?",modifiers:".concat(JSON.stringify(s.modifiers)):"","},"))}return u?o.slice(0,-1)+"]":void 0}}(e,t);a&&(n+=a+","),e.key&&(n+="key:".concat(e.key,",")),e.ref&&(n+="ref:".concat(e.ref,",")),e.refInFor&&(n+="refInFor:true,"),e.pre&&(n+="pre:true,"),e.component&&(n+='tag:"'.concat(e.tag,'",'));for(var i=0;i<t.dataGenFns.length;i++)n+=t.dataGenFns[i](e);if(e.attrs&&(n+="attrs:".concat(Ro(e.attrs),",")),e.props&&(n+="domProps:".concat(Ro(e.props),",")),e.events&&(n+="".concat(so(e.events,!1),",")),e.nativeEvents&&(n+="".concat(so(e.nativeEvents,!0),",")),e.slotTarget&&!e.slotScope&&(n+="slot:".concat(e.slotTarget,",")),e.scopedSlots&&(n+="".concat(function(e,t,n){var a=e.for||Object.keys(t).some((function(e){var n=t[e];return n.slotTargetDynamic||n.if||n.for||go(n)})),i=!!e.if;if(!a)for(var s=e.parent;s;){if(s.slotScope&&s.slotScope!==Lr||s.for){a=!0;break}s.if&&(i=!0),s=s.parent}var r=Object.keys(t).map((function(e){return To(t[e],n)})).join(",");return"scopedSlots:_u([".concat(r,"]").concat(a?",null,true":"").concat(!a&&i?",null,false,".concat(function(e){for(var t=5381,n=e.length;n;)t=33*t^e.charCodeAt(--n);return t>>>0}(r)):"",")")}(e,e.scopedSlots,t),",")),e.model&&(n+="model:{value:".concat(e.model.value,",callback:").concat(e.model.callback,",expression:").concat(e.model.expression,"},")),e.inlineTemplate){var s=function(e,t){var n=e.children[0];if(n&&1===n.type){var a=lo(n,t.options);return"inlineTemplate:{render:function(){".concat(a.render,"},staticRenderFns:[").concat(a.staticRenderFns.map((function(e){return"function(){".concat(e,"}")})).join(","),"]}")}}(e,t);s&&(n+="".concat(s,","))}return n=n.replace(/,$/,"")+"}",e.dynamicAttrs&&(n="_b(".concat(n,',"').concat(e.tag,'",').concat(Ro(e.dynamicAttrs),")")),e.wrapData&&(n=e.wrapData(n)),e.wrapListeners&&(n=e.wrapListeners(n)),n}function go(e){return 1===e.type&&("slot"===e.tag||e.children.some(go))}function To(e,t){var n=e.attrsMap["slot-scope"];if(e.if&&!e.ifProcessed&&!n)return fo(e,t,To,"null");if(e.for&&!e.forProcessed)return bo(e,t,To);var a=e.slotScope===Lr?"":String(e.slotScope),i="function(".concat(a,"){")+"return ".concat("template"===e.tag?e.if&&n?"(".concat(e.if,")?").concat(wo(e,t)||"undefined",":undefined"):wo(e,t)||"undefined":co(e,t),"}"),s=a?"":",proxy:true";return"{key:".concat(e.slotTarget||'"default"',",fn:").concat(i).concat(s,"}")}function wo(e,t,n,a,i){var s=e.children;if(s.length){var r=s[0];if(1===s.length&&r.for&&"template"!==r.tag&&"slot"!==r.tag){var o=n?t.maybeComponent(r)?",1":",0":"";return"".concat((a||co)(r,t)).concat(o)}var u=n?function(e,t){for(var n=0,a=0;a<e.length;a++){var i=e[a];if(1===i.type){if(ko(i)||i.ifConditions&&i.ifConditions.some((function(e){return ko(e.block)}))){n=2;break}(t(i)||i.ifConditions&&i.ifConditions.some((function(e){return t(e.block)})))&&(n=1)}}return n}(s,t.maybeComponent):0,d=i||Ao;return"[".concat(s.map((function(e){return d(e,t)})).join(","),"]").concat(u?",".concat(u):"")}}function ko(e){return void 0!==e.for||"template"===e.tag||"slot"===e.tag}function Ao(e,t){return 1===e.type?co(e,t):3===e.type&&e.isComment?function(e){return"_e(".concat(JSON.stringify(e.text),")")}(e):"_v(".concat(2===(n=e).type?n.expression:So(JSON.stringify(n.text)),")");var n}function Ro(e){for(var t="",n="",a=0;a<e.length;a++){var i=e[a],s=So(i.value);i.dynamic?n+="".concat(i.name,",").concat(s,","):t+='"'.concat(i.name,'":').concat(s,",")}return t="{".concat(t.slice(0,-1),"}"),n?"_d(".concat(t,",[").concat(n.slice(0,-1),"])"):t}function So(e){return e.replace(/\u2028/g,"\\u2028").replace(/\u2029/g,"\\u2029")}function Mo(e,t){try{return new Function(e)}catch(n){return t.push({err:n,code:e}),x}}function _o(e){var t=Object.create(null);return function(n,a,i){(a=I({},a)).warn,delete a.warn;var s=a.delimiters?String(a.delimiters)+n:n;if(t[s])return t[s];var r=e(n,a),o={},u=[];return o.render=Mo(r.render,u),o.staticRenderFns=r.staticRenderFns.map((function(e){return Mo(e,u)})),t[s]=o}}new RegExp("\\b"+"do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments".split(",").join("\\b|\\b")+"\\b"),new RegExp("\\b"+"delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b")+"\\s*\\([^\\)]*\\)");var Do,Io,Eo=(Do=function(e,t){var n=Or(e.trim(),t);!1!==t.optimize&&Zr(n,t);var a=lo(n,t);return{ast:n,render:a.render,staticRenderFns:a.staticRenderFns}},function(e){function t(t,n){var a=Object.create(e),i=[],s=[];if(n)for(var r in n.modules&&(a.modules=(e.modules||[]).concat(n.modules)),n.directives&&(a.directives=I(Object.create(e.directives||null),n.directives)),n)"modules"!==r&&"directives"!==r&&(a[r]=n[r]);a.warn=function(e,t,n){(n?s:i).push(e)};var o=Do(t.trim(),a);return o.errors=i,o.tips=s,o}return{compile:t,compileToFunctions:_o(t)}}),xo=Eo(Gr).compileToFunctions;function Lo(e){return(Io=Io||document.createElement("div")).innerHTML=e?'<a href="\n"/>':'<div a="\n"/>',Io.innerHTML.indexOf("&#10;")>0}var Co=!!W&&Lo(!1),Oo=!!W&&Lo(!0),Po=w((function(e){var t=ka(e);return t&&t.innerHTML})),Fo=Qn.prototype.$mount;function zo(e,t){for(var n in t)e[n]=t[n];return e}Qn.prototype.$mount=function(e,t){if((e=e&&ka(e))===document.body||e===document.documentElement)return this;var n=this.$options;if(!n.render){var a=n.template;if(a)if("string"==typeof a)"#"===a.charAt(0)&&(a=Po(a));else{if(!a.nodeType)return this;a=a.innerHTML}else e&&(a=function(e){if(e.outerHTML)return e.outerHTML;var t=document.createElement("div");return t.appendChild(e.cloneNode(!0)),t.innerHTML}(e));if(a){var i=xo(a,{outputSourceRange:!1,shouldDecodeNewlines:Co,shouldDecodeNewlinesForHref:Oo,delimiters:n.delimiters,comments:n.comments},this),s=i.render,r=i.staticRenderFns;n.render=s,n.staticRenderFns=r}}return Fo.call(this,e,t)},Qn.compile=xo;var No=/[!'()*]/g,$o=function(e){return"%"+e.charCodeAt(0).toString(16)},Bo=/%2C/g,qo=function(e){return encodeURIComponent(e).replace(No,$o).replace(Bo,",")};function jo(e){try{return decodeURIComponent(e)}catch(e){}return e}var Vo=function(e){return null==e||"object"==typeof e?e:String(e)};function Uo(e){var t={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var n=e.replace(/\+/g," ").split("="),a=jo(n.shift()),i=n.length>0?jo(n.join("=")):null;void 0===t[a]?t[a]=i:Array.isArray(t[a])?t[a].push(i):t[a]=[t[a],i]})),t):t}function Ho(e){var t=e?Object.keys(e).map((function(t){var n=e[t];if(void 0===n)return"";if(null===n)return qo(t);if(Array.isArray(n)){var a=[];return n.forEach((function(e){void 0!==e&&(null===e?a.push(qo(t)):a.push(qo(t)+"="+qo(e)))})),a.join("&")}return qo(t)+"="+qo(n)})).filter((function(e){return e.length>0})).join("&"):null;return t?"?"+t:""}var Wo=/\/?$/;function Go(e,t,n,a){var i=a&&a.options.stringifyQuery,s=t.query||{};try{s=Qo(s)}catch(e){}var r={name:t.name||e&&e.name,meta:e&&e.meta||{},path:t.path||"/",hash:t.hash||"",query:s,params:t.params||{},fullPath:Ko(t,i),matched:e?Yo(e):[]};return n&&(r.redirectedFrom=Ko(n,i)),Object.freeze(r)}function Qo(e){if(Array.isArray(e))return e.map(Qo);if(e&&"object"==typeof e){var t={};for(var n in e)t[n]=Qo(e[n]);return t}return e}var Zo=Go(null,{path:"/"});function Yo(e){for(var t=[];e;)t.unshift(e),e=e.parent;return t}function Ko(e,t){var n=e.path,a=e.query;void 0===a&&(a={});var i=e.hash;return void 0===i&&(i=""),(n||"/")+(t||Ho)(a)+i}function Xo(e,t,n){return t===Zo?e===t:!!t&&(e.path&&t.path?e.path.replace(Wo,"")===t.path.replace(Wo,"")&&(n||e.hash===t.hash&&Jo(e.query,t.query)):!(!e.name||!t.name)&&e.name===t.name&&(n||e.hash===t.hash&&Jo(e.query,t.query)&&Jo(e.params,t.params)))}function Jo(e,t){if(void 0===e&&(e={}),void 0===t&&(t={}),!e||!t)return e===t;var n=Object.keys(e).sort(),a=Object.keys(t).sort();return n.length===a.length&&n.every((function(n,i){var s=e[n];if(a[i]!==n)return!1;var r=t[n];return null==s||null==r?s===r:"object"==typeof s&&"object"==typeof r?Jo(s,r):String(s)===String(r)}))}function eu(e){for(var t=0;t<e.matched.length;t++){var n=e.matched[t];for(var a in n.instances){var i=n.instances[a],s=n.enteredCbs[a];if(i&&s){delete n.enteredCbs[a];for(var r=0;r<s.length;r++)i._isBeingDestroyed||s[r](i)}}}}var tu={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,t){var n=t.props,a=t.children,i=t.parent,s=t.data;s.routerView=!0;for(var r=i.$createElement,o=n.name,u=i.$route,d=i._routerViewCache||(i._routerViewCache={}),p=0,l=!1;i&&i._routerRoot!==i;){var c=i.$vnode?i.$vnode.data:{};c.routerView&&p++,c.keepAlive&&i._directInactive&&i._inactive&&(l=!0),i=i.$parent}if(s.routerViewDepth=p,l){var y=d[o],m=y&&y.component;return m?(y.configProps&&nu(m,s,y.route,y.configProps),r(m,s,a)):r()}var f=u.matched[p],h=f&&f.components[o];if(!f||!h)return d[o]=null,r();d[o]={component:h},s.registerRouteInstance=function(e,t){var n=f.instances[o];(t&&n!==e||!t&&n===e)&&(f.instances[o]=t)},(s.hook||(s.hook={})).prepatch=function(e,t){f.instances[o]=t.componentInstance},s.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==f.instances[o]&&(f.instances[o]=e.componentInstance),eu(u)};var b=f.props&&f.props[o];return b&&(zo(d[o],{route:u,configProps:b}),nu(h,s,u,b)),r(h,s,a)}};function nu(e,t,n,a){var i=t.props=function(e,t){switch(typeof t){case"undefined":return;case"object":return t;case"function":return t(e);case"boolean":return t?e.params:void 0}}(n,a);if(i){i=t.props=zo({},i);var s=t.attrs=t.attrs||{};for(var r in i)e.props&&r in e.props||(s[r]=i[r],delete i[r])}}function au(e,t,n){var a=e.charAt(0);if("/"===a)return e;if("?"===a||"#"===a)return t+e;var i=t.split("/");n&&i[i.length-1]||i.pop();for(var s=e.replace(/^\//,"").split("/"),r=0;r<s.length;r++){var o=s[r];".."===o?i.pop():"."!==o&&i.push(o)}return""!==i[0]&&i.unshift(""),i.join("/")}function iu(e){return e.replace(/\/(?:\s*\/)+/g,"/")}var su=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},ru=function e(t,n,a){return su(n)||(a=n||a,n=[]),a=a||{},t instanceof RegExp?function(e,t){var n=e.source.match(/\((?!\?)/g);if(n)for(var a=0;a<n.length;a++)t.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return bu(e,t)}(t,n):su(t)?function(t,n,a){for(var i=[],s=0;s<t.length;s++)i.push(e(t[s],n,a).source);return bu(new RegExp("(?:"+i.join("|")+")",vu(a)),n)}(t,n,a):function(e,t,n){return gu(lu(e,n),t,n)}(t,n,a)},ou=lu,uu=mu,du=gu,pu=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function lu(e,t){for(var n,a=[],i=0,s=0,r="",o=t&&t.delimiter||"/";null!=(n=pu.exec(e));){var u=n[0],d=n[1],p=n.index;if(r+=e.slice(s,p),s=p+u.length,d)r+=d[1];else{var l=e[s],c=n[2],y=n[3],m=n[4],f=n[5],h=n[6],b=n[7];r&&(a.push(r),r="");var v=null!=c&&null!=l&&l!==c,g="+"===h||"*"===h,T="?"===h||"*"===h,w=n[2]||o,k=m||f;a.push({name:y||i++,prefix:c||"",delimiter:w,optional:T,repeat:g,partial:v,asterisk:!!b,pattern:k?hu(k):b?".*":"[^"+fu(w)+"]+?"})}}return s<e.length&&(r+=e.substr(s)),r&&a.push(r),a}function cu(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function yu(e){return encodeURI(e).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function mu(e,t){for(var n=new Array(e.length),a=0;a<e.length;a++)"object"==typeof e[a]&&(n[a]=new RegExp("^(?:"+e[a].pattern+")$",vu(t)));return function(t,a){for(var i="",s=t||{},r=(a||{}).pretty?cu:encodeURIComponent,o=0;o<e.length;o++){var u=e[o];if("string"!=typeof u){var d,p=s[u.name];if(null==p){if(u.optional){u.partial&&(i+=u.prefix);continue}throw new TypeError('Expected "'+u.name+'" to be defined')}if(su(p)){if(!u.repeat)throw new TypeError('Expected "'+u.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(u.optional)continue;throw new TypeError('Expected "'+u.name+'" to not be empty')}for(var l=0;l<p.length;l++){if(d=r(p[l]),!n[o].test(d))throw new TypeError('Expected all "'+u.name+'" to match "'+u.pattern+'", but received `'+JSON.stringify(d)+"`");i+=(0===l?u.prefix:u.delimiter)+d}}else{if(d=u.asterisk?yu(p):r(p),!n[o].test(d))throw new TypeError('Expected "'+u.name+'" to match "'+u.pattern+'", but received "'+d+'"');i+=u.prefix+d}}else i+=u}return i}}function fu(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function hu(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function bu(e,t){return e.keys=t,e}function vu(e){return e&&e.sensitive?"":"i"}function gu(e,t,n){su(t)||(n=t||n,t=[]);for(var a=(n=n||{}).strict,i=!1!==n.end,s="",r=0;r<e.length;r++){var o=e[r];if("string"==typeof o)s+=fu(o);else{var u=fu(o.prefix),d="(?:"+o.pattern+")";t.push(o),o.repeat&&(d+="(?:"+u+d+")*"),s+=d=o.optional?o.partial?u+"("+d+")?":"(?:"+u+"("+d+"))?":u+"("+d+")"}}var p=fu(n.delimiter||"/"),l=s.slice(-p.length)===p;return a||(s=(l?s.slice(0,-p.length):s)+"(?:"+p+"(?=$))?"),s+=i?"$":a&&l?"":"(?="+p+"|$)",bu(new RegExp("^"+s,vu(n)),t)}ru.parse=ou,ru.compile=function(e,t){return mu(lu(e,t),t)},ru.tokensToFunction=uu,ru.tokensToRegExp=du;var Tu=Object.create(null);function wu(e,t,n){t=t||{};try{var a=Tu[e]||(Tu[e]=ru.compile(e));return"string"==typeof t.pathMatch&&(t[0]=t.pathMatch),a(t,{pretty:!0})}catch(e){return""}finally{delete t[0]}}function ku(e,t,n,a){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var s=(i=zo({},e)).params;return s&&"object"==typeof s&&(i.params=zo({},s)),i}if(!i.path&&i.params&&t){(i=zo({},i))._normalized=!0;var r=zo(zo({},t.params),i.params);if(t.name)i.name=t.name,i.params=r;else if(t.matched.length){var o=t.matched[t.matched.length-1].path;i.path=wu(o,r,t.path)}return i}var u=function(e){var t="",n="",a=e.indexOf("#");a>=0&&(t=e.slice(a),e=e.slice(0,a));var i=e.indexOf("?");return i>=0&&(n=e.slice(i+1),e=e.slice(0,i)),{path:e,query:n,hash:t}}(i.path||""),d=t&&t.path||"/",p=u.path?au(u.path,d,n||i.append):d,l=function(e,t,n){void 0===t&&(t={});var a,i=n||Uo;try{a=i(e||"")}catch(e){a={}}for(var s in t){var r=t[s];a[s]=Array.isArray(r)?r.map(Vo):Vo(r)}return a}(u.query,i.query,a&&a.options.parseQuery),c=i.hash||u.hash;return c&&"#"!==c.charAt(0)&&(c="#"+c),{_normalized:!0,path:p,query:l,hash:c}}var Au,Ru=function(){},Su={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var t=this,n=this.$router,a=this.$route,i=n.resolve(this.to,a,this.append),s=i.location,r=i.route,o=i.href,u={},d=n.options.linkActiveClass,p=n.options.linkExactActiveClass,l=null==d?"router-link-active":d,c=null==p?"router-link-exact-active":p,y=null==this.activeClass?l:this.activeClass,m=null==this.exactActiveClass?c:this.exactActiveClass,f=r.redirectedFrom?Go(null,ku(r.redirectedFrom),null,n):r;u[m]=Xo(a,f,this.exactPath),u[y]=this.exact||this.exactPath?u[m]:function(e,t){return 0===e.path.replace(Wo,"/").indexOf(t.path.replace(Wo,"/"))&&(!t.hash||e.hash===t.hash)&&function(e,t){for(var n in t)if(!(n in e))return!1;return!0}(e.query,t.query)}(a,f);var h=u[m]?this.ariaCurrentValue:null,b=function(e){Mu(e)&&(t.replace?n.replace(s,Ru):n.push(s,Ru))},v={click:Mu};Array.isArray(this.event)?this.event.forEach((function(e){v[e]=b})):v[this.event]=b;var g={class:u},T=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:o,route:r,navigate:b,isActive:u[y],isExactActive:u[m]});if(T){if(1===T.length)return T[0];if(T.length>1||!T.length)return 0===T.length?e():e("span",{},T)}if("a"===this.tag)g.on=v,g.attrs={href:o,"aria-current":h};else{var w=_u(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=zo({},w.data);for(var A in k.on=k.on||{},k.on){var R=k.on[A];A in v&&(k.on[A]=Array.isArray(R)?R:[R])}for(var S in v)S in k.on?k.on[S].push(v[S]):k.on[S]=b;var M=w.data.attrs=zo({},w.data.attrs);M.href=o,M["aria-current"]=h}else g.on=v}return e(this.tag,g,this.$slots.default)}};function Mu(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var t=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(t))return}return e.preventDefault&&e.preventDefault(),!0}}function _u(e){if(e)for(var t,n=0;n<e.length;n++){if("a"===(t=e[n]).tag)return t;if(t.children&&(t=_u(t.children)))return t}}var Du="undefined"!=typeof window;function Iu(e,t,n,a,i){var s=t||[],r=n||Object.create(null),o=a||Object.create(null);e.forEach((function(e){Eu(s,r,o,e,i)}));for(var u=0,d=s.length;u<d;u++)"*"===s[u]&&(s.push(s.splice(u,1)[0]),d--,u--);return{pathList:s,pathMap:r,nameMap:o}}function Eu(e,t,n,a,i,s){var r=a.path,o=a.name,u=a.pathToRegexpOptions||{},d=function(e,t,n){return n||(e=e.replace(/\/$/,"")),"/"===e[0]||null==t?e:iu(t.path+"/"+e)}(r,i,u.strict);"boolean"==typeof a.caseSensitive&&(u.sensitive=a.caseSensitive);var p={path:d,regex:xu(d,u),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:o,parent:i,matchAs:s,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};if(a.children&&a.children.forEach((function(a){var i=s?iu(s+"/"+a.path):void 0;Eu(e,t,n,a,p,i)})),t[p.path]||(e.push(p.path),t[p.path]=p),void 0!==a.alias)for(var l=Array.isArray(a.alias)?a.alias:[a.alias],c=0;c<l.length;++c){var y={path:l[c],children:a.children};Eu(e,t,n,y,i,p.path||"/")}o&&(n[o]||(n[o]=p))}function xu(e,t){return ru(e,[],t)}function Lu(e,t){var n=Iu(e),a=n.pathList,i=n.pathMap,s=n.nameMap;function r(e,n,r){var u=ku(e,n,!1,t),d=u.name;if(d){var p=s[d];if(!p)return o(null,u);var l=p.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof u.params&&(u.params={}),n&&"object"==typeof n.params)for(var c in n.params)!(c in u.params)&&l.indexOf(c)>-1&&(u.params[c]=n.params[c]);return u.path=wu(p.path,u.params),o(p,u,r)}if(u.path){u.params={};for(var y=0;y<a.length;y++){var m=a[y],f=i[m];if(Cu(f.regex,u.path,u.params))return o(f,u,r)}}return o(null,u)}function o(e,n,a){return e&&e.redirect?function(e,n){var a=e.redirect,i="function"==typeof a?a(Go(e,n,null,t)):a;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return o(null,n);var u=i,d=u.name,p=u.path,l=n.query,c=n.hash,y=n.params;if(l=u.hasOwnProperty("query")?u.query:l,c=u.hasOwnProperty("hash")?u.hash:c,y=u.hasOwnProperty("params")?u.params:y,d)return s[d],r({_normalized:!0,name:d,query:l,hash:c,params:y},void 0,n);if(p){var m=function(e,t){return au(e,t.parent?t.parent.path:"/",!0)}(p,e);return r({_normalized:!0,path:wu(m,y),query:l,hash:c},void 0,n)}return o(null,n)}(e,a||n):e&&e.matchAs?function(e,t,n){var a=r({_normalized:!0,path:wu(n,t.params)});if(a){var i=a.matched,s=i[i.length-1];return t.params=a.params,o(s,t)}return o(null,t)}(0,n,e.matchAs):Go(e,n,a,t)}return{match:r,addRoute:function(e,t){var n="object"!=typeof e?s[e]:void 0;Iu([t||e],a,i,s,n),n&&n.alias.length&&Iu(n.alias.map((function(e){return{path:e,children:[t]}})),a,i,s,n)},getRoutes:function(){return a.map((function(e){return i[e]}))},addRoutes:function(e){Iu(e,a,i,s)}}}function Cu(e,t,n){var a=t.match(e);if(!a)return!1;if(!n)return!0;for(var i=1,s=a.length;i<s;++i){var r=e.keys[i-1];r&&(n[r.name||"pathMatch"]="string"==typeof a[i]?jo(a[i]):a[i])}return!0}var Ou=Du&&window.performance&&window.performance.now?window.performance:Date;function Pu(){return Ou.now().toFixed(3)}var Fu=Pu();function zu(){return Fu}function Nu(e){return Fu=e}var $u=Object.create(null);function Bu(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,t=window.location.href.replace(e,""),n=zo({},window.history.state);return n.key=zu(),window.history.replaceState(n,"",t),window.addEventListener("popstate",Vu),function(){window.removeEventListener("popstate",Vu)}}function qu(e,t,n,a){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var s=function(){var e=zu();if(e)return $u[e]}(),r=i.call(e,t,n,a?s:null);r&&("function"==typeof r.then?r.then((function(e){Qu(e,s)})).catch((function(e){})):Qu(r,s))}))}}function ju(){var e=zu();e&&($u[e]={x:window.pageXOffset,y:window.pageYOffset})}function Vu(e){ju(),e.state&&e.state.key&&Nu(e.state.key)}function Uu(e){return Wu(e.x)||Wu(e.y)}function Hu(e){return{x:Wu(e.x)?e.x:window.pageXOffset,y:Wu(e.y)?e.y:window.pageYOffset}}function Wu(e){return"number"==typeof e}var Gu=/^#\d/;function Qu(e,t){var n,a="object"==typeof e;if(a&&"string"==typeof e.selector){var i=Gu.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var s=e.offset&&"object"==typeof e.offset?e.offset:{};t=function(e,t){var n=document.documentElement.getBoundingClientRect(),a=e.getBoundingClientRect();return{x:a.left-n.left-t.x,y:a.top-n.top-t.y}}(i,s={x:Wu((n=s).x)?n.x:0,y:Wu(n.y)?n.y:0})}else Uu(e)&&(t=Hu(e))}else a&&Uu(e)&&(t=Hu(e));t&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:t.x,top:t.y,behavior:e.behavior}):window.scrollTo(t.x,t.y))}var Zu,Yu=Du&&(-1===(Zu=window.navigator.userAgent).indexOf("Android 2.")&&-1===Zu.indexOf("Android 4.0")||-1===Zu.indexOf("Mobile Safari")||-1!==Zu.indexOf("Chrome")||-1!==Zu.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState;function Ku(e,t){ju();var n=window.history;try{if(t){var a=zo({},n.state);a.key=zu(),n.replaceState(a,"",e)}else n.pushState({key:Nu(Pu())},"",e)}catch(n){window.location[t?"replace":"assign"](e)}}function Xu(e){Ku(e,!0)}var Ju={redirected:2,aborted:4,cancelled:8,duplicated:16};function ed(e,t){return td(e,t,Ju.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+t.fullPath+'" with a new navigation.')}function td(e,t,n,a){var i=new Error(a);return i._isRouter=!0,i.from=e,i.to=t,i.type=n,i}var nd=["params","query","hash"];function ad(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function id(e,t){return ad(e)&&e._isRouter&&(null==t||e.type===t)}function sd(e,t,n){var a=function(i){i>=e.length?n():e[i]?t(e[i],(function(){a(i+1)})):a(i+1)};a(0)}function rd(e,t){return od(e.map((function(e){return Object.keys(e.components).map((function(n){return t(e.components[n],e.instances[n],e,n)}))})))}function od(e){return Array.prototype.concat.apply([],e)}var ud="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function dd(e){var t=!1;return function(){for(var n=[],a=arguments.length;a--;)n[a]=arguments[a];if(!t)return t=!0,e.apply(this,n)}}var pd=function(e,t){this.router=e,this.base=function(e){if(!e)if(Du){var t=document.querySelector("base");e=(e=t&&t.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";return"/"!==e.charAt(0)&&(e="/"+e),e.replace(/\/$/,"")}(t),this.current=Zo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function ld(e,t,n,a){var i=rd(e,(function(e,a,i,s){var r=function(e,t){return"function"!=typeof e&&(e=Au.extend(e)),e.options[t]}(e,t);if(r)return Array.isArray(r)?r.map((function(e){return n(e,a,i,s)})):n(r,a,i,s)}));return od(a?i.reverse():i)}function cd(e,t){if(t)return function(){return e.apply(t,arguments)}}pd.prototype.listen=function(e){this.cb=e},pd.prototype.onReady=function(e,t){this.ready?e():(this.readyCbs.push(e),t&&this.readyErrorCbs.push(t))},pd.prototype.onError=function(e){this.errorCbs.push(e)},pd.prototype.transitionTo=function(e,t,n){var a,i=this;try{a=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(t){t(e)})),e}var s=this.current;this.confirmTransition(a,(function(){i.updateRoute(a),t&&t(a),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(a,s)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(a)})))}),(function(e){n&&n(e),e&&!i.ready&&(id(e,Ju.redirected)&&s===Zo||(i.ready=!0,i.readyErrorCbs.forEach((function(t){t(e)}))))}))},pd.prototype.confirmTransition=function(e,t,n){var a=this,i=this.current;this.pending=e;var s,r,o=function(e){!id(e)&&ad(e)&&(a.errorCbs.length?a.errorCbs.forEach((function(t){t(e)})):console.error(e)),n&&n(e)},u=e.matched.length-1,d=i.matched.length-1;if(Xo(e,i)&&u===d&&e.matched[u]===i.matched[d])return this.ensureURL(),e.hash&&qu(this.router,i,e,!1),o(((r=td(s=i,e,Ju.duplicated,'Avoided redundant navigation to current location: "'+s.fullPath+'".')).name="NavigationDuplicated",r));var p,l=function(e,t){var n,a=Math.max(e.length,t.length);for(n=0;n<a&&e[n]===t[n];n++);return{updated:t.slice(0,n),activated:t.slice(n),deactivated:e.slice(n)}}(this.current.matched,e.matched),c=l.updated,y=l.deactivated,m=l.activated,f=[].concat(function(e){return ld(e,"beforeRouteLeave",cd,!0)}(y),this.router.beforeHooks,function(e){return ld(e,"beforeRouteUpdate",cd)}(c),m.map((function(e){return e.beforeEnter})),(p=m,function(e,t,n){var a=!1,i=0,s=null;rd(p,(function(e,t,r,o){if("function"==typeof e&&void 0===e.cid){a=!0,i++;var u,d=dd((function(t){var a;((a=t).__esModule||ud&&"Module"===a[Symbol.toStringTag])&&(t=t.default),e.resolved="function"==typeof t?t:Au.extend(t),r.components[o]=t,--i<=0&&n()})),p=dd((function(e){var t="Failed to resolve async component "+o+": "+e;s||(s=ad(e)?e:new Error(t),n(s))}));try{u=e(d,p)}catch(e){p(e)}if(u)if("function"==typeof u.then)u.then(d,p);else{var l=u.component;l&&"function"==typeof l.then&&l.then(d,p)}}})),a||n()})),h=function(t,n){if(a.pending!==e)return o(ed(i,e));try{t(e,i,(function(t){!1===t?(a.ensureURL(!0),o(function(e,t){return td(e,t,Ju.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+t.fullPath+'" via a navigation guard.')}(i,e))):ad(t)?(a.ensureURL(!0),o(t)):"string"==typeof t||"object"==typeof t&&("string"==typeof t.path||"string"==typeof t.name)?(o(function(e,t){return td(e,t,Ju.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var t={};return nd.forEach((function(n){n in e&&(t[n]=e[n])})),JSON.stringify(t,null,2)}(t)+'" via a navigation guard.')}(i,e)),"object"==typeof t&&t.replace?a.replace(t):a.push(t)):n(t)}))}catch(e){o(e)}};sd(f,h,(function(){var n=function(e){return ld(e,"beforeRouteEnter",(function(e,t,n,a){return function(e,t,n){return function(a,i,s){return e(a,i,(function(e){"function"==typeof e&&(t.enteredCbs[n]||(t.enteredCbs[n]=[]),t.enteredCbs[n].push(e)),s(e)}))}}(e,n,a)}))}(m);sd(n.concat(a.router.resolveHooks),h,(function(){if(a.pending!==e)return o(ed(i,e));a.pending=null,t(e),a.router.app&&a.router.app.$nextTick((function(){eu(e)}))}))}))},pd.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},pd.prototype.setupListeners=function(){},pd.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=Zo,this.pending=null};var yd=function(e){function t(t,n){e.call(this,t,n),this._startLocation=md(this.base)}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router,n=t.options.scrollBehavior,a=Yu&&n;a&&this.listeners.push(Bu());var i=function(){var n=e.current,i=md(e.base);e.current===Zo&&i===e._startLocation||e.transitionTo(i,(function(e){a&&qu(t,e,n,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},t.prototype.go=function(e){window.history.go(e)},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Ku(iu(a.base+e.fullPath)),qu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Xu(iu(a.base+e.fullPath)),qu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.ensureURL=function(e){if(md(this.base)!==this.current.fullPath){var t=iu(this.base+this.current.fullPath);e?Ku(t):Xu(t)}},t.prototype.getCurrentLocation=function(){return md(this.base)},t}(pd);function md(e){var t=window.location.pathname,n=t.toLowerCase(),a=e.toLowerCase();return!e||n!==a&&0!==n.indexOf(iu(a+"/"))||(t=t.slice(e.length)),(t||"/")+window.location.search+window.location.hash}var fd=function(e){function t(t,n,a){e.call(this,t,n),a&&function(e){var t=md(e);if(!/^\/#/.test(t))return window.location.replace(iu(e+"/#"+t)),!0}(this.base)||hd()}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var t=this.router.options.scrollBehavior,n=Yu&&t;n&&this.listeners.push(Bu());var a=function(){var t=e.current;hd()&&e.transitionTo(bd(),(function(a){n&&qu(e.router,a,t,!0),Yu||Td(a.fullPath)}))},i=Yu?"popstate":"hashchange";window.addEventListener(i,a),this.listeners.push((function(){window.removeEventListener(i,a)}))}},t.prototype.push=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){gd(e.fullPath),qu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this,i=this.current;this.transitionTo(e,(function(e){Td(e.fullPath),qu(a.router,e,i,!1),t&&t(e)}),n)},t.prototype.go=function(e){window.history.go(e)},t.prototype.ensureURL=function(e){var t=this.current.fullPath;bd()!==t&&(e?gd(t):Td(t))},t.prototype.getCurrentLocation=function(){return bd()},t}(pd);function hd(){var e=bd();return"/"===e.charAt(0)||(Td("/"+e),!1)}function bd(){var e=window.location.href,t=e.indexOf("#");return t<0?"":e=e.slice(t+1)}function vd(e){var t=window.location.href,n=t.indexOf("#");return(n>=0?t.slice(0,n):t)+"#"+e}function gd(e){Yu?Ku(vd(e)):window.location.hash=e}function Td(e){Yu?Xu(vd(e)):window.location.replace(vd(e))}var wd=function(e){function t(t,n){e.call(this,t,n),this.stack=[],this.index=-1}return e&&(t.__proto__=e),t.prototype=Object.create(e&&e.prototype),t.prototype.constructor=t,t.prototype.push=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index+1).concat(e),a.index++,t&&t(e)}),n)},t.prototype.replace=function(e,t,n){var a=this;this.transitionTo(e,(function(e){a.stack=a.stack.slice(0,a.index).concat(e),t&&t(e)}),n)},t.prototype.go=function(e){var t=this,n=this.index+e;if(!(n<0||n>=this.stack.length)){var a=this.stack[n];this.confirmTransition(a,(function(){var e=t.current;t.index=n,t.updateRoute(a),t.router.afterHooks.forEach((function(t){t&&t(a,e)}))}),(function(e){id(e,Ju.duplicated)&&(t.index=n)}))}},t.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},t.prototype.ensureURL=function(){},t}(pd),kd=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Lu(e.routes||[],this);var t=e.mode||"hash";switch(this.fallback="history"===t&&!Yu&&!1!==e.fallback,this.fallback&&(t="hash"),Du||(t="abstract"),this.mode=t,t){case"history":this.history=new yd(this,e.base);break;case"hash":this.history=new fd(this,e.base,this.fallback);break;case"abstract":this.history=new wd(this,e.base)}},Ad={currentRoute:{configurable:!0}};kd.prototype.match=function(e,t,n){return this.matcher.match(e,t,n)},Ad.currentRoute.get=function(){return this.history&&this.history.current},kd.prototype.init=function(e){var t=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var n=t.apps.indexOf(e);n>-1&&t.apps.splice(n,1),t.app===e&&(t.app=t.apps[0]||null),t.app||t.history.teardown()})),!this.app){this.app=e;var n=this.history;if(n instanceof yd||n instanceof fd){var a=function(e){n.setupListeners(),function(e){var a=n.current,i=t.options.scrollBehavior;Yu&&i&&"fullPath"in e&&qu(t,e,a,!1)}(e)};n.transitionTo(n.getCurrentLocation(),a,a)}n.listen((function(e){t.apps.forEach((function(t){t._route=e}))}))}},kd.prototype.beforeEach=function(e){return Sd(this.beforeHooks,e)},kd.prototype.beforeResolve=function(e){return Sd(this.resolveHooks,e)},kd.prototype.afterEach=function(e){return Sd(this.afterHooks,e)},kd.prototype.onReady=function(e,t){this.history.onReady(e,t)},kd.prototype.onError=function(e){this.history.onError(e)},kd.prototype.push=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.push(e,t,n)}));this.history.push(e,t,n)},kd.prototype.replace=function(e,t,n){var a=this;if(!t&&!n&&"undefined"!=typeof Promise)return new Promise((function(t,n){a.history.replace(e,t,n)}));this.history.replace(e,t,n)},kd.prototype.go=function(e){this.history.go(e)},kd.prototype.back=function(){this.go(-1)},kd.prototype.forward=function(){this.go(1)},kd.prototype.getMatchedComponents=function(e){var t=e?e.matched?e:this.resolve(e).route:this.currentRoute;return t?[].concat.apply([],t.matched.map((function(e){return Object.keys(e.components).map((function(t){return e.components[t]}))}))):[]},kd.prototype.resolve=function(e,t,n){var a=ku(e,t=t||this.history.current,n,this),i=this.match(a,t),s=i.redirectedFrom||i.fullPath,r=function(e,t,n){var a="hash"===n?"#"+t:t;return e?iu(e+"/"+a):a}(this.history.base,s,this.mode);return{location:a,route:i,href:r,normalizedTo:a,resolved:i}},kd.prototype.getRoutes=function(){return this.matcher.getRoutes()},kd.prototype.addRoute=function(e,t){this.matcher.addRoute(e,t),this.history.current!==Zo&&this.history.transitionTo(this.history.getCurrentLocation())},kd.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==Zo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(kd.prototype,Ad);var Rd=kd;function Sd(e,t){return e.push(t),function(){var n=e.indexOf(t);n>-1&&e.splice(n,1)}}kd.install=function e(t){if(!e.installed||Au!==t){e.installed=!0,Au=t;var n=function(e){return void 0!==e},a=function(e,t){var a=e.$options._parentVnode;n(a)&&n(a=a.data)&&n(a=a.registerRouteInstance)&&a(e,t)};t.mixin({beforeCreate:function(){n(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),t.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(t.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(t.prototype,"$route",{get:function(){return this._routerRoot._route}}),t.component("RouterView",tu),t.component("RouterLink",Su);var i=t.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},kd.version="3.6.5",kd.isNavigationFailure=id,kd.NavigationFailureType=Ju,kd.START_LOCATION=Zo,Du&&window.Vue&&window.Vue.use(kd);var Md=function(){var e=this._self._c;return e("div",{staticClass:"min-h-screen bg-gray-100 px-4 pt-6"},[e("router-view")],1)};function _d(e,t,n,a,i,s,r,o){var u,d="function"==typeof e?e.options:e;if(t&&(d.render=t,d.staticRenderFns=n,d._compiled=!0),a&&(d.functional=!0),s&&(d._scopeId="data-v-"+s),r?(u=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(r)},d._ssrRegister=u):i&&(u=o?function(){i.call(this,(d.functional?this.parent:this).$root.$options.shadowRoot)}:i),u)if(d.functional){d._injectStyles=u;var p=d.render;d.render=function(e,t){return u.call(t),p(e,t)}}else{var l=d.beforeCreate;d.beforeCreate=l?[].concat(l,u):[u]}return{exports:e,options:d}}Md._withStripped=!0,n(838);const Dd=_d({},Md,[],!1,null,null,null).exports;var Id=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("HeaderBar"),e._v(" "),t("div",{staticClass:"pb-32"},[t("div",{staticClass:"space-y-4"},[t("span",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.source)+"\n      ")]),e._v(" "),t("h1",{staticClass:"text-xl"},[e._v("\n        "+e._s(e.json.name)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.title)+"\n      ")]),e._v(" "),t("h2",{staticClass:"text-lg"},[e._v("\n        "+e._s(e.json.author)+"\n      ")]),e._v(" "),t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))])]),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.hasOwnProperty("constructor")?t("Member",{attrs:{json:e.json.constructor}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.receive?t("Member",{attrs:{json:e.json.receive}}):e._e()],1),e._v(" "),t("div",{staticClass:"mt-8"},[e.json.fallback?t("Member",{attrs:{json:e.json.fallback}}):e._e()],1),e._v(" "),e.json.events?t("MemberSet",{attrs:{title:"Events",json:e.json.events}}):e._e(),e._v(" "),e.json.stateVariables?t("MemberSet",{attrs:{title:"State Variables",json:e.json.stateVariables}}):e._e(),e._v(" "),e.json.methods?t("MemberSet",{attrs:{title:"Methods",json:e.json.methods}}):e._e()],1),e._v(" "),t("FooterBar")],1)};Id._withStripped=!0;var Ed=function(){var e=this,t=e._self._c;return t("div",{staticClass:"bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300"},[t("div",{staticClass:"w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto"},[t("button",{staticClass:"py-1 px-2 text-gray-500",on:{click:function(t){return e.openLink(e.repository)}}},[e._v("\n      built with "+e._s(e.name)+"\n    ")])])])};Ed._withStripped=!0;const xd=JSON.parse('{"u2":"hardhat-docgen","cj":"https://github.com/ItsNickBarry/hardhat-docgen"}'),Ld=_d({data:function(){return{repository:xd.cj,name:xd.u2}},methods:{openLink(e){window.open(e,"_blank")}}},Ed,[],!1,null,null,null).exports;var Cd=function(){var e=this._self._c;return e("div",{staticClass:"w-full border-b border-dashed py-2 border-gray-300"},[e("router-link",{staticClass:"py-2 text-gray-500",attrs:{to:"/"}},[this._v("\n    <- Go back\n  ")])],1)};Cd._withStripped=!0;const Od=_d({},Cd,[],!1,null,null,null).exports;var Pd=function(){var e=this,t=e._self._c;return t("div",{staticClass:"border-2 border-gray-400 border-dashed w-full p-2"},[t("h3",{staticClass:"text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed"},[e._v("\n    "+e._s(e.name)+" "+e._s(e.keywords)+" "+e._s(e.inputSignature)+"\n  ")]),e._v(" "),t("div",{staticClass:"space-y-3"},[t("p",[e._v(e._s(e.json.notice))]),e._v(" "),t("p",[e._v(e._s(e.json.details))]),e._v(" "),t("MemberSection",{attrs:{name:"Parameters",items:e.inputs}}),e._v(" "),t("MemberSection",{attrs:{name:"Return Values",items:e.outputs}})],1)])};Pd._withStripped=!0;var Fd=function(){var e=this,t=e._self._c;return e.items.length>0?t("ul",[t("h4",{staticClass:"text-lg"},[e._v("\n    "+e._s(e.name)+"\n  ")]),e._v(" "),e._l(e.items,(function(n,a){return t("li",{key:a},[t("span",{staticClass:"bg-gray-300"},[e._v(e._s(n.type))]),e._v(" "),t("b",[e._v(e._s(n.name||`_${a}`))]),n.desc?t("span",[e._v(": "),t("i",[e._v(e._s(n.desc))])]):e._e()])}))],2):e._e()};Fd._withStripped=!0;const zd={components:{MemberSection:_d({props:{name:{type:String,default:""},items:{type:Array,default:()=>new Array}}},Fd,[],!1,null,null,null).exports},props:{json:{type:Object,default:()=>new Object}},computed:{name:function(){return this.json.name||this.json.type},keywords:function(){let e=[];return this.json.stateMutability&&e.push(this.json.stateMutability),"true"===this.json.anonymous&&e.push("anonymous"),e.join(" ")},params:function(){return this.json.params||{}},returns:function(){return this.json.returns||{}},inputs:function(){return(this.json.inputs||[]).map((e=>({...e,desc:this.params[e.name]})))},inputSignature:function(){return`(${this.inputs.map((e=>e.type)).join(",")})`},outputs:function(){return(this.json.outputs||[]).map(((e,t)=>({...e,desc:this.returns[e.name||`_${t}`]})))},outputSignature:function(){return`(${this.outputs.map((e=>e.type)).join(",")})`}}},Nd=_d(zd,Pd,[],!1,null,null,null).exports;var $d=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full mt-8"},[t("h2",{staticClass:"text-lg"},[e._v(e._s(e.title))]),e._v(" "),e._l(Object.keys(e.json),(function(n){return t("Member",{key:n,staticClass:"mt-3",attrs:{json:e.json[n]}})}))],2)};$d._withStripped=!0;var Bd=_d({components:{Member:Nd},props:{title:{type:String,default:""},json:{type:Object,default:()=>new Object}}},$d,[],!1,null,null,null);const qd=_d({components:{Member:Nd,MemberSet:Bd.exports,HeaderBar:Od,FooterBar:Ld},props:{json:{type:Object,default:()=>new Object}}},Id,[],!1,null,null,null).exports;var jd=function(){var e=this,t=e._self._c;return t("div",{staticClass:"w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32"},[t("Branch",{attrs:{json:e.trees,name:"Sources:"}}),e._v(" "),t("FooterBar",{staticClass:"mt-20"})],1)};jd._withStripped=!0;var Vd=function(){var e=this,t=e._self._c;return t("div",[e._v("\n  "+e._s(e.name)+"\n  "),Array.isArray(e.json)?t("div",{staticClass:"pl-5"},e._l(e.json,(function(n,a){return t("div",{key:a},[t("router-link",{attrs:{to:`${n.source}:${n.name}`}},[e._v("\n        "+e._s(n.name)+"\n      ")])],1)})),0):t("div",{staticClass:"pl-5"},e._l(Object.keys(e.json),(function(n){return t("div",{key:n},[t("Branch",{attrs:{json:e.json[n],name:n}})],1)})),0)])};Vd._withStripped=!0;var Ud=_d({name:"Branch",props:{name:{type:String,default:null},json:{type:[Object,Array],default:()=>new Object}}},Vd,[],!1,null,null,null);const Hd=_d({components:{Branch:Ud.exports,FooterBar:Ld},props:{json:{type:Object,default:()=>new Object}},computed:{trees:function(){let e={};for(let t in this.json)t.replace("/","//").split(/\/(?=[^\/])/).reduce(function(e,n){if(!n.includes(":"))return e[n]=e[n]||{},e[n];{let[a]=n.split(":");e[a]=e[a]||[],e[a].push(this.json[t])}}.bind(this),e);return e}}},jd,[],!1,null,null,null).exports;Qn.use(Rd);const Wd={"contracts/diamonds/autoreflectiveStaking/ASLib.sol:ASLib":{source:"contracts/diamonds/autoreflectiveStaking/ASLib.sol",name:"ASLib",stateVariables:{"REWARD_DISTRIBUTOR_ROLE()":{inputs:[],name:"REWARD_DISTRIBUTOR_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:"Classic `AccessControl` role. Allowes the bearer to send and distribute rewards."}},methods:{"NAME_PREFIX()":{inputs:[],name:"NAME_PREFIX",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"SYMBOL_PREFIX()":{inputs:[],name:"SYMBOL_PREFIX",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}}},"contracts/diamonds/autoreflectiveStaking/DiamondAutoreflectiveStaking.sol:DiamondAutoreflectiveStaking":{source:"contracts/diamonds/autoreflectiveStaking/DiamondAutoreflectiveStaking.sol",name:"DiamondAutoreflectiveStaking",details:"This MUST aggregate all of the faucets interfaces, to be able to grasp a full view of ABI in one place.",notice:'IMPORTANT: all of the collective diamond interfaces MUST be prefixed with "Diamond" word.',events:{"AddressStatus(address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"who",type:"address"},{indexed:!0,internalType:"bool",name:"isExcluded",type:"bool"}],name:"AddressStatus",type:"event",params:{isExcluded:"True - an address receives. False - it does not.",who:"An address to receive fees or staking rewards."},notice:"Emits when an address `who` is included or excluded from autoreflective fees gathering and staking rewards."},"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"FeeReflected(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"FeeReflected",type:"event",params:{amount:"An absolute amount of fees."},notice:"Emits when fees that are enabled for each transfer (and the base of the fee would be an amount sent in each) and its greater then zero."},"RewardAdded(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"RewardAdded",type:"event",params:{amount:"An amount of reward tokens to be distributed to users."},notice:"Emits when reward tokens are added to the distribution to users."},"Staked(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"Staked",type:"event",params:{amount:"An amount of staking token staked."},notice:"Emits when staking operation has completed successfully."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."},"Withdrawn(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"Withdrawn",type:"event",params:{amount:"An amount of staking token withdrawn."},notice:"Emits when withdrawal operation has completed successfully."}},methods:{"_burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_burnFrom",outputs:[],stateMutability:"nonpayable",type:"function",params:{tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be burnt.",who:"An address from whom the burn proceeds. "},notice:"An internal diamond-wise that other facets could use to burn st-tokens from."},"_emitTransferEvent(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"_emitTransferEvent",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be transferred.",from:"An address `from`.",to:"An address `to`."},notice:"An internal diamond-wise that emits standard IERC20 Transfer event.  Utilized to provide an opportunity to trigger the event in the facets where ABI does not contain it."},"_getCurrentSupply()":{inputs:[],name:"_getCurrentSupply",outputs:[{components:[{internalType:"uint256",name:"rSupply",type:"uint256"},{internalType:"uint256",name:"tSupply",type:"uint256"}],internalType:"struct ASLib.Supply",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"An internal diamond-wise view function that returns current state of both real and reflected total supplies but accounting excluded and included addresses."},"_getRValues(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"},{internalType:"uint256",name:"tFee",type:"uint256"},{internalType:"uint256",name:"currentRate",type:"uint256"}],name:"_getRValues",outputs:[{components:[{internalType:"uint256",name:"rAmount",type:"uint256"},{internalType:"uint256",name:"rTransferAmount",type:"uint256"},{internalType:"uint256",name:"rFee",type:"uint256"}],internalType:"struct ASLib.RValues",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{currentRate:"An amount which represents the transformation rate between real and reflected total supply.",tAmount:"An amount of real share tokens to be calculated based on.",tFee:"An amount of fee per transaction (currently 0) in real share tokens."},returns:{_0:"A struct which represents reflected side of the balance."},notice:"An internal diamond-wise view function that calculates reflected side of the balance."},"_getRate()":{inputs:[],name:"_getRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"An internal diamond-wise view function that returns an amount which represents  the transformation rate between real and reflected total supply."},"_getTValues(uint256)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_getTValues",outputs:[{components:[{internalType:"uint256",name:"tTransferAmount",type:"uint256"},{internalType:"uint256",name:"tFee",type:"uint256"}],internalType:"struct ASLib.TValues",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{tAmount:"An amount of real share tokens to be calculated based on."},returns:{_0:"A struct which represents real side of the balance."},notice:"An internal diamond-wise view function that calculates real side of the balance."},"_getValues(uint256)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_getValues",outputs:[{components:[{components:[{internalType:"uint256",name:"rAmount",type:"uint256"},{internalType:"uint256",name:"rTransferAmount",type:"uint256"},{internalType:"uint256",name:"rFee",type:"uint256"}],internalType:"struct ASLib.RValues",name:"r",type:"tuple"},{components:[{internalType:"uint256",name:"tTransferAmount",type:"uint256"},{internalType:"uint256",name:"tFee",type:"uint256"}],internalType:"struct ASLib.TValues",name:"t",type:"tuple"}],internalType:"struct ASLib.Values",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{tAmount:"An amount of real share tokens to be calculated based on."},returns:{_0:"A struct which represents both sides of the balance."},notice:"An internal diamond-wise view function that calculates both sides of the balance: reflected and real."},"_mintTo(address,uint256)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_mintTo",outputs:[],stateMutability:"nonpayable",type:"function",params:{tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be minted.",who:"An address to whom the mint proceeds. "},notice:"An internal diamond-wise that other facets could use to mint st-tokens to."},"_transferBothExcluded(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferBothExcluded",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from excluded to excluded address."},"_transferFromExcluded(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferFromExcluded",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from excluded to non-excluded address."},"_transferStandard(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferStandard",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from non-excluded to non-excluded address."},"_transferToExcluded(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferToExcluded",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from non-excluded to excluded address."},"_updateTotalReflection()":{inputs:[],name:"_updateTotalReflection",outputs:[],stateMutability:"nonpayable",type:"function",notice:"An internal diamond-wise that updates the reflected total supply to distribute new tokens  (a reward thats coming from the responsible entity)."},"addDelayedSending(address,address,uint256,uint8)":{inputs:[{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"},{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"}],name:"addDelayedSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be sent.",dueToDuration:"A duration code.",receiver:"A receiver of the sending.",sendingToken:"Token to be sent."},notice:"Creates a delayed sending of any token to any receiver. Could only be called by the diamond itself."},"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"advise(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"advise",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{amount:"An amount of tokens of an entity which the advise about fees be based on."},returns:{_0:"Constant 0."},notice:"Returns the amount of fee based on who and what amount be transferred and placed fee upon.  For now returns constantly zero."},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the decimals places of the token."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",notice:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."},"excludeAccount(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"excludeAccount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event AddressStatus(...)`.",params:{account:"An address to be excluded."},notice:"Excludes an address from autoreflective fees gathering and staking rewards."},"getDelayedSending(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getDelayedSending",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{index:"Required index of the sending in the queue"},returns:{_0:"Found sending struct. "},notice:"Returns a sending struct with full info in the queue."},"getDequeSize()":{inputs:[],name:"getDequeSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"The size."},notice:"Returns size of the sendings queue."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"tTotal",type:"uint256"},{internalType:"uint256",name:"rTotal",type:"uint256"},{internalType:"uint256",name:"tFeeTotal",type:"uint256"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"uint8",name:"decimals",type:"uint8"},{internalType:"uint256",name:"totalStaked",type:"uint256"}],internalType:"struct ASLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"Returns whole state of the primitive variables in the diamond."},"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."},"getSendingsDeque()":{inputs:[],name:"getSendingsDeque",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"A deque of sendings. (Or queue of sendings.)"},notice:"Returns full array of sendings queue."},"getSendingsDequeIndiciesStored()":{inputs:[],name:"getSendingsDequeIndiciesStored",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",notice:"Returns an array of IDs of the sendings, that are stored in public mapping.Array on indicies stored in the queue."},"getTotalSendingsPerStaker(address)":{inputs:[{internalType:"address",name:"staker",type:"address"}],name:"getTotalSendingsPerStaker",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{staker:"A staker address to be search info for."},returns:{_0:"A sum of tokens that are going to eventuely go to the `staker`."},notice:"Returns sum of all sendings to be delivered to certain `staker`."},"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"includeAccount(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"includeAccount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event AddressStatus(...)`.",params:{account:"An address to be included back."},notice:"Includes an address back to autoreflective fees gathering and staking rewards."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",notice:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"initialize(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"token",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"An address for the governing purposes.",token:"A token that should be staked in and act as a reward."},notice:"An initializer function for Locus Token owner and starting state of the inflation."},"isExcluded(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"isExcluded",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{account:"An account to be checked."},returns:{_0:"True if an address is excluded. False - if it does not."},notice:"Checks if an account were either inlcuded or excluded from fees and staking rewards distribution."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event RewardAdded(...)`.",params:{amount:"An amount of reward tokens to be distributed."},notice:"Sends from `msg.sender` reward tokens to be distributed among users."},"processQueue()":{inputs:[],name:"processQueue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Cleares the queue. Iterates over every element in the queue, and if the sendings due is now, executes the sending.  If not, sets it back."},"reflectionFromToken(uint256,bool)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"},{internalType:"bool",name:"addTransferFee",type:"bool"}],name:"reflectionFromToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{addTransferFee:"An account the fees that could be applied.",tAmount:"A real amount of share tokens."},returns:{_0:"A reflected amount of share tokens."},notice:"Returns a reflected amount against real amount of share tokens."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event Staked(...)`.",params:{amount:"An amount of staking token to be staked."},notice:"Stakes a number of staking tokens."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token."},"tokenFromReflection(uint256)":{inputs:[{internalType:"uint256",name:"rAmount",type:"uint256"}],name:"tokenFromReflection",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rAmount:"A reflected amount of share tokens."},returns:{_0:"A real amount of share tokens."},notice:"Returns a real amount against reflected amount of share tokens."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event Withdrawn(...)`.",params:{amount:"An amount of staking token to be withdrawn.",dueDuration:"Code of time interval after which the tokens would be sent to the `msg.sender`."},notice:"Withdraws a number of staking tokens."}}},"contracts/diamonds/autoreflectiveStaking/v1/ASDepositaryFacet.sol:ASDepositaryFacet":{source:"contracts/diamonds/autoreflectiveStaking/v1/ASDepositaryFacet.sol",name:"ASDepositaryFacet",title:"A facet that implements the depositary logic for users. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"RewardAdded(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"RewardAdded",type:"event",params:{amount:"An amount of reward tokens to be distributed to users."},notice:"Emits when reward tokens are added to the distribution to users."},"Staked(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"Staked",type:"event",params:{amount:"An amount of staking token staked."},notice:"Emits when staking operation has completed successfully."},"Withdrawn(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"Withdrawn",type:"event",params:{amount:"An amount of staking token withdrawn."},notice:"Emits when withdrawal operation has completed successfully."}},methods:{"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event RewardAdded(...)`.",params:{amount:"An amount of reward tokens to be distributed."},notice:"Sends from `msg.sender` reward tokens to be distributed among users."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event Staked(...)`.",params:{amount:"An amount of staking token to be staked."},notice:"Stakes a number of staking tokens."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event Withdrawn(...)`.",params:{amount:"An amount of staking token to be withdrawn.",dueDuration:"Code of time interval after which the tokens would be sent to the `msg.sender`."},notice:"Withdraws a number of staking tokens."}}},"contracts/diamonds/autoreflectiveStaking/v1/ASEip20Facet.sol:ASEip20Facet":{source:"contracts/diamonds/autoreflectiveStaking/v1/ASEip20Facet.sol",name:"ASEip20Facet",title:"A facet that implements the EIP20 logic. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"_emitTransferEvent(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"_emitTransferEvent",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be transferred.",from:"An address `from`.",to:"An address `to`."},notice:"An internal diamond-wise that emits standard IERC20 Transfer event.  Utilized to provide an opportunity to trigger the event in the facets where ABI does not contain it."},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the decimals places of the token."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",notice:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",notice:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/diamonds/autoreflectiveStaking/v1/ASFeeAdvisorFacet.sol:ASFeeAdvisorFacet":{source:"contracts/diamonds/autoreflectiveStaking/v1/ASFeeAdvisorFacet.sol",name:"ASFeeAdvisorFacet",title:"A facet that implements the fee calculation logic. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"advise(uint256)":{inputs:[{internalType:"uint256",name:"",type:"uint256"}],name:"advise",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",params:{amount:"An amount of tokens of an entity which the advise about fees be based on."},returns:{_0:"Constant 0."},notice:"Returns the amount of fee based on who and what amount be transferred and placed fee upon.  For now returns constantly zero."}}},"contracts/diamonds/autoreflectiveStaking/v1/ASInitializerFacet.sol:ASInitializerFacet":{source:"contracts/diamonds/autoreflectiveStaking/v1/ASInitializerFacet.sol",name:"ASInitializerFacet",title:"A facet that implements all of the diamonds facets initialization. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"initialize(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"token",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"An address for the governing purposes.",token:"A token that should be staked in and act as a reward."},notice:"An initializer function for Locus Token owner and starting state of the inflation."}}},"contracts/diamonds/autoreflectiveStaking/v1/ASReflectionFacet.sol:ASReflectionFacet":{source:"contracts/diamonds/autoreflectiveStaking/v1/ASReflectionFacet.sol",name:"ASReflectionFacet",title:"A facet that implements the autoreflective transfers and mint/burns. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"AddressStatus(address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"who",type:"address"},{indexed:!0,internalType:"bool",name:"isExcluded",type:"bool"}],name:"AddressStatus",type:"event",params:{isExcluded:"True - an address receives. False - it does not.",who:"An address to receive fees or staking rewards."},notice:"Emits when an address `who` is included or excluded from autoreflective fees gathering and staking rewards."},"FeeReflected(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"FeeReflected",type:"event",params:{amount:"An absolute amount of fees."},notice:"Emits when fees that are enabled for each transfer (and the base of the fee would be an amount sent in each) and its greater then zero."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"_burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_burnFrom",outputs:[],stateMutability:"nonpayable",type:"function",params:{tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be burnt.",who:"An address from whom the burn proceeds. "},notice:"An internal diamond-wise that other facets could use to burn st-tokens from."},"_mintTo(address,uint256)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_mintTo",outputs:[],stateMutability:"nonpayable",type:"function",params:{tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be minted.",who:"An address to whom the mint proceeds. "},notice:"An internal diamond-wise that other facets could use to mint st-tokens to."},"_transferBothExcluded(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferBothExcluded",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from excluded to excluded address."},"_transferFromExcluded(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferFromExcluded",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from excluded to non-excluded address."},"_transferStandard(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferStandard",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from non-excluded to non-excluded address."},"_transferToExcluded(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferToExcluded",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from non-excluded to excluded address."},"_updateTotalReflection()":{inputs:[],name:"_updateTotalReflection",outputs:[],stateMutability:"nonpayable",type:"function",notice:"An internal diamond-wise that updates the reflected total supply to distribute new tokens  (a reward thats coming from the responsible entity)."},"excludeAccount(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"excludeAccount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event AddressStatus(...)`.",params:{account:"An address to be excluded."},notice:"Excludes an address from autoreflective fees gathering and staking rewards."},"includeAccount(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"includeAccount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event AddressStatus(...)`.",params:{account:"An address to be included back."},notice:"Includes an address back to autoreflective fees gathering and staking rewards."}}},"contracts/diamonds/autoreflectiveStaking/v1/ASReflectionLoupeFacet.sol:ASReflectionLoupeFacet":{source:"contracts/diamonds/autoreflectiveStaking/v1/ASReflectionLoupeFacet.sol",name:"ASReflectionLoupeFacet",title:"A facet that implements the observation of autoreflective math inside the staking contract.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"_getCurrentSupply()":{inputs:[],name:"_getCurrentSupply",outputs:[{components:[{internalType:"uint256",name:"rSupply",type:"uint256"},{internalType:"uint256",name:"tSupply",type:"uint256"}],internalType:"struct ASLib.Supply",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"An internal diamond-wise view function that returns current state of both real and reflected total supplies but accounting excluded and included addresses."},"_getRValues(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"},{internalType:"uint256",name:"tFee",type:"uint256"},{internalType:"uint256",name:"currentRate",type:"uint256"}],name:"_getRValues",outputs:[{components:[{internalType:"uint256",name:"rAmount",type:"uint256"},{internalType:"uint256",name:"rTransferAmount",type:"uint256"},{internalType:"uint256",name:"rFee",type:"uint256"}],internalType:"struct ASLib.RValues",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{currentRate:"An amount which represents the transformation rate between real and reflected total supply.",tAmount:"An amount of real share tokens to be calculated based on.",tFee:"An amount of fee per transaction (currently 0) in real share tokens."},returns:{_0:"A struct which represents reflected side of the balance."},notice:"An internal diamond-wise view function that calculates reflected side of the balance."},"_getRate()":{inputs:[],name:"_getRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"An internal diamond-wise view function that returns an amount which represents  the transformation rate between real and reflected total supply."},"_getTValues(uint256)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_getTValues",outputs:[{components:[{internalType:"uint256",name:"tTransferAmount",type:"uint256"},{internalType:"uint256",name:"tFee",type:"uint256"}],internalType:"struct ASLib.TValues",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{tAmount:"An amount of real share tokens to be calculated based on."},returns:{_0:"A struct which represents real side of the balance."},notice:"An internal diamond-wise view function that calculates real side of the balance."},"_getValues(uint256)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_getValues",outputs:[{components:[{components:[{internalType:"uint256",name:"rAmount",type:"uint256"},{internalType:"uint256",name:"rTransferAmount",type:"uint256"},{internalType:"uint256",name:"rFee",type:"uint256"}],internalType:"struct ASLib.RValues",name:"r",type:"tuple"},{components:[{internalType:"uint256",name:"tTransferAmount",type:"uint256"},{internalType:"uint256",name:"tFee",type:"uint256"}],internalType:"struct ASLib.TValues",name:"t",type:"tuple"}],internalType:"struct ASLib.Values",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{tAmount:"An amount of real share tokens to be calculated based on."},returns:{_0:"A struct which represents both sides of the balance."},notice:"An internal diamond-wise view function that calculates both sides of the balance: reflected and real."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"tTotal",type:"uint256"},{internalType:"uint256",name:"rTotal",type:"uint256"},{internalType:"uint256",name:"tFeeTotal",type:"uint256"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"uint8",name:"decimals",type:"uint8"},{internalType:"uint256",name:"totalStaked",type:"uint256"}],internalType:"struct ASLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"Returns whole state of the primitive variables in the diamond."},"isExcluded(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"isExcluded",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{account:"An account to be checked."},returns:{_0:"True if an address is excluded. False - if it does not."},notice:"Checks if an account were either inlcuded or excluded from fees and staking rewards distribution."},"reflectionFromToken(uint256,bool)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"},{internalType:"bool",name:"addTransferFee",type:"bool"}],name:"reflectionFromToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{addTransferFee:"An account the fees that could be applied.",tAmount:"A real amount of share tokens."},returns:{_0:"A reflected amount of share tokens."},notice:"Returns a reflected amount against real amount of share tokens."},"tokenFromReflection(uint256)":{inputs:[{internalType:"uint256",name:"rAmount",type:"uint256"}],name:"tokenFromReflection",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rAmount:"A reflected amount of share tokens."},returns:{_0:"A real amount of share tokens."},notice:"Returns a real amount against reflected amount of share tokens."}}},"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASDepositaryFacet.sol:IASDepositaryFacet":{source:"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASDepositaryFacet.sol",name:"IASDepositaryFacet",title:"A facet that implements the depositary logic for users. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"RewardAdded(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"RewardAdded",type:"event",params:{amount:"An amount of reward tokens to be distributed to users."},notice:"Emits when reward tokens are added to the distribution to users."},"Staked(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"Staked",type:"event",params:{amount:"An amount of staking token staked."},notice:"Emits when staking operation has completed successfully."},"Withdrawn(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"Withdrawn",type:"event",params:{amount:"An amount of staking token withdrawn."},notice:"Emits when withdrawal operation has completed successfully."}},methods:{"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event RewardAdded(...)`.",params:{amount:"An amount of reward tokens to be distributed."},notice:"Sends from `msg.sender` reward tokens to be distributed among users."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event Staked(...)`.",params:{amount:"An amount of staking token to be staked."},notice:"Stakes a number of staking tokens."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event Withdrawn(...)`.",params:{amount:"An amount of staking token to be withdrawn.",dueDuration:"Code of time interval after which the tokens would be sent to the `msg.sender`."},notice:"Withdraws a number of staking tokens."}}},"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASEip20Facet.sol:IASEip20Facet":{source:"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASEip20Facet.sol",name:"IASEip20Facet",title:"A facet that implements the EIP20 logic. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"_emitTransferEvent(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"_emitTransferEvent",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be transferred.",from:"An address `from`.",to:"An address `to`."},notice:"An internal diamond-wise that emits standard IERC20 Transfer event.  Utilized to provide an opportunity to trigger the event in the facets where ABI does not contain it."},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the decimals places of the token."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",notice:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",notice:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASFeeAdvisorFacet.sol:IASFeeAdvisorFacet":{source:"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASFeeAdvisorFacet.sol",name:"IASFeeAdvisorFacet",title:"A facet that implements the fee calculation logic. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"advise(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"advise",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{amount:"An amount of tokens of an entity which the advise about fees be based on."},returns:{_0:"Constant 0."},notice:"Returns the amount of fee based on who and what amount be transferred and placed fee upon.  For now returns constantly zero."}}},"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASInitializerFacet.sol:IASInitializerFacet":{source:"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASInitializerFacet.sol",name:"IASInitializerFacet",title:"A facet that implements all of the diamonds facets initialization. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"initialize(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"token",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"An address for the governing purposes.",token:"A token that should be staked in and act as a reward."},notice:"An initializer function for Locus Token owner and starting state of the inflation."}}},"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASReflectionFacet.sol:IASReflectionFacet":{source:"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASReflectionFacet.sol",name:"IASReflectionFacet",title:"A facet that implements the autoreflective transfers and mint/burns. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"AddressStatus(address,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"who",type:"address"},{indexed:!0,internalType:"bool",name:"isExcluded",type:"bool"}],name:"AddressStatus",type:"event",params:{isExcluded:"True - an address receives. False - it does not.",who:"An address to receive fees or staking rewards."},notice:"Emits when an address `who` is included or excluded from autoreflective fees gathering and staking rewards."},"FeeReflected(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"FeeReflected",type:"event",params:{amount:"An absolute amount of fees."},notice:"Emits when fees that are enabled for each transfer (and the base of the fee would be an amount sent in each) and its greater then zero."}},methods:{"_burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_burnFrom",outputs:[],stateMutability:"nonpayable",type:"function",params:{tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be burnt.",who:"An address from whom the burn proceeds. "},notice:"An internal diamond-wise that other facets could use to burn st-tokens from."},"_mintTo(address,uint256)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_mintTo",outputs:[],stateMutability:"nonpayable",type:"function",params:{tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be minted.",who:"An address to whom the mint proceeds. "},notice:"An internal diamond-wise that other facets could use to mint st-tokens to."},"_transferBothExcluded(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferBothExcluded",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from excluded to excluded address."},"_transferFromExcluded(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferFromExcluded",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from excluded to non-excluded address."},"_transferStandard(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferStandard",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from non-excluded to non-excluded address."},"_transferToExcluded(address,address,uint256)":{inputs:[{internalType:"address",name:"sender",type:"address"},{internalType:"address",name:"recipient",type:"address"},{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_transferToExcluded",outputs:[],stateMutability:"nonpayable",type:"function",params:{recipient:"An address transfer is coming to.",sender:"An address transfer is coming from.",tAmount:"An amount of actual (non-autoreflective part of the balance) tokens to be transferred."},notice:"An internal diamond-wise that other facet that responsible for EIP20 logic would call to perform a transfer from non-excluded to excluded address."},"_updateTotalReflection()":{inputs:[],name:"_updateTotalReflection",outputs:[],stateMutability:"nonpayable",type:"function",notice:"An internal diamond-wise that updates the reflected total supply to distribute new tokens  (a reward thats coming from the responsible entity)."},"excludeAccount(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"excludeAccount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event AddressStatus(...)`.",params:{account:"An address to be excluded."},notice:"Excludes an address from autoreflective fees gathering and staking rewards."},"includeAccount(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"includeAccount",outputs:[],stateMutability:"nonpayable",type:"function",details:"Triggers `event AddressStatus(...)`.",params:{account:"An address to be included back."},notice:"Includes an address back to autoreflective fees gathering and staking rewards."}}},"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASReflectionLoupeFacet.sol:IASReflectionLoupeFacet":{source:"contracts/diamonds/autoreflectiveStaking/v1/interfaces/IASReflectionLoupeFacet.sol",name:"IASReflectionLoupeFacet",title:"A facet that implements the observation of autoreflective math inside the staking contract.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"_getCurrentSupply()":{inputs:[],name:"_getCurrentSupply",outputs:[{components:[{internalType:"uint256",name:"rSupply",type:"uint256"},{internalType:"uint256",name:"tSupply",type:"uint256"}],internalType:"struct ASLib.Supply",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"An internal diamond-wise view function that returns current state of both real and reflected total supplies but accounting excluded and included addresses."},"_getRValues(uint256,uint256,uint256)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"},{internalType:"uint256",name:"tFee",type:"uint256"},{internalType:"uint256",name:"currentRate",type:"uint256"}],name:"_getRValues",outputs:[{components:[{internalType:"uint256",name:"rAmount",type:"uint256"},{internalType:"uint256",name:"rTransferAmount",type:"uint256"},{internalType:"uint256",name:"rFee",type:"uint256"}],internalType:"struct ASLib.RValues",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{currentRate:"An amount which represents the transformation rate between real and reflected total supply.",tAmount:"An amount of real share tokens to be calculated based on.",tFee:"An amount of fee per transaction (currently 0) in real share tokens."},returns:{_0:"A struct which represents reflected side of the balance."},notice:"An internal diamond-wise view function that calculates reflected side of the balance."},"_getRate()":{inputs:[],name:"_getRate",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"An internal diamond-wise view function that returns an amount which represents  the transformation rate between real and reflected total supply."},"_getTValues(uint256)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_getTValues",outputs:[{components:[{internalType:"uint256",name:"tTransferAmount",type:"uint256"},{internalType:"uint256",name:"tFee",type:"uint256"}],internalType:"struct ASLib.TValues",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{tAmount:"An amount of real share tokens to be calculated based on."},returns:{_0:"A struct which represents real side of the balance."},notice:"An internal diamond-wise view function that calculates real side of the balance."},"_getValues(uint256)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"}],name:"_getValues",outputs:[{components:[{components:[{internalType:"uint256",name:"rAmount",type:"uint256"},{internalType:"uint256",name:"rTransferAmount",type:"uint256"},{internalType:"uint256",name:"rFee",type:"uint256"}],internalType:"struct ASLib.RValues",name:"r",type:"tuple"},{components:[{internalType:"uint256",name:"tTransferAmount",type:"uint256"},{internalType:"uint256",name:"tFee",type:"uint256"}],internalType:"struct ASLib.TValues",name:"t",type:"tuple"}],internalType:"struct ASLib.Values",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{tAmount:"An amount of real share tokens to be calculated based on."},returns:{_0:"A struct which represents both sides of the balance."},notice:"An internal diamond-wise view function that calculates both sides of the balance: reflected and real."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"address",name:"token",type:"address"},{internalType:"uint256",name:"tTotal",type:"uint256"},{internalType:"uint256",name:"rTotal",type:"uint256"},{internalType:"uint256",name:"tFeeTotal",type:"uint256"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"symbol",type:"string"},{internalType:"uint8",name:"decimals",type:"uint8"},{internalType:"uint256",name:"totalStaked",type:"uint256"}],internalType:"struct ASLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",notice:"Returns whole state of the primitive variables in the diamond."},"isExcluded(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"isExcluded",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{account:"An account to be checked."},returns:{_0:"True if an address is excluded. False - if it does not."},notice:"Checks if an account were either inlcuded or excluded from fees and staking rewards distribution."},"reflectionFromToken(uint256,bool)":{inputs:[{internalType:"uint256",name:"tAmount",type:"uint256"},{internalType:"bool",name:"addTransferFee",type:"bool"}],name:"reflectionFromToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{addTransferFee:"An account the fees that could be applied.",tAmount:"A real amount of share tokens."},returns:{_0:"A reflected amount of share tokens."},notice:"Returns a reflected amount against real amount of share tokens."},"tokenFromReflection(uint256)":{inputs:[{internalType:"uint256",name:"rAmount",type:"uint256"}],name:"tokenFromReflection",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rAmount:"A reflected amount of share tokens."},returns:{_0:"A real amount of share tokens."},notice:"Returns a real amount against reflected amount of share tokens."}}},"contracts/diamonds/facetsFramework/diamondBase/facets/BaseFacet.sol:BaseFacet":{source:"contracts/diamonds/facetsFramework/diamondBase/facets/BaseFacet.sol",name:"BaseFacet",title:"A base facet that establishes some important modifiers and functions to must have for each facet. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}}},"contracts/diamonds/facetsFramework/diamondBase/facets/PausabilityFacet.sol:PausabilityFacet":{source:"contracts/diamonds/facetsFramework/diamondBase/facets/PausabilityFacet.sol",name:"PausabilityFacet",title:"A base facet that establishes the pausability functionality. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Returns if the diamond has been paused or not."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Unpauses the diamond."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Pauses the diamond."}}},"contracts/diamonds/facetsFramework/diamondBase/facets/RolesManagementFacet.sol:RolesManagementFacet":{source:"contracts/diamonds/facetsFramework/diamondBase/facets/RolesManagementFacet.sol",name:"RolesManagementFacet",title:"A base facet that establishes the basic roles functionality.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."}}},"contracts/diamonds/facetsFramework/diamondBase/interfaces/IPausable.sol:IPausable":{source:"contracts/diamonds/facetsFramework/diamondBase/interfaces/IPausable.sol",name:"IPausable",title:"A base facet that establishes the pausability functionality. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Returns if the diamond has been paused or not."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Unpauses the diamond."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Pauses the diamond."}}},"contracts/diamonds/facetsFramework/diamondBase/interfaces/IRolesManagement.sol:IRolesManagement":{source:"contracts/diamonds/facetsFramework/diamondBase/interfaces/IRolesManagement.sol",name:"IRolesManagement",title:"A base facet that establishes the basic roles functionality.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."}}},"contracts/diamonds/facetsFramework/diamondBase/libraries/InitializerLib.sol:InitializerLib":{source:"contracts/diamonds/facetsFramework/diamondBase/libraries/InitializerLib.sol",name:"InitializerLib"},"contracts/diamonds/facetsFramework/diamondBase/libraries/PausabilityLib.sol:PausabilityLib":{source:"contracts/diamonds/facetsFramework/diamondBase/libraries/PausabilityLib.sol",name:"PausabilityLib"},"contracts/diamonds/facetsFramework/diamondBase/libraries/RolesManagementLib.sol:RolesManagementLib":{source:"contracts/diamonds/facetsFramework/diamondBase/libraries/RolesManagementLib.sol",name:"RolesManagementLib",events:{"RoleSet(address,bytes32,bool)":{anonymous:!1,inputs:[{indexed:!1,internalType:"address",name:"who",type:"address"},{indexed:!1,internalType:"bytes32",name:"role",type:"bytes32"},{indexed:!1,internalType:"bool",name:"isGrantedOrRevoked",type:"bool"}],name:"RoleSet",type:"event",params:{isGrantedOrRevoked:"True - role is granted. False - role is revoked. ",role:"A role.",who:"An entity."},notice:"Emits when a relation between enitity and role change."}},stateVariables:{"ALLOWED_TOKEN_ROLE()":{inputs:[],name:"ALLOWED_TOKEN_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:"Roles to check with smart-contracts"},"INTERNAL_ROLE()":{inputs:[],name:"INTERNAL_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:"A special role - must not be removed."},"PAUSER_ROLE()":{inputs:[],name:"PAUSER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:"Roles to check with EOA"}},methods:{"OWNER_ROLE()":{inputs:[],name:"OWNER_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"}}},"contracts/diamonds/facetsFramework/tokensDistributor/TDLib.sol:TDLib":{source:"contracts/diamonds/facetsFramework/tokensDistributor/TDLib.sol",name:"TDLib",events:{"Distributed(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"distributedValue",type:"uint256"},{indexed:!0,internalType:"uint256",name:"tokensLeftAndSentToGovernance",type:"uint256"}],name:"Distributed",type:"event",params:{distributedValue:"An amount of tokens distributed.",tokensLeftAndSentToGovernance:"A dust that could be left after all divisions. It is sent to the governance or distribution call sender."},notice:"Emits when tokens distribution is triggered."},"ReceiverAltered(address,uint256,bool,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"receiver",type:"address"},{indexed:!0,internalType:"uint256",name:"share",type:"uint256"},{indexed:!0,internalType:"bool",name:"isBlocked",type:"bool"},{indexed:!1,internalType:"uint256",name:"sumOfShares",type:"uint256"}],name:"ReceiverAltered",type:"event",params:{isBlocked:"The receivers status.",receiver:"A tokens receiver.",share:"The receivers share.",sumOfShares:"Total sum of all shares."},notice:"Emits when tokens receiver info is altered."}},methods:{"MAX_BPS()":{inputs:[],name:"MAX_BPS",outputs:[{internalType:"uint16",name:"",type:"uint16"}],stateMutability:"view",type:"function"}}},"contracts/diamonds/facetsFramework/tokensDistributor/v1/TDLoupeFacet.sol:TDLoupeFacet":{source:"contracts/diamonds/facetsFramework/tokensDistributor/v1/TDLoupeFacet.sol",name:"TDLoupeFacet",title:"A facet which is a part of `tokenDistributor` group of facets. It allows to loupe through the data of  receivers of tokens and their shares. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."}}},"contracts/diamonds/facetsFramework/tokensDistributor/v1/TDManagementFacet.sol:TDManagementFacet":{source:"contracts/diamonds/facetsFramework/tokensDistributor/v1/TDManagementFacet.sol",name:"TDManagementFacet",title:"A facet which is a part of `tokenDistributor` group of facets. It allows to add new receivers of tokens and manipulate their status (whether they're blocked which means they're excluded from the distribution) and their shares in a distribution.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"distributionReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"distributionReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"distributionReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."}}},"contracts/diamonds/facetsFramework/tokensDistributor/v1/TDProcessFacet.sol:TDProcessFacet":{source:"contracts/diamonds/facetsFramework/tokensDistributor/v1/TDProcessFacet.sol",name:"TDProcessFacet",title:"A facet which is a part of `tokenDistributor` group of facets. It allows to perform distribution of any token that is holding in the diamond according to tokens receivers their shares.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."}}},"contracts/diamonds/facetsFramework/tokensDistributor/v1/interfaces/ITDLoupeFacet.sol:ITDLoupeFacet":{source:"contracts/diamonds/facetsFramework/tokensDistributor/v1/interfaces/ITDLoupeFacet.sol",name:"ITDLoupeFacet",title:"A facet which is a part of `tokenDistributor` group of facets. It allows to loupe through the data of  receivers of tokens and their shares. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."}}},"contracts/diamonds/facetsFramework/tokensDistributor/v1/interfaces/ITDManagementFacet.sol:ITDManagementFacet":{source:"contracts/diamonds/facetsFramework/tokensDistributor/v1/interfaces/ITDManagementFacet.sol",name:"ITDManagementFacet",title:"A facet which is a part of `tokenDistributor` group of facets. It allows to add new receivers of tokens and manipulate their status (whether they're blocked which means they're excluded from the distribution) and their shares in a distribution.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."}}},"contracts/diamonds/facetsFramework/tokensDistributor/v1/interfaces/ITDProcessFacet.sol:ITDProcessFacet":{source:"contracts/diamonds/facetsFramework/tokensDistributor/v1/interfaces/ITDProcessFacet.sol",name:"ITDProcessFacet",title:"A facet which is a part of `tokenDistributor` group of facets. It allows to perform distribution of any token that is holding in the diamond according to tokens receivers their shares.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."}}},"contracts/diamonds/locusStaking/DiamondLocusMockTokensStaking.sol:DiamondLocusMockTokensStaking":{source:"contracts/diamonds/locusStaking/DiamondLocusMockTokensStaking.sol",name:"DiamondLocusMockTokensStaking",details:"This MUST aggregate all of the faucets interfaces, to be able to grasp a full view of ABI in one place.",notice:'IMPORTANT: all of the collective diamond interfaces MUST be prefixed with "Diamond" word.',methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"addDelayedSending(address,address,uint256,uint8)":{inputs:[{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"},{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"}],name:"addDelayedSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be sent.",dueToDuration:"A duration code.",receiver:"A receiver of the sending.",sendingToken:"Token to be sent."},notice:"Creates a delayed sending of any token to any receiver. Could only be called by the diamond itself."},"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An entity to check."},returns:{_0:"An amount of tokens staked."},notice:"Returns a staked deposit of some entity."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"Decimals."},notice:"Returns EIP20-like precision."},"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."},"earned(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"earned",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An account to check."},returns:{_0:"Amount of tokens earned by the account."},notice:"Returns an amount of rewards tokens earned by an `account`."},"getAPR()":{inputs:[],name:"getAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"APR"},notice:"Returns an APR with constraint (reward rate is unchanging throughout the staking cycle). The precision of the APR equals to `10**<decimals of staking token>`."},"getAPRInAbsoluteValue()":{inputs:[],name:"getAPRInAbsoluteValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns an amount of tokens earned per 1 staking token throughout 1 staking cycle with actual but constant reward rate."},"getDelayedSending(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getDelayedSending",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{index:"Required index of the sending in the queue"},returns:{_0:"Found sending struct. "},notice:"Returns a sending struct with full info in the queue."},"getDequeSize()":{inputs:[],name:"getDequeSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"The size."},notice:"Returns size of the sendings queue."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"contract IERC20Metadata",name:"rewardsToken",type:"address"},{internalType:"contract IERC20Metadata",name:"stakingToken",type:"address"},{internalType:"uint256",name:"periodFinish",type:"uint256"},{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardsDuration",type:"uint256"},{internalType:"uint256",name:"lastUpdateTime",type:"uint256"},{internalType:"uint256",name:"rewardPerTokenStored",type:"uint256"},{internalType:"uint256",name:"totalSupply",type:"uint256"},{internalType:"uint256",name:"totalReward",type:"uint256"},{internalType:"address",name:"wrappedStLocusToken",type:"address"},{internalType:"bool",name:"areDepositsShut",type:"bool"}],internalType:"struct LSLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",returns:{_0:"`Primitives` struct."},notice:"Gives all primitive internal variables of the diamond."},"getProjectedAPR(uint256,uint256)":{inputs:[{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardDuration",type:"uint256"}],name:"getProjectedAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rewardDuration:"A staking cycle.",rewardRate:"A rate with which the rewards are accumulated."},returns:{_0:"Projected APR."},notice:"Returns an APR with the same constraint as is `getAPR`, but reward rate and staking cycle are variables."},"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"getRewardForDuration()":{inputs:[],name:"getRewardForDuration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned throughout of staking cycle."},"getSendingsDeque()":{inputs:[],name:"getSendingsDeque",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"A deque of sendings. (Or queue of sendings.)"},notice:"Returns full array of sendings queue."},"getSendingsDequeIndiciesStored()":{inputs:[],name:"getSendingsDequeIndiciesStored",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",notice:"Returns an array of IDs of the sendings, that are stored in public mapping.Array on indicies stored in the queue."},"getTotalReward()":{inputs:[],name:"getTotalReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned since the diamond deployment."},"getTotalSendingsPerStaker(address)":{inputs:[{internalType:"address",name:"staker",type:"address"}],name:"getTotalSendingsPerStaker",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{staker:"A staker address to be search info for."},returns:{_0:"A sum of tokens that are going to eventuely go to the `staker`."},notice:"Returns sum of all sendings to be delivered to certain `staker`."},"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"initialize(address,address,address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"rewardDistributor",type:"address"},{internalType:"address",name:"rewardsToken",type:"address"},{internalType:"address",name:"stakingToken",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"Owner of the diamond operations.",rewardDistributor:"An entity who would be able to provide rewards.",rewardsToken:"Token address to act as a reward token.",stakingToken:"Token address to act as a staking token."},notice:"An initalizer function for the diamond."},"lastTimeRewardApplicable()":{inputs:[],name:"lastTimeRewardApplicable",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"A timestamp."},notice:"Returns timestamp when last time the reward was provided to distribute to users."},"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"reward",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{reward:"An amount of tokens to be distributed among the users group."},notice:"Transfers from `msg.sender` (if they're a bearer of `REWARD_DISTRIBUTOR_ROLE`) a reward for the diamond users and starts a distribution resetting the staking cycle."},"prepareDepositary()":{inputs:[],name:"prepareDepositary",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Initializes OZ dependencies of the depositary facet. Can only be called by `OWNER_ROLE` bearer."},"processQueue()":{inputs:[],name:"processQueue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Cleares the queue. Iterates over every element in the queue, and if the sendings due is now, executes the sending.  If not, sets it back."},"processRewardSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"reward",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processRewardSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"Duration code if the rewards are sent with delay.",reward:"An amount of rewards to be sent.",staker:"A staker to which the rewards should be sent."},notice:"Either creates delayed sending of rewards or just sends the rewards immediately,  depends on what token is staking: Governance token - sends without delay, other - sends with delay."},"processWithdrawalSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processWithdrawalSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of withdrawal to be sent.",dueDuration:"Duration code if the withdrawal is sent with delay. ",staker:"A staker to which the withdrawal should be sent."},notice:"Either creates delayed sending of withdrawal or just withdraws the deposit immediately, depends on what token is staking: Governance token - sends with delay, other - sends without delay."},"recoverTokens(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenAmount",type:"uint256"}],name:"recoverTokens",outputs:[],stateMutability:"nonpayable",type:"function",params:{tokenAddress:"An address of stucked token.",tokenAmount:"An amount of stucked tokens."},notice:"Allows bearer of `OWNER_ROLE` to recover stucked tokens."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."},"rewardPerToken()":{inputs:[],name:"rewardPerToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns amount of rewards tokens worth of 1 staking token."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."},"setRewardsDuration(uint256)":{inputs:[{internalType:"uint256",name:"_rewardsDuration",type:"uint256"}],name:"setRewardsDuration",outputs:[],stateMutability:"nonpayable",type:"function",params:{_rewardsDuration:"A duration of staking cycle in seconds."},notice:"Sets a duration for staking cycle. Callable only by `OWNER_ROLE`."},"setWrappedStakingLocus(address)":{inputs:[{internalType:"address",name:"wrappedStLocusToken",type:"address"}],name:"setWrappedStakingLocus",outputs:[],stateMutability:"nonpayable",type:"function",details:"NOT UTILIZED ANYWHERE CURRENTLY. Could only be set by `OWNER_ROLE` bearer.",params:{wrappedStLocusToken:"Address of the EIP20 wrapper."},notice:"Setter for token representation of staking deposit."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns currently total staked tokens amount."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/DiamondLocusPendleEthTokensStaking.sol:DiamondLocusPendleEthTokensStaking":{source:"contracts/diamonds/locusStaking/DiamondLocusPendleEthTokensStaking.sol",name:"DiamondLocusPendleEthTokensStaking",details:"This MUST aggregate all of the faucets interfaces, to be able to grasp a full view of ABI in one place.",notice:'IMPORTANT: all of the collective diamond interfaces MUST be prefixed with "Diamond" word.',methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"addDelayedSending(address,address,uint256,uint8)":{inputs:[{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"},{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"}],name:"addDelayedSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be sent.",dueToDuration:"A duration code.",receiver:"A receiver of the sending.",sendingToken:"Token to be sent."},notice:"Creates a delayed sending of any token to any receiver. Could only be called by the diamond itself."},"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An entity to check."},returns:{_0:"An amount of tokens staked."},notice:"Returns a staked deposit of some entity."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"Decimals."},notice:"Returns EIP20-like precision."},"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."},"earned(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"earned",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An account to check."},returns:{_0:"Amount of tokens earned by the account."},notice:"Returns an amount of rewards tokens earned by an `account`."},"getAPR()":{inputs:[],name:"getAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"APR"},notice:"Returns an APR with constraint (reward rate is unchanging throughout the staking cycle). The precision of the APR equals to `10**<decimals of staking token>`."},"getAPRInAbsoluteValue()":{inputs:[],name:"getAPRInAbsoluteValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns an amount of tokens earned per 1 staking token throughout 1 staking cycle with actual but constant reward rate."},"getDelayedSending(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getDelayedSending",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{index:"Required index of the sending in the queue"},returns:{_0:"Found sending struct. "},notice:"Returns a sending struct with full info in the queue."},"getDequeSize()":{inputs:[],name:"getDequeSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"The size."},notice:"Returns size of the sendings queue."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"contract IERC20Metadata",name:"rewardsToken",type:"address"},{internalType:"contract IERC20Metadata",name:"stakingToken",type:"address"},{internalType:"uint256",name:"periodFinish",type:"uint256"},{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardsDuration",type:"uint256"},{internalType:"uint256",name:"lastUpdateTime",type:"uint256"},{internalType:"uint256",name:"rewardPerTokenStored",type:"uint256"},{internalType:"uint256",name:"totalSupply",type:"uint256"},{internalType:"uint256",name:"totalReward",type:"uint256"},{internalType:"address",name:"wrappedStLocusToken",type:"address"},{internalType:"bool",name:"areDepositsShut",type:"bool"}],internalType:"struct LSLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",returns:{_0:"`Primitives` struct."},notice:"Gives all primitive internal variables of the diamond."},"getProjectedAPR(uint256,uint256)":{inputs:[{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardDuration",type:"uint256"}],name:"getProjectedAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rewardDuration:"A staking cycle.",rewardRate:"A rate with which the rewards are accumulated."},returns:{_0:"Projected APR."},notice:"Returns an APR with the same constraint as is `getAPR`, but reward rate and staking cycle are variables."},"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"getRewardForDuration()":{inputs:[],name:"getRewardForDuration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned throughout of staking cycle."},"getSendingsDeque()":{inputs:[],name:"getSendingsDeque",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"A deque of sendings. (Or queue of sendings.)"},notice:"Returns full array of sendings queue."},"getSendingsDequeIndiciesStored()":{inputs:[],name:"getSendingsDequeIndiciesStored",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",notice:"Returns an array of IDs of the sendings, that are stored in public mapping.Array on indicies stored in the queue."},"getTotalReward()":{inputs:[],name:"getTotalReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned since the diamond deployment."},"getTotalSendingsPerStaker(address)":{inputs:[{internalType:"address",name:"staker",type:"address"}],name:"getTotalSendingsPerStaker",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{staker:"A staker address to be search info for."},returns:{_0:"A sum of tokens that are going to eventuely go to the `staker`."},notice:"Returns sum of all sendings to be delivered to certain `staker`."},"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"initialize(address,address,address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"rewardDistributor",type:"address"},{internalType:"address",name:"rewardsToken",type:"address"},{internalType:"address",name:"stakingToken",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"Owner of the diamond operations.",rewardDistributor:"An entity who would be able to provide rewards.",rewardsToken:"Token address to act as a reward token.",stakingToken:"Token address to act as a staking token."},notice:"An initalizer function for the diamond."},"lastTimeRewardApplicable()":{inputs:[],name:"lastTimeRewardApplicable",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"A timestamp."},notice:"Returns timestamp when last time the reward was provided to distribute to users."},"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"reward",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{reward:"An amount of tokens to be distributed among the users group."},notice:"Transfers from `msg.sender` (if they're a bearer of `REWARD_DISTRIBUTOR_ROLE`) a reward for the diamond users and starts a distribution resetting the staking cycle."},"prepareDepositary()":{inputs:[],name:"prepareDepositary",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Initializes OZ dependencies of the depositary facet. Can only be called by `OWNER_ROLE` bearer."},"processQueue()":{inputs:[],name:"processQueue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Cleares the queue. Iterates over every element in the queue, and if the sendings due is now, executes the sending.  If not, sets it back."},"processRewardSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"reward",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processRewardSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"Duration code if the rewards are sent with delay.",reward:"An amount of rewards to be sent.",staker:"A staker to which the rewards should be sent."},notice:"Either creates delayed sending of rewards or just sends the rewards immediately,  depends on what token is staking: Governance token - sends without delay, other - sends with delay."},"processWithdrawalSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processWithdrawalSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of withdrawal to be sent.",dueDuration:"Duration code if the withdrawal is sent with delay. ",staker:"A staker to which the withdrawal should be sent."},notice:"Either creates delayed sending of withdrawal or just withdraws the deposit immediately, depends on what token is staking: Governance token - sends with delay, other - sends without delay."},"recoverTokens(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenAmount",type:"uint256"}],name:"recoverTokens",outputs:[],stateMutability:"nonpayable",type:"function",params:{tokenAddress:"An address of stucked token.",tokenAmount:"An amount of stucked tokens."},notice:"Allows bearer of `OWNER_ROLE` to recover stucked tokens."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."},"rewardPerToken()":{inputs:[],name:"rewardPerToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns amount of rewards tokens worth of 1 staking token."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."},"setRewardsDuration(uint256)":{inputs:[{internalType:"uint256",name:"_rewardsDuration",type:"uint256"}],name:"setRewardsDuration",outputs:[],stateMutability:"nonpayable",type:"function",params:{_rewardsDuration:"A duration of staking cycle in seconds."},notice:"Sets a duration for staking cycle. Callable only by `OWNER_ROLE`."},"setWrappedStakingLocus(address)":{inputs:[{internalType:"address",name:"wrappedStLocusToken",type:"address"}],name:"setWrappedStakingLocus",outputs:[],stateMutability:"nonpayable",type:"function",details:"NOT UTILIZED ANYWHERE CURRENTLY. Could only be set by `OWNER_ROLE` bearer.",params:{wrappedStLocusToken:"Address of the EIP20 wrapper."},notice:"Setter for token representation of staking deposit."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns currently total staked tokens amount."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/DiamondLocusStaking.sol:DiamondLocusStaking":{source:"contracts/diamonds/locusStaking/DiamondLocusStaking.sol",name:"DiamondLocusStaking",details:"This MUST aggregate all of the faucets interfaces, to be able to grasp a full view of ABI in one place.",notice:'IMPORTANT: all of the collective diamond interfaces MUST be prefixed with "Diamond" word.',methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"addDelayedSending(address,address,uint256,uint8)":{inputs:[{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"},{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"}],name:"addDelayedSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be sent.",dueToDuration:"A duration code.",receiver:"A receiver of the sending.",sendingToken:"Token to be sent."},notice:"Creates a delayed sending of any token to any receiver. Could only be called by the diamond itself."},"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An entity to check."},returns:{_0:"An amount of tokens staked."},notice:"Returns a staked deposit of some entity."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"Decimals."},notice:"Returns EIP20-like precision."},"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."},"earned(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"earned",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An account to check."},returns:{_0:"Amount of tokens earned by the account."},notice:"Returns an amount of rewards tokens earned by an `account`."},"getAPR()":{inputs:[],name:"getAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"APR"},notice:"Returns an APR with constraint (reward rate is unchanging throughout the staking cycle). The precision of the APR equals to `10**<decimals of staking token>`."},"getAPRInAbsoluteValue()":{inputs:[],name:"getAPRInAbsoluteValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns an amount of tokens earned per 1 staking token throughout 1 staking cycle with actual but constant reward rate."},"getDelayedSending(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getDelayedSending",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{index:"Required index of the sending in the queue"},returns:{_0:"Found sending struct. "},notice:"Returns a sending struct with full info in the queue."},"getDequeSize()":{inputs:[],name:"getDequeSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"The size."},notice:"Returns size of the sendings queue."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"contract IERC20Metadata",name:"rewardsToken",type:"address"},{internalType:"contract IERC20Metadata",name:"stakingToken",type:"address"},{internalType:"uint256",name:"periodFinish",type:"uint256"},{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardsDuration",type:"uint256"},{internalType:"uint256",name:"lastUpdateTime",type:"uint256"},{internalType:"uint256",name:"rewardPerTokenStored",type:"uint256"},{internalType:"uint256",name:"totalSupply",type:"uint256"},{internalType:"uint256",name:"totalReward",type:"uint256"},{internalType:"address",name:"wrappedStLocusToken",type:"address"},{internalType:"bool",name:"areDepositsShut",type:"bool"}],internalType:"struct LSLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",returns:{_0:"`Primitives` struct."},notice:"Gives all primitive internal variables of the diamond."},"getProjectedAPR(uint256,uint256)":{inputs:[{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardDuration",type:"uint256"}],name:"getProjectedAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rewardDuration:"A staking cycle.",rewardRate:"A rate with which the rewards are accumulated."},returns:{_0:"Projected APR."},notice:"Returns an APR with the same constraint as is `getAPR`, but reward rate and staking cycle are variables."},"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"getRewardForDuration()":{inputs:[],name:"getRewardForDuration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned throughout of staking cycle."},"getSendingsDeque()":{inputs:[],name:"getSendingsDeque",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"A deque of sendings. (Or queue of sendings.)"},notice:"Returns full array of sendings queue."},"getSendingsDequeIndiciesStored()":{inputs:[],name:"getSendingsDequeIndiciesStored",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",notice:"Returns an array of IDs of the sendings, that are stored in public mapping.Array on indicies stored in the queue."},"getTotalReward()":{inputs:[],name:"getTotalReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned since the diamond deployment."},"getTotalSendingsPerStaker(address)":{inputs:[{internalType:"address",name:"staker",type:"address"}],name:"getTotalSendingsPerStaker",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{staker:"A staker address to be search info for."},returns:{_0:"A sum of tokens that are going to eventuely go to the `staker`."},notice:"Returns sum of all sendings to be delivered to certain `staker`."},"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"initialize(address,address,address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"rewardDistributor",type:"address"},{internalType:"address",name:"rewardsToken",type:"address"},{internalType:"address",name:"stakingToken",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"Owner of the diamond operations.",rewardDistributor:"An entity who would be able to provide rewards.",rewardsToken:"Token address to act as a reward token.",stakingToken:"Token address to act as a staking token."},notice:"An initalizer function for the diamond."},"lastTimeRewardApplicable()":{inputs:[],name:"lastTimeRewardApplicable",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"A timestamp."},notice:"Returns timestamp when last time the reward was provided to distribute to users."},"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"reward",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{reward:"An amount of tokens to be distributed among the users group."},notice:"Transfers from `msg.sender` (if they're a bearer of `REWARD_DISTRIBUTOR_ROLE`) a reward for the diamond users and starts a distribution resetting the staking cycle."},"prepareDepositary()":{inputs:[],name:"prepareDepositary",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Initializes OZ dependencies of the depositary facet. Can only be called by `OWNER_ROLE` bearer."},"processQueue()":{inputs:[],name:"processQueue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Cleares the queue. Iterates over every element in the queue, and if the sendings due is now, executes the sending.  If not, sets it back."},"processRewardSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"reward",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processRewardSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"Duration code if the rewards are sent with delay.",reward:"An amount of rewards to be sent.",staker:"A staker to which the rewards should be sent."},notice:"Either creates delayed sending of rewards or just sends the rewards immediately,  depends on what token is staking: Governance token - sends without delay, other - sends with delay."},"processWithdrawalSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processWithdrawalSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of withdrawal to be sent.",dueDuration:"Duration code if the withdrawal is sent with delay. ",staker:"A staker to which the withdrawal should be sent."},notice:"Either creates delayed sending of withdrawal or just withdraws the deposit immediately, depends on what token is staking: Governance token - sends with delay, other - sends without delay."},"recoverTokens(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenAmount",type:"uint256"}],name:"recoverTokens",outputs:[],stateMutability:"nonpayable",type:"function",params:{tokenAddress:"An address of stucked token.",tokenAmount:"An amount of stucked tokens."},notice:"Allows bearer of `OWNER_ROLE` to recover stucked tokens."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."},"rewardPerToken()":{inputs:[],name:"rewardPerToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns amount of rewards tokens worth of 1 staking token."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."},"setRewardsDuration(uint256)":{inputs:[{internalType:"uint256",name:"_rewardsDuration",type:"uint256"}],name:"setRewardsDuration",outputs:[],stateMutability:"nonpayable",type:"function",params:{_rewardsDuration:"A duration of staking cycle in seconds."},notice:"Sets a duration for staking cycle. Callable only by `OWNER_ROLE`."},"setWrappedStakingLocus(address)":{inputs:[{internalType:"address",name:"wrappedStLocusToken",type:"address"}],name:"setWrappedStakingLocus",outputs:[],stateMutability:"nonpayable",type:"function",details:"NOT UTILIZED ANYWHERE CURRENTLY. Could only be set by `OWNER_ROLE` bearer.",params:{wrappedStLocusToken:"Address of the EIP20 wrapper."},notice:"Setter for token representation of staking deposit."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns currently total staked tokens amount."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/DiamondLocusXArbTokensStaking.sol:DiamondLocusXArbTokensStaking":{source:"contracts/diamonds/locusStaking/DiamondLocusXArbTokensStaking.sol",name:"DiamondLocusXArbTokensStaking",details:"This MUST aggregate all of the faucets interfaces, to be able to grasp a full view of ABI in one place.",notice:'IMPORTANT: all of the collective diamond interfaces MUST be prefixed with "Diamond" word.',methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"addDelayedSending(address,address,uint256,uint8)":{inputs:[{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"},{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"}],name:"addDelayedSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be sent.",dueToDuration:"A duration code.",receiver:"A receiver of the sending.",sendingToken:"Token to be sent."},notice:"Creates a delayed sending of any token to any receiver. Could only be called by the diamond itself."},"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An entity to check."},returns:{_0:"An amount of tokens staked."},notice:"Returns a staked deposit of some entity."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"Decimals."},notice:"Returns EIP20-like precision."},"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."},"earned(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"earned",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An account to check."},returns:{_0:"Amount of tokens earned by the account."},notice:"Returns an amount of rewards tokens earned by an `account`."},"getAPR()":{inputs:[],name:"getAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"APR"},notice:"Returns an APR with constraint (reward rate is unchanging throughout the staking cycle). The precision of the APR equals to `10**<decimals of staking token>`."},"getAPRInAbsoluteValue()":{inputs:[],name:"getAPRInAbsoluteValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns an amount of tokens earned per 1 staking token throughout 1 staking cycle with actual but constant reward rate."},"getDelayedSending(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getDelayedSending",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{index:"Required index of the sending in the queue"},returns:{_0:"Found sending struct. "},notice:"Returns a sending struct with full info in the queue."},"getDequeSize()":{inputs:[],name:"getDequeSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"The size."},notice:"Returns size of the sendings queue."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"contract IERC20Metadata",name:"rewardsToken",type:"address"},{internalType:"contract IERC20Metadata",name:"stakingToken",type:"address"},{internalType:"uint256",name:"periodFinish",type:"uint256"},{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardsDuration",type:"uint256"},{internalType:"uint256",name:"lastUpdateTime",type:"uint256"},{internalType:"uint256",name:"rewardPerTokenStored",type:"uint256"},{internalType:"uint256",name:"totalSupply",type:"uint256"},{internalType:"uint256",name:"totalReward",type:"uint256"},{internalType:"address",name:"wrappedStLocusToken",type:"address"},{internalType:"bool",name:"areDepositsShut",type:"bool"}],internalType:"struct LSLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",returns:{_0:"`Primitives` struct."},notice:"Gives all primitive internal variables of the diamond."},"getProjectedAPR(uint256,uint256)":{inputs:[{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardDuration",type:"uint256"}],name:"getProjectedAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rewardDuration:"A staking cycle.",rewardRate:"A rate with which the rewards are accumulated."},returns:{_0:"Projected APR."},notice:"Returns an APR with the same constraint as is `getAPR`, but reward rate and staking cycle are variables."},"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"getRewardForDuration()":{inputs:[],name:"getRewardForDuration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned throughout of staking cycle."},"getSendingsDeque()":{inputs:[],name:"getSendingsDeque",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"A deque of sendings. (Or queue of sendings.)"},notice:"Returns full array of sendings queue."},"getSendingsDequeIndiciesStored()":{inputs:[],name:"getSendingsDequeIndiciesStored",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",notice:"Returns an array of IDs of the sendings, that are stored in public mapping.Array on indicies stored in the queue."},"getTotalReward()":{inputs:[],name:"getTotalReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned since the diamond deployment."},"getTotalSendingsPerStaker(address)":{inputs:[{internalType:"address",name:"staker",type:"address"}],name:"getTotalSendingsPerStaker",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{staker:"A staker address to be search info for."},returns:{_0:"A sum of tokens that are going to eventuely go to the `staker`."},notice:"Returns sum of all sendings to be delivered to certain `staker`."},"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"initialize(address,address,address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"rewardDistributor",type:"address"},{internalType:"address",name:"rewardsToken",type:"address"},{internalType:"address",name:"stakingToken",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"Owner of the diamond operations.",rewardDistributor:"An entity who would be able to provide rewards.",rewardsToken:"Token address to act as a reward token.",stakingToken:"Token address to act as a staking token."},notice:"An initalizer function for the diamond."},"lastTimeRewardApplicable()":{inputs:[],name:"lastTimeRewardApplicable",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"A timestamp."},notice:"Returns timestamp when last time the reward was provided to distribute to users."},"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"reward",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{reward:"An amount of tokens to be distributed among the users group."},notice:"Transfers from `msg.sender` (if they're a bearer of `REWARD_DISTRIBUTOR_ROLE`) a reward for the diamond users and starts a distribution resetting the staking cycle."},"prepareDepositary()":{inputs:[],name:"prepareDepositary",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Initializes OZ dependencies of the depositary facet. Can only be called by `OWNER_ROLE` bearer."},"processQueue()":{inputs:[],name:"processQueue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Cleares the queue. Iterates over every element in the queue, and if the sendings due is now, executes the sending.  If not, sets it back."},"processRewardSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"reward",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processRewardSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"Duration code if the rewards are sent with delay.",reward:"An amount of rewards to be sent.",staker:"A staker to which the rewards should be sent."},notice:"Either creates delayed sending of rewards or just sends the rewards immediately,  depends on what token is staking: Governance token - sends without delay, other - sends with delay."},"processWithdrawalSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processWithdrawalSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of withdrawal to be sent.",dueDuration:"Duration code if the withdrawal is sent with delay. ",staker:"A staker to which the withdrawal should be sent."},notice:"Either creates delayed sending of withdrawal or just withdraws the deposit immediately, depends on what token is staking: Governance token - sends with delay, other - sends without delay."},"recoverTokens(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenAmount",type:"uint256"}],name:"recoverTokens",outputs:[],stateMutability:"nonpayable",type:"function",params:{tokenAddress:"An address of stucked token.",tokenAmount:"An amount of stucked tokens."},notice:"Allows bearer of `OWNER_ROLE` to recover stucked tokens."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."},"rewardPerToken()":{inputs:[],name:"rewardPerToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns amount of rewards tokens worth of 1 staking token."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."},"setRewardsDuration(uint256)":{inputs:[{internalType:"uint256",name:"_rewardsDuration",type:"uint256"}],name:"setRewardsDuration",outputs:[],stateMutability:"nonpayable",type:"function",params:{_rewardsDuration:"A duration of staking cycle in seconds."},notice:"Sets a duration for staking cycle. Callable only by `OWNER_ROLE`."},"setWrappedStakingLocus(address)":{inputs:[{internalType:"address",name:"wrappedStLocusToken",type:"address"}],name:"setWrappedStakingLocus",outputs:[],stateMutability:"nonpayable",type:"function",details:"NOT UTILIZED ANYWHERE CURRENTLY. Could only be set by `OWNER_ROLE` bearer.",params:{wrappedStLocusToken:"Address of the EIP20 wrapper."},notice:"Setter for token representation of staking deposit."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns currently total staked tokens amount."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/DiamondLocusXDefiTokensStaking.sol:DiamondLocusXDefiTokensStaking":{source:"contracts/diamonds/locusStaking/DiamondLocusXDefiTokensStaking.sol",name:"DiamondLocusXDefiTokensStaking",details:"This MUST aggregate all of the faucets interfaces, to be able to grasp a full view of ABI in one place.",notice:'IMPORTANT: all of the collective diamond interfaces MUST be prefixed with "Diamond" word.',methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"addDelayedSending(address,address,uint256,uint8)":{inputs:[{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"},{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"}],name:"addDelayedSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be sent.",dueToDuration:"A duration code.",receiver:"A receiver of the sending.",sendingToken:"Token to be sent."},notice:"Creates a delayed sending of any token to any receiver. Could only be called by the diamond itself."},"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An entity to check."},returns:{_0:"An amount of tokens staked."},notice:"Returns a staked deposit of some entity."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"Decimals."},notice:"Returns EIP20-like precision."},"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."},"earned(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"earned",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An account to check."},returns:{_0:"Amount of tokens earned by the account."},notice:"Returns an amount of rewards tokens earned by an `account`."},"getAPR()":{inputs:[],name:"getAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"APR"},notice:"Returns an APR with constraint (reward rate is unchanging throughout the staking cycle). The precision of the APR equals to `10**<decimals of staking token>`."},"getAPRInAbsoluteValue()":{inputs:[],name:"getAPRInAbsoluteValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns an amount of tokens earned per 1 staking token throughout 1 staking cycle with actual but constant reward rate."},"getDelayedSending(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getDelayedSending",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{index:"Required index of the sending in the queue"},returns:{_0:"Found sending struct. "},notice:"Returns a sending struct with full info in the queue."},"getDequeSize()":{inputs:[],name:"getDequeSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"The size."},notice:"Returns size of the sendings queue."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"contract IERC20Metadata",name:"rewardsToken",type:"address"},{internalType:"contract IERC20Metadata",name:"stakingToken",type:"address"},{internalType:"uint256",name:"periodFinish",type:"uint256"},{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardsDuration",type:"uint256"},{internalType:"uint256",name:"lastUpdateTime",type:"uint256"},{internalType:"uint256",name:"rewardPerTokenStored",type:"uint256"},{internalType:"uint256",name:"totalSupply",type:"uint256"},{internalType:"uint256",name:"totalReward",type:"uint256"},{internalType:"address",name:"wrappedStLocusToken",type:"address"},{internalType:"bool",name:"areDepositsShut",type:"bool"}],internalType:"struct LSLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",returns:{_0:"`Primitives` struct."},notice:"Gives all primitive internal variables of the diamond."},"getProjectedAPR(uint256,uint256)":{inputs:[{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardDuration",type:"uint256"}],name:"getProjectedAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rewardDuration:"A staking cycle.",rewardRate:"A rate with which the rewards are accumulated."},returns:{_0:"Projected APR."},notice:"Returns an APR with the same constraint as is `getAPR`, but reward rate and staking cycle are variables."},"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"getRewardForDuration()":{inputs:[],name:"getRewardForDuration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned throughout of staking cycle."},"getSendingsDeque()":{inputs:[],name:"getSendingsDeque",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"A deque of sendings. (Or queue of sendings.)"},notice:"Returns full array of sendings queue."},"getSendingsDequeIndiciesStored()":{inputs:[],name:"getSendingsDequeIndiciesStored",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",notice:"Returns an array of IDs of the sendings, that are stored in public mapping.Array on indicies stored in the queue."},"getTotalReward()":{inputs:[],name:"getTotalReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned since the diamond deployment."},"getTotalSendingsPerStaker(address)":{inputs:[{internalType:"address",name:"staker",type:"address"}],name:"getTotalSendingsPerStaker",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{staker:"A staker address to be search info for."},returns:{_0:"A sum of tokens that are going to eventuely go to the `staker`."},notice:"Returns sum of all sendings to be delivered to certain `staker`."},"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"initialize(address,address,address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"rewardDistributor",type:"address"},{internalType:"address",name:"rewardsToken",type:"address"},{internalType:"address",name:"stakingToken",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"Owner of the diamond operations.",rewardDistributor:"An entity who would be able to provide rewards.",rewardsToken:"Token address to act as a reward token.",stakingToken:"Token address to act as a staking token."},notice:"An initalizer function for the diamond."},"lastTimeRewardApplicable()":{inputs:[],name:"lastTimeRewardApplicable",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"A timestamp."},notice:"Returns timestamp when last time the reward was provided to distribute to users."},"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"reward",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{reward:"An amount of tokens to be distributed among the users group."},notice:"Transfers from `msg.sender` (if they're a bearer of `REWARD_DISTRIBUTOR_ROLE`) a reward for the diamond users and starts a distribution resetting the staking cycle."},"prepareDepositary()":{inputs:[],name:"prepareDepositary",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Initializes OZ dependencies of the depositary facet. Can only be called by `OWNER_ROLE` bearer."},"processQueue()":{inputs:[],name:"processQueue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Cleares the queue. Iterates over every element in the queue, and if the sendings due is now, executes the sending.  If not, sets it back."},"processRewardSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"reward",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processRewardSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"Duration code if the rewards are sent with delay.",reward:"An amount of rewards to be sent.",staker:"A staker to which the rewards should be sent."},notice:"Either creates delayed sending of rewards or just sends the rewards immediately,  depends on what token is staking: Governance token - sends without delay, other - sends with delay."},"processWithdrawalSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processWithdrawalSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of withdrawal to be sent.",dueDuration:"Duration code if the withdrawal is sent with delay. ",staker:"A staker to which the withdrawal should be sent."},notice:"Either creates delayed sending of withdrawal or just withdraws the deposit immediately, depends on what token is staking: Governance token - sends with delay, other - sends without delay."},"recoverTokens(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenAmount",type:"uint256"}],name:"recoverTokens",outputs:[],stateMutability:"nonpayable",type:"function",params:{tokenAddress:"An address of stucked token.",tokenAmount:"An amount of stucked tokens."},notice:"Allows bearer of `OWNER_ROLE` to recover stucked tokens."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."},"rewardPerToken()":{inputs:[],name:"rewardPerToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns amount of rewards tokens worth of 1 staking token."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."},"setRewardsDuration(uint256)":{inputs:[{internalType:"uint256",name:"_rewardsDuration",type:"uint256"}],name:"setRewardsDuration",outputs:[],stateMutability:"nonpayable",type:"function",params:{_rewardsDuration:"A duration of staking cycle in seconds."},notice:"Sets a duration for staking cycle. Callable only by `OWNER_ROLE`."},"setWrappedStakingLocus(address)":{inputs:[{internalType:"address",name:"wrappedStLocusToken",type:"address"}],name:"setWrappedStakingLocus",outputs:[],stateMutability:"nonpayable",type:"function",details:"NOT UTILIZED ANYWHERE CURRENTLY. Could only be set by `OWNER_ROLE` bearer.",params:{wrappedStLocusToken:"Address of the EIP20 wrapper."},notice:"Setter for token representation of staking deposit."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns currently total staked tokens amount."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/DiamondLocusXEthTokensStaking.sol:DiamondLocusXEthTokensStaking":{source:"contracts/diamonds/locusStaking/DiamondLocusXEthTokensStaking.sol",name:"DiamondLocusXEthTokensStaking",details:"This MUST aggregate all of the faucets interfaces, to be able to grasp a full view of ABI in one place.",notice:'IMPORTANT: all of the collective diamond interfaces MUST be prefixed with "Diamond" word.',methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"addDelayedSending(address,address,uint256,uint8)":{inputs:[{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"},{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"}],name:"addDelayedSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be sent.",dueToDuration:"A duration code.",receiver:"A receiver of the sending.",sendingToken:"Token to be sent."},notice:"Creates a delayed sending of any token to any receiver. Could only be called by the diamond itself."},"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An entity to check."},returns:{_0:"An amount of tokens staked."},notice:"Returns a staked deposit of some entity."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"Decimals."},notice:"Returns EIP20-like precision."},"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."},"earned(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"earned",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An account to check."},returns:{_0:"Amount of tokens earned by the account."},notice:"Returns an amount of rewards tokens earned by an `account`."},"getAPR()":{inputs:[],name:"getAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"APR"},notice:"Returns an APR with constraint (reward rate is unchanging throughout the staking cycle). The precision of the APR equals to `10**<decimals of staking token>`."},"getAPRInAbsoluteValue()":{inputs:[],name:"getAPRInAbsoluteValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns an amount of tokens earned per 1 staking token throughout 1 staking cycle with actual but constant reward rate."},"getDelayedSending(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getDelayedSending",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{index:"Required index of the sending in the queue"},returns:{_0:"Found sending struct. "},notice:"Returns a sending struct with full info in the queue."},"getDequeSize()":{inputs:[],name:"getDequeSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"The size."},notice:"Returns size of the sendings queue."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"contract IERC20Metadata",name:"rewardsToken",type:"address"},{internalType:"contract IERC20Metadata",name:"stakingToken",type:"address"},{internalType:"uint256",name:"periodFinish",type:"uint256"},{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardsDuration",type:"uint256"},{internalType:"uint256",name:"lastUpdateTime",type:"uint256"},{internalType:"uint256",name:"rewardPerTokenStored",type:"uint256"},{internalType:"uint256",name:"totalSupply",type:"uint256"},{internalType:"uint256",name:"totalReward",type:"uint256"},{internalType:"address",name:"wrappedStLocusToken",type:"address"},{internalType:"bool",name:"areDepositsShut",type:"bool"}],internalType:"struct LSLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",returns:{_0:"`Primitives` struct."},notice:"Gives all primitive internal variables of the diamond."},"getProjectedAPR(uint256,uint256)":{inputs:[{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardDuration",type:"uint256"}],name:"getProjectedAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rewardDuration:"A staking cycle.",rewardRate:"A rate with which the rewards are accumulated."},returns:{_0:"Projected APR."},notice:"Returns an APR with the same constraint as is `getAPR`, but reward rate and staking cycle are variables."},"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"getRewardForDuration()":{inputs:[],name:"getRewardForDuration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned throughout of staking cycle."},"getSendingsDeque()":{inputs:[],name:"getSendingsDeque",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"A deque of sendings. (Or queue of sendings.)"},notice:"Returns full array of sendings queue."},"getSendingsDequeIndiciesStored()":{inputs:[],name:"getSendingsDequeIndiciesStored",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",notice:"Returns an array of IDs of the sendings, that are stored in public mapping.Array on indicies stored in the queue."},"getTotalReward()":{inputs:[],name:"getTotalReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned since the diamond deployment."},"getTotalSendingsPerStaker(address)":{inputs:[{internalType:"address",name:"staker",type:"address"}],name:"getTotalSendingsPerStaker",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{staker:"A staker address to be search info for."},returns:{_0:"A sum of tokens that are going to eventuely go to the `staker`."},notice:"Returns sum of all sendings to be delivered to certain `staker`."},"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"initialize(address,address,address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"rewardDistributor",type:"address"},{internalType:"address",name:"rewardsToken",type:"address"},{internalType:"address",name:"stakingToken",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"Owner of the diamond operations.",rewardDistributor:"An entity who would be able to provide rewards.",rewardsToken:"Token address to act as a reward token.",stakingToken:"Token address to act as a staking token."},notice:"An initalizer function for the diamond."},"lastTimeRewardApplicable()":{inputs:[],name:"lastTimeRewardApplicable",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"A timestamp."},notice:"Returns timestamp when last time the reward was provided to distribute to users."},"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"reward",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{reward:"An amount of tokens to be distributed among the users group."},notice:"Transfers from `msg.sender` (if they're a bearer of `REWARD_DISTRIBUTOR_ROLE`) a reward for the diamond users and starts a distribution resetting the staking cycle."},"prepareDepositary()":{inputs:[],name:"prepareDepositary",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Initializes OZ dependencies of the depositary facet. Can only be called by `OWNER_ROLE` bearer."},"processQueue()":{inputs:[],name:"processQueue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Cleares the queue. Iterates over every element in the queue, and if the sendings due is now, executes the sending.  If not, sets it back."},"processRewardSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"reward",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processRewardSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"Duration code if the rewards are sent with delay.",reward:"An amount of rewards to be sent.",staker:"A staker to which the rewards should be sent."},notice:"Either creates delayed sending of rewards or just sends the rewards immediately,  depends on what token is staking: Governance token - sends without delay, other - sends with delay."},"processWithdrawalSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processWithdrawalSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of withdrawal to be sent.",dueDuration:"Duration code if the withdrawal is sent with delay. ",staker:"A staker to which the withdrawal should be sent."},notice:"Either creates delayed sending of withdrawal or just withdraws the deposit immediately, depends on what token is staking: Governance token - sends with delay, other - sends without delay."},"recoverTokens(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenAmount",type:"uint256"}],name:"recoverTokens",outputs:[],stateMutability:"nonpayable",type:"function",params:{tokenAddress:"An address of stucked token.",tokenAmount:"An amount of stucked tokens."},notice:"Allows bearer of `OWNER_ROLE` to recover stucked tokens."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."},"rewardPerToken()":{inputs:[],name:"rewardPerToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns amount of rewards tokens worth of 1 staking token."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."},"setRewardsDuration(uint256)":{inputs:[{internalType:"uint256",name:"_rewardsDuration",type:"uint256"}],name:"setRewardsDuration",outputs:[],stateMutability:"nonpayable",type:"function",params:{_rewardsDuration:"A duration of staking cycle in seconds."},notice:"Sets a duration for staking cycle. Callable only by `OWNER_ROLE`."},"setWrappedStakingLocus(address)":{inputs:[{internalType:"address",name:"wrappedStLocusToken",type:"address"}],name:"setWrappedStakingLocus",outputs:[],stateMutability:"nonpayable",type:"function",details:"NOT UTILIZED ANYWHERE CURRENTLY. Could only be set by `OWNER_ROLE` bearer.",params:{wrappedStLocusToken:"Address of the EIP20 wrapper."},notice:"Setter for token representation of staking deposit."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns currently total staked tokens amount."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/DiamondLocusXUsdTokensStaking.sol:DiamondLocusXUsdTokensStaking":{source:"contracts/diamonds/locusStaking/DiamondLocusXUsdTokensStaking.sol",name:"DiamondLocusXUsdTokensStaking",details:"This MUST aggregate all of the faucets interfaces, to be able to grasp a full view of ABI in one place.",notice:'IMPORTANT: all of the collective diamond interfaces MUST be prefixed with "Diamond" word.',methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"addDelayedSending(address,address,uint256,uint8)":{inputs:[{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"},{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"}],name:"addDelayedSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be sent.",dueToDuration:"A duration code.",receiver:"A receiver of the sending.",sendingToken:"Token to be sent."},notice:"Creates a delayed sending of any token to any receiver. Could only be called by the diamond itself."},"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An entity to check."},returns:{_0:"An amount of tokens staked."},notice:"Returns a staked deposit of some entity."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"Decimals."},notice:"Returns EIP20-like precision."},"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."},"earned(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"earned",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An account to check."},returns:{_0:"Amount of tokens earned by the account."},notice:"Returns an amount of rewards tokens earned by an `account`."},"getAPR()":{inputs:[],name:"getAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"APR"},notice:"Returns an APR with constraint (reward rate is unchanging throughout the staking cycle). The precision of the APR equals to `10**<decimals of staking token>`."},"getAPRInAbsoluteValue()":{inputs:[],name:"getAPRInAbsoluteValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns an amount of tokens earned per 1 staking token throughout 1 staking cycle with actual but constant reward rate."},"getDelayedSending(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getDelayedSending",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{index:"Required index of the sending in the queue"},returns:{_0:"Found sending struct. "},notice:"Returns a sending struct with full info in the queue."},"getDequeSize()":{inputs:[],name:"getDequeSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"The size."},notice:"Returns size of the sendings queue."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"contract IERC20Metadata",name:"rewardsToken",type:"address"},{internalType:"contract IERC20Metadata",name:"stakingToken",type:"address"},{internalType:"uint256",name:"periodFinish",type:"uint256"},{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardsDuration",type:"uint256"},{internalType:"uint256",name:"lastUpdateTime",type:"uint256"},{internalType:"uint256",name:"rewardPerTokenStored",type:"uint256"},{internalType:"uint256",name:"totalSupply",type:"uint256"},{internalType:"uint256",name:"totalReward",type:"uint256"},{internalType:"address",name:"wrappedStLocusToken",type:"address"},{internalType:"bool",name:"areDepositsShut",type:"bool"}],internalType:"struct LSLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",returns:{_0:"`Primitives` struct."},notice:"Gives all primitive internal variables of the diamond."},"getProjectedAPR(uint256,uint256)":{inputs:[{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardDuration",type:"uint256"}],name:"getProjectedAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rewardDuration:"A staking cycle.",rewardRate:"A rate with which the rewards are accumulated."},returns:{_0:"Projected APR."},notice:"Returns an APR with the same constraint as is `getAPR`, but reward rate and staking cycle are variables."},"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"getRewardForDuration()":{inputs:[],name:"getRewardForDuration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned throughout of staking cycle."},"getSendingsDeque()":{inputs:[],name:"getSendingsDeque",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"A deque of sendings. (Or queue of sendings.)"},notice:"Returns full array of sendings queue."},"getSendingsDequeIndiciesStored()":{inputs:[],name:"getSendingsDequeIndiciesStored",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",notice:"Returns an array of IDs of the sendings, that are stored in public mapping.Array on indicies stored in the queue."},"getTotalReward()":{inputs:[],name:"getTotalReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned since the diamond deployment."},"getTotalSendingsPerStaker(address)":{inputs:[{internalType:"address",name:"staker",type:"address"}],name:"getTotalSendingsPerStaker",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{staker:"A staker address to be search info for."},returns:{_0:"A sum of tokens that are going to eventuely go to the `staker`."},notice:"Returns sum of all sendings to be delivered to certain `staker`."},"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"initialize(address,address,address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"rewardDistributor",type:"address"},{internalType:"address",name:"rewardsToken",type:"address"},{internalType:"address",name:"stakingToken",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"Owner of the diamond operations.",rewardDistributor:"An entity who would be able to provide rewards.",rewardsToken:"Token address to act as a reward token.",stakingToken:"Token address to act as a staking token."},notice:"An initalizer function for the diamond."},"lastTimeRewardApplicable()":{inputs:[],name:"lastTimeRewardApplicable",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"A timestamp."},notice:"Returns timestamp when last time the reward was provided to distribute to users."},"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"reward",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{reward:"An amount of tokens to be distributed among the users group."},notice:"Transfers from `msg.sender` (if they're a bearer of `REWARD_DISTRIBUTOR_ROLE`) a reward for the diamond users and starts a distribution resetting the staking cycle."},"prepareDepositary()":{inputs:[],name:"prepareDepositary",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Initializes OZ dependencies of the depositary facet. Can only be called by `OWNER_ROLE` bearer."},"processQueue()":{inputs:[],name:"processQueue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Cleares the queue. Iterates over every element in the queue, and if the sendings due is now, executes the sending.  If not, sets it back."},"processRewardSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"reward",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processRewardSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"Duration code if the rewards are sent with delay.",reward:"An amount of rewards to be sent.",staker:"A staker to which the rewards should be sent."},notice:"Either creates delayed sending of rewards or just sends the rewards immediately,  depends on what token is staking: Governance token - sends without delay, other - sends with delay."},"processWithdrawalSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processWithdrawalSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of withdrawal to be sent.",dueDuration:"Duration code if the withdrawal is sent with delay. ",staker:"A staker to which the withdrawal should be sent."},notice:"Either creates delayed sending of withdrawal or just withdraws the deposit immediately, depends on what token is staking: Governance token - sends with delay, other - sends without delay."},"recoverTokens(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenAmount",type:"uint256"}],name:"recoverTokens",outputs:[],stateMutability:"nonpayable",type:"function",params:{tokenAddress:"An address of stucked token.",tokenAmount:"An amount of stucked tokens."},notice:"Allows bearer of `OWNER_ROLE` to recover stucked tokens."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."},"rewardPerToken()":{inputs:[],name:"rewardPerToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns amount of rewards tokens worth of 1 staking token."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."},"setRewardsDuration(uint256)":{inputs:[{internalType:"uint256",name:"_rewardsDuration",type:"uint256"}],name:"setRewardsDuration",outputs:[],stateMutability:"nonpayable",type:"function",params:{_rewardsDuration:"A duration of staking cycle in seconds."},notice:"Sets a duration for staking cycle. Callable only by `OWNER_ROLE`."},"setWrappedStakingLocus(address)":{inputs:[{internalType:"address",name:"wrappedStLocusToken",type:"address"}],name:"setWrappedStakingLocus",outputs:[],stateMutability:"nonpayable",type:"function",details:"NOT UTILIZED ANYWHERE CURRENTLY. Could only be set by `OWNER_ROLE` bearer.",params:{wrappedStLocusToken:"Address of the EIP20 wrapper."},notice:"Setter for token representation of staking deposit."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns currently total staked tokens amount."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/LSLib.sol:LSLib":{source:"contracts/diamonds/locusStaking/LSLib.sol",name:"LSLib",events:{"MigrationComplete(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"who",type:"address"},{indexed:!0,internalType:"uint256",name:"index",type:"uint256"}],name:"MigrationComplete",type:"event",params:{index:"Users index in the queue on restoration.",who:"User whose balance to be restored."},notice:"WARNING: NEVER USED ANYWHERE AFTER THE INCIDENT. Emits when a users balance has been restored. "},"Recovered(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"Recovered",type:"event",params:{amount:"An amount of recovered tokens.",token:"Token that was recovered."},notice:"Emits when some stucked tokens are retrieved by `OWNER_ROLE` bearer."},"RewardAdded(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"reward",type:"uint256"}],name:"RewardAdded",type:"event",params:{reward:"An amount to be distributed to users."},notice:"Emits when new rewards amount is added to distribution."},"RewardsDurationUpdated(uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"uint256",name:"newDuration",type:"uint256"}],name:"RewardsDurationUpdated",type:"event",params:{newDuration:"New duration of staking cycle in seconds."},notice:"Emits when staking cycle duration is altered."},"SentOut(address,address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"token",type:"address"},{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"},{indexed:!1,internalType:"uint256",name:"feesTaken",type:"uint256"}],name:"SentOut",type:"event",params:{amount:"An amount to be sent.",feesTaken:"Possible amount of fees to be sent.",token:"Token to be sent.",user:"A receiver of the sending."},notice:"Emits when a delayed sending is executed on due or immedeately."},"Staked(address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"user",type:"address"},{indexed:!0,internalType:"uint256",name:"amount",type:"uint256"}],name:"Staked",type:"event",params:{amount:"An amount ot stake.",user:"A staker."},notice:"Emits when `user` does stake `amount` of staking tokens."}},stateVariables:{"ALLOWED_TO_STAKE_FOR_ROLE()":{inputs:[],name:"ALLOWED_TO_STAKE_FOR_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:"Classic `AccessControl` role. Allows the bearer to stake for users."},"REWARD_DISTRIBUTOR_ROLE()":{inputs:[],name:"REWARD_DISTRIBUTOR_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:"Classic `AccessControl` role. Allows the bearer to send and distribute rewards."}},methods:{"PRECISION()":{inputs:[],name:"PRECISION",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",notice:"Precision for math calculations in the diamond."}}},"contracts/diamonds/locusStaking/v1/LSInitializerFacet.sol:LSInitializerFacet":{source:"contracts/diamonds/locusStaking/v1/LSInitializerFacet.sol",name:"LSInitializerFacet",title:"A facet that implements the diamond initalization.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"initialize(address,address,address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"rewardDistributor",type:"address"},{internalType:"address",name:"rewardsToken",type:"address"},{internalType:"address",name:"stakingToken",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"Owner of the diamond operations.",rewardDistributor:"An entity who would be able to provide rewards.",rewardsToken:"Token address to act as a reward token.",stakingToken:"Token address to act as a staking token."},notice:"An initalizer function for the diamond."},"prepareDepositary()":{inputs:[],name:"prepareDepositary",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Initializes OZ dependencies of the depositary facet. Can only be called by `OWNER_ROLE` bearer."},"setWrappedStakingLocus(address)":{inputs:[{internalType:"address",name:"wrappedStLocusToken",type:"address"}],name:"setWrappedStakingLocus",outputs:[],stateMutability:"nonpayable",type:"function",details:"NOT UTILIZED ANYWHERE CURRENTLY. Could only be set by `OWNER_ROLE` bearer.",params:{wrappedStLocusToken:"Address of the EIP20 wrapper."},notice:"Setter for token representation of staking deposit."}}},"contracts/diamonds/locusStaking/v1/LSLoupeFacet.sol:LSLoupeFacet":{source:"contracts/diamonds/locusStaking/v1/LSLoupeFacet.sol",name:"LSLoupeFacet",title:"A facet that implements view functions of the diamond.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An entity to check."},returns:{_0:"An amount of tokens staked."},notice:"Returns a staked deposit of some entity."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"Decimals."},notice:"Returns EIP20-like precision."},"earned(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"earned",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An account to check."},returns:{_0:"Amount of tokens earned by the account."},notice:"Returns an amount of rewards tokens earned by an `account`."},"getAPR()":{inputs:[],name:"getAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"APR"},notice:"Returns an APR with constraint (reward rate is unchanging throughout the staking cycle). The precision of the APR equals to `10**<decimals of staking token>`."},"getAPRInAbsoluteValue()":{inputs:[],name:"getAPRInAbsoluteValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns an amount of tokens earned per 1 staking token throughout 1 staking cycle with actual but constant reward rate."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"contract IERC20Metadata",name:"rewardsToken",type:"address"},{internalType:"contract IERC20Metadata",name:"stakingToken",type:"address"},{internalType:"uint256",name:"periodFinish",type:"uint256"},{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardsDuration",type:"uint256"},{internalType:"uint256",name:"lastUpdateTime",type:"uint256"},{internalType:"uint256",name:"rewardPerTokenStored",type:"uint256"},{internalType:"uint256",name:"totalSupply",type:"uint256"},{internalType:"uint256",name:"totalReward",type:"uint256"},{internalType:"address",name:"wrappedStLocusToken",type:"address"},{internalType:"bool",name:"areDepositsShut",type:"bool"}],internalType:"struct LSLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",returns:{_0:"`Primitives` struct."},notice:"Gives all primitive internal variables of the diamond."},"getProjectedAPR(uint256,uint256)":{inputs:[{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardDuration",type:"uint256"}],name:"getProjectedAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rewardDuration:"A staking cycle.",rewardRate:"A rate with which the rewards are accumulated."},returns:{_0:"Projected APR."},notice:"Returns an APR with the same constraint as is `getAPR`, but reward rate and staking cycle are variables."},"getRewardForDuration()":{inputs:[],name:"getRewardForDuration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned throughout of staking cycle."},"getTotalReward()":{inputs:[],name:"getTotalReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned since the diamond deployment."},"lastTimeRewardApplicable()":{inputs:[],name:"lastTimeRewardApplicable",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"A timestamp."},notice:"Returns timestamp when last time the reward was provided to distribute to users."},"rewardPerToken()":{inputs:[],name:"rewardPerToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns amount of rewards tokens worth of 1 staking token."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns currently total staked tokens amount."}}},"contracts/diamonds/locusStaking/v1/LSManagementFacet.sol:LSManagementFacet":{source:"contracts/diamonds/locusStaking/v1/LSManagementFacet.sol",name:"LSManagementFacet",title:"A facet that implements managemental functionality of the diamond.  Specifically: rewards management, setting duration of the staking cycle, recovering stuck tokens that are allowed to be extracted.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"reward",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{reward:"An amount of tokens to be distributed among the users group."},notice:"Transfers from `msg.sender` (if they're a bearer of `REWARD_DISTRIBUTOR_ROLE`) a reward for the diamond users and starts a distribution resetting the staking cycle."},"recoverTokens(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenAmount",type:"uint256"}],name:"recoverTokens",outputs:[],stateMutability:"nonpayable",type:"function",params:{tokenAddress:"An address of stucked token.",tokenAmount:"An amount of stucked tokens."},notice:"Allows bearer of `OWNER_ROLE` to recover stucked tokens."},"setRewardsDuration(uint256)":{inputs:[{internalType:"uint256",name:"_rewardsDuration",type:"uint256"}],name:"setRewardsDuration",outputs:[],stateMutability:"nonpayable",type:"function",params:{_rewardsDuration:"A duration of staking cycle in seconds."},notice:"Sets a duration for staking cycle. Callable only by `OWNER_ROLE`."}}},"contracts/diamonds/locusStaking/v1/governanceTokenStaking/LSDepositaryFacet.sol:LSDepositaryFacet":{source:"contracts/diamonds/locusStaking/v1/governanceTokenStaking/LSDepositaryFacet.sol",name:"LSDepositaryFacet",title:"A facet that implements the depositary logic for users.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Returns if the diamond has been paused or not."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Unpauses the diamond."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Pauses the diamond."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/v1/governanceTokenStaking/LSProcessFeesFacet.sol:LSProcessFeesFacet":{source:"contracts/diamonds/locusStaking/v1/governanceTokenStaking/LSProcessFeesFacet.sol",name:"LSProcessFeesFacet",title:"A facet that implements creation of delayed sendings of either rewards or withdrawals depending on what is staking. Governance token or any other EIP20-compatible token.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"processRewardSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"reward",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"",type:"uint8"}],name:"processRewardSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"Duration code if the rewards are sent with delay.",reward:"An amount of rewards to be sent.",staker:"A staker to which the rewards should be sent."},notice:"Either creates delayed sending of rewards or just sends the rewards immediately,  depends on what token is staking: Governance token - sends without delay, other - sends with delay."},"processWithdrawalSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processWithdrawalSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of withdrawal to be sent.",dueDuration:"Duration code if the withdrawal is sent with delay. ",staker:"A staker to which the withdrawal should be sent."},notice:"Either creates delayed sending of withdrawal or just withdraws the deposit immediately, depends on what token is staking: Governance token - sends with delay, other - sends without delay."}}},"contracts/diamonds/locusStaking/v1/interfaces/ILSDepositaryFacet.sol:ILSDepositaryFacet":{source:"contracts/diamonds/locusStaking/v1/interfaces/ILSDepositaryFacet.sol",name:"ILSDepositaryFacet",title:"A facet that implements the depositary logic for users.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/v1/interfaces/ILSGeneralDepositaryFacet.sol:ILSGeneralDepositaryFacet":{source:"contracts/diamonds/locusStaking/v1/interfaces/ILSGeneralDepositaryFacet.sol",name:"ILSGeneralDepositaryFacet",title:"A facet that implements the basic depositary logic for users, specifically: `stakeFor`, `stake`, `getReward`, `updateReward`.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Returns if the diamond has been paused or not."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Unpauses the diamond."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Pauses the diamond."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/v1/interfaces/ILSInitializerFacet.sol:ILSInitializerFacet":{source:"contracts/diamonds/locusStaking/v1/interfaces/ILSInitializerFacet.sol",name:"ILSInitializerFacet",title:"A facet that implements the diamond initalization.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"initialize(address,address,address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"rewardDistributor",type:"address"},{internalType:"address",name:"rewardsToken",type:"address"},{internalType:"address",name:"stakingToken",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"Owner of the diamond operations.",rewardDistributor:"An entity who would be able to provide rewards.",rewardsToken:"Token address to act as a reward token.",stakingToken:"Token address to act as a staking token."},notice:"An initalizer function for the diamond."},"prepareDepositary()":{inputs:[],name:"prepareDepositary",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Initializes OZ dependencies of the depositary facet. Can only be called by `OWNER_ROLE` bearer."},"setWrappedStakingLocus(address)":{inputs:[{internalType:"address",name:"wrappedStLocusToken",type:"address"}],name:"setWrappedStakingLocus",outputs:[],stateMutability:"nonpayable",type:"function",details:"NOT UTILIZED ANYWHERE CURRENTLY. Could only be set by `OWNER_ROLE` bearer.",params:{wrappedStLocusToken:"Address of the EIP20 wrapper."},notice:"Setter for token representation of staking deposit."}}},"contracts/diamonds/locusStaking/v1/interfaces/ILSLoupeFacet.sol:ILSLoupeFacet":{source:"contracts/diamonds/locusStaking/v1/interfaces/ILSLoupeFacet.sol",name:"ILSLoupeFacet",title:"A facet that implements view functions of the diamond.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An entity to check."},returns:{_0:"An amount of tokens staked."},notice:"Returns a staked deposit of some entity."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",returns:{_0:"Decimals."},notice:"Returns EIP20-like precision."},"earned(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"earned",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{account:"An account to check."},returns:{_0:"Amount of tokens earned by the account."},notice:"Returns an amount of rewards tokens earned by an `account`."},"getAPR()":{inputs:[],name:"getAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"APR"},notice:"Returns an APR with constraint (reward rate is unchanging throughout the staking cycle). The precision of the APR equals to `10**<decimals of staking token>`."},"getAPRInAbsoluteValue()":{inputs:[],name:"getAPRInAbsoluteValue",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns an amount of tokens earned per 1 staking token throughout 1 staking cycle with actual but constant reward rate."},"getPrimitives()":{inputs:[],name:"getPrimitives",outputs:[{components:[{internalType:"contract IERC20Metadata",name:"rewardsToken",type:"address"},{internalType:"contract IERC20Metadata",name:"stakingToken",type:"address"},{internalType:"uint256",name:"periodFinish",type:"uint256"},{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardsDuration",type:"uint256"},{internalType:"uint256",name:"lastUpdateTime",type:"uint256"},{internalType:"uint256",name:"rewardPerTokenStored",type:"uint256"},{internalType:"uint256",name:"totalSupply",type:"uint256"},{internalType:"uint256",name:"totalReward",type:"uint256"},{internalType:"address",name:"wrappedStLocusToken",type:"address"},{internalType:"bool",name:"areDepositsShut",type:"bool"}],internalType:"struct LSLib.Primitives",name:"",type:"tuple"}],stateMutability:"view",type:"function",returns:{_0:"`Primitives` struct."},notice:"Gives all primitive internal variables of the diamond."},"getProjectedAPR(uint256,uint256)":{inputs:[{internalType:"uint256",name:"rewardRate",type:"uint256"},{internalType:"uint256",name:"rewardDuration",type:"uint256"}],name:"getProjectedAPR",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{rewardDuration:"A staking cycle.",rewardRate:"A rate with which the rewards are accumulated."},returns:{_0:"Projected APR."},notice:"Returns an APR with the same constraint as is `getAPR`, but reward rate and staking cycle are variables."},"getRewardForDuration()":{inputs:[],name:"getRewardForDuration",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned throughout of staking cycle."},"getTotalReward()":{inputs:[],name:"getTotalReward",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns a total amount rewards earned since the diamond deployment."},"lastTimeRewardApplicable()":{inputs:[],name:"lastTimeRewardApplicable",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"A timestamp."},notice:"Returns timestamp when last time the reward was provided to distribute to users."},"rewardPerToken()":{inputs:[],name:"rewardPerToken",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns amount of rewards tokens worth of 1 staking token."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"An amount of tokens."},notice:"Returns currently total staked tokens amount."}}},"contracts/diamonds/locusStaking/v1/interfaces/ILSManagementFacet.sol:ILSManagementFacet":{source:"contracts/diamonds/locusStaking/v1/interfaces/ILSManagementFacet.sol",name:"ILSManagementFacet",title:"A facet that implements managemental functionality of the diamond.  Specifically: rewards management, setting duration of the staking cycle, recovering stuck tokens that are allowed to be extracted.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"notifyRewardAmount(uint256)":{inputs:[{internalType:"uint256",name:"reward",type:"uint256"}],name:"notifyRewardAmount",outputs:[],stateMutability:"nonpayable",type:"function",params:{reward:"An amount of tokens to be distributed among the users group."},notice:"Transfers from `msg.sender` (if they're a bearer of `REWARD_DISTRIBUTOR_ROLE`) a reward for the diamond users and starts a distribution resetting the staking cycle."},"recoverTokens(address,uint256)":{inputs:[{internalType:"address",name:"tokenAddress",type:"address"},{internalType:"uint256",name:"tokenAmount",type:"uint256"}],name:"recoverTokens",outputs:[],stateMutability:"nonpayable",type:"function",params:{tokenAddress:"An address of stucked token.",tokenAmount:"An amount of stucked tokens."},notice:"Allows bearer of `OWNER_ROLE` to recover stucked tokens."},"setRewardsDuration(uint256)":{inputs:[{internalType:"uint256",name:"_rewardsDuration",type:"uint256"}],name:"setRewardsDuration",outputs:[],stateMutability:"nonpayable",type:"function",params:{_rewardsDuration:"A duration of staking cycle in seconds."},notice:"Sets a duration for staking cycle. Callable only by `OWNER_ROLE`."}}},"contracts/diamonds/locusStaking/v1/interfaces/ILSProcessFeesFacet.sol:ILSProcessFeesFacet":{source:"contracts/diamonds/locusStaking/v1/interfaces/ILSProcessFeesFacet.sol",name:"ILSProcessFeesFacet",title:"A facet that implements creation of delayed sendings of either rewards or withdrawals depending on what is staking. Governance token or any other EIP20-compatible token.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"processRewardSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"reward",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processRewardSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"Duration code if the rewards are sent with delay.",reward:"An amount of rewards to be sent.",staker:"A staker to which the rewards should be sent."},notice:"Either creates delayed sending of rewards or just sends the rewards immediately,  depends on what token is staking: Governance token - sends without delay, other - sends with delay."},"processWithdrawalSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processWithdrawalSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of withdrawal to be sent.",dueDuration:"Duration code if the withdrawal is sent with delay. ",staker:"A staker to which the withdrawal should be sent."},notice:"Either creates delayed sending of withdrawal or just withdraws the deposit immediately, depends on what token is staking: Governance token - sends with delay, other - sends without delay."}}},"contracts/diamonds/locusStaking/v1/vaultTokenStaking/LSDepositaryForVaultTokensFacet.sol:LSDepositaryForVaultTokensFacet":{source:"contracts/diamonds/locusStaking/v1/vaultTokenStaking/LSDepositaryForVaultTokensFacet.sol",name:"LSDepositaryForVaultTokensFacet",title:"A facet that implements the depositary logic for users. But for vault tokens.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"_initialize_LSDepositaryFacet()":{inputs:[],name:"_initialize_LSDepositaryFacet",outputs:[],stateMutability:"nonpayable",type:"function",details:"MIND THAT THIS SHOULD BE THE ONLY SMART CONTRACT (MEANING REENTRANCY GUARD) FROM OZ LIB THAT IS TO BE UTILIZIED IN THIS DIAMOND.",notice:"An internal diamond-wise view function that initializes OZ dependencies of the facet."},"getReward(uint8)":{inputs:[{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"getReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"A code of time duration interval to expect earned funds after."},notice:"Allows to acquire earned rewards from staking by `msg.sender`."},"pause()":{inputs:[],name:"pause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Returns if the diamond has been paused or not."},"paused()":{inputs:[],name:"paused",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",notice:"Unpauses the diamond."},"stake(uint256)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"}],name:"stake",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to stake."},notice:"Stakes a certain amount of staking token for `msg.sender`."},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function",details:"Could be called only by authorized entity.",params:{amount:"An amount of tokens to stake.",staker:"A staker address for the staking."},notice:"Stakes a certain amount of staking token for `sender`."},"unpause()":{inputs:[],name:"unpause",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Pauses the diamond."},"updateReward(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"updateReward",outputs:[],stateMutability:"nonpayable",type:"function",params:{account:"An account to update rewards gaining math for."},notice:"Allows to update rewards gaining math for an account."},"withdraw(uint256,uint8)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"withdraw",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of tokens to withdraw.",dueDuration:"A code of time duration interval to expect withdrawn funds after."},notice:"Allows to perform a withdrawal for `msg.sender`."}}},"contracts/diamonds/locusStaking/v1/vaultTokenStaking/LSProcessFeesForVaultTokensFacet.sol:LSProcessFeesForVaultTokensFacet":{source:"contracts/diamonds/locusStaking/v1/vaultTokenStaking/LSProcessFeesForVaultTokensFacet.sol",name:"LSProcessFeesForVaultTokensFacet",title:"A facet that implements creation of delayed sendings for vault tokens. ",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"processRewardSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"reward",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueDuration",type:"uint8"}],name:"processRewardSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{dueDuration:"Duration code if the rewards are sent with delay.",reward:"An amount of rewards to be sent.",staker:"A staker to which the rewards should be sent."},notice:"Either creates delayed sending of rewards or just sends the rewards immediately,  depends on what token is staking: Governance token - sends without delay, other - sends with delay."},"processWithdrawalSending(address,uint256,uint8)":{inputs:[{internalType:"address",name:"staker",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"",type:"uint8"}],name:"processWithdrawalSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of withdrawal to be sent.",dueDuration:"Duration code if the withdrawal is sent with delay. ",staker:"A staker to which the withdrawal should be sent."},notice:"Either creates delayed sending of withdrawal or just withdraws the deposit immediately, depends on what token is staking: Governance token - sends with delay, other - sends without delay."}}},"contracts/diamonds/locusStaking/v2/manualWithdrawQueueFacets/LSSendingsDequeFacet.sol:LSSendingsDequeFacet":{source:"contracts/diamonds/locusStaking/v2/manualWithdrawQueueFacets/LSSendingsDequeFacet.sol",name:"LSSendingsDequeFacet",title:"A facet that implements CRUD operations on delayed sendings. It also implements queue clearing of those delayed sendings.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"addDelayedSending(address,address,uint256,uint8)":{inputs:[{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"},{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"}],name:"addDelayedSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be sent.",dueToDuration:"A duration code.",receiver:"A receiver of the sending.",sendingToken:"Token to be sent."},notice:"Creates a delayed sending of any token to any receiver. Could only be called by the diamond itself."},"processQueue()":{inputs:[],name:"processQueue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Cleares the queue. Iterates over every element in the queue, and if the sendings due is now, executes the sending.  If not, sets it back."}}},"contracts/diamonds/locusStaking/v2/manualWithdrawQueueFacets/LSSendingsDequeLoupeFacet.sol:LSSendingsDequeLoupeFacet":{source:"contracts/diamonds/locusStaking/v2/manualWithdrawQueueFacets/LSSendingsDequeLoupeFacet.sol",name:"LSSendingsDequeLoupeFacet",title:"A facet that implements getters and iteration tools over the delayed sendings queue.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"getDelayedSending(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getDelayedSending",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{index:"Required index of the sending in the queue"},returns:{_0:"Found sending struct. "},notice:"Returns a sending struct with full info in the queue."},"getDequeSize()":{inputs:[],name:"getDequeSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"The size."},notice:"Returns size of the sendings queue."},"getSendingsDeque()":{inputs:[],name:"getSendingsDeque",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending[]",name:"result",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{result:"A deque of sendings. (Or queue of sendings.)"},notice:"Returns full array of sendings queue."},"getSendingsDequeIndiciesStored()":{inputs:[],name:"getSendingsDequeIndiciesStored",outputs:[{internalType:"uint256[]",name:"result",type:"uint256[]"}],stateMutability:"view",type:"function",notice:"Returns an array of IDs of the sendings, that are stored in public mapping.Array on indicies stored in the queue."},"getTotalSendingsPerStaker(address)":{inputs:[{internalType:"address",name:"staker",type:"address"}],name:"getTotalSendingsPerStaker",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{staker:"A staker address to be search info for."},returns:{_0:"A sum of tokens that are going to eventuely go to the `staker`."},notice:"Returns sum of all sendings to be delivered to certain `staker`."}}},"contracts/diamonds/locusStaking/v2/manualWithdrawQueueFacets/interfaces/ILSSendingsDequeFacet.sol:ILSSendingsDequeFacet":{source:"contracts/diamonds/locusStaking/v2/manualWithdrawQueueFacets/interfaces/ILSSendingsDequeFacet.sol",name:"ILSSendingsDequeFacet",title:"A facet that implements CRUD operations on delayed sendings. It also implements queue clearing of those delayed sendings.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"addDelayedSending(address,address,uint256,uint8)":{inputs:[{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"},{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"}],name:"addDelayedSending",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount to be sent.",dueToDuration:"A duration code.",receiver:"A receiver of the sending.",sendingToken:"Token to be sent."},notice:"Creates a delayed sending of any token to any receiver. Could only be called by the diamond itself."},"processQueue()":{inputs:[],name:"processQueue",outputs:[],stateMutability:"nonpayable",type:"function",notice:"Cleares the queue. Iterates over every element in the queue, and if the sendings due is now, executes the sending.  If not, sets it back."}}},"contracts/diamonds/locusStaking/v2/manualWithdrawQueueFacets/interfaces/ILSSendingsDequeLoupeFacet.sol:ILSSendingsDequeLoupeFacet":{source:"contracts/diamonds/locusStaking/v2/manualWithdrawQueueFacets/interfaces/ILSSendingsDequeLoupeFacet.sol",name:"ILSSendingsDequeLoupeFacet",title:"A facet that implements getters and iteration tools over the delayed sendings queue.",author:"Oleg Bedrin <o.bedrin@locus.finance> - Locus Team",notice:"The contract is meant to be utilized as a EIP2535 proxy facet. Hence it cannot be called directly and not through the diamond proxy.",methods:{"getDelayedSending(uint256)":{inputs:[{internalType:"uint256",name:"index",type:"uint256"}],name:"getDelayedSending",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending",name:"",type:"tuple"}],stateMutability:"view",type:"function",params:{index:"Required index of the sending in the queue"},returns:{_0:"Found sending struct. "},notice:"Returns a sending struct with full info in the queue."},"getDequeSize()":{inputs:[],name:"getDequeSize",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",returns:{_0:"The size."},notice:"Returns size of the sendings queue."},"getSendingsDeque()":{inputs:[],name:"getSendingsDeque",outputs:[{components:[{internalType:"address",name:"receiver",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"uint256",name:"dueToTimestamp",type:"uint256"},{internalType:"enum DelayedSendingsQueueLib.DueDuration",name:"dueToDuration",type:"uint8"},{internalType:"contract IERC20Metadata",name:"sendingToken",type:"address"}],internalType:"struct DelayedSendingsQueueLib.DelayedSending[]",name:"",type:"tuple[]"}],stateMutability:"view",type:"function",returns:{_0:"A deque of sendings. (Or queue of sendings.)"},notice:"Returns full array of sendings queue."},"getSendingsDequeIndiciesStored()":{inputs:[],name:"getSendingsDequeIndiciesStored",outputs:[{internalType:"uint256[]",name:"",type:"uint256[]"}],stateMutability:"view",type:"function",notice:"Returns an array of IDs of the sendings, that are stored in public mapping.Array on indicies stored in the queue."},"getTotalSendingsPerStaker(address)":{inputs:[{internalType:"address",name:"staker",type:"address"}],name:"getTotalSendingsPerStaker",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",params:{staker:"A staker address to be search info for."},returns:{_0:"A sum of tokens that are going to eventuely go to the `staker`."},notice:"Returns sum of all sendings to be delivered to certain `staker`."}}},"contracts/diamonds/locusStaking/v2/manualWithdrawQueueFacets/libraries/DelayedSendingsQueueLib.sol:DelayedSendingsQueueLib":{source:"contracts/diamonds/locusStaking/v2/manualWithdrawQueueFacets/libraries/DelayedSendingsQueueLib.sol",name:"DelayedSendingsQueueLib",stateVariables:{"DELAYED_SENDINGS_QUEUE_PROCESSOR_ROLE()":{inputs:[],name:"DELAYED_SENDINGS_QUEUE_PROCESSOR_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"stateVariable",details:"Classic `AccessControl` role. Allowes the bearer to clear the deque of sendings."}}},"contracts/diamonds/locusToken/DiamondLocusToken.sol:DiamondLocusToken":{source:"contracts/diamonds/locusToken/DiamondLocusToken.sol",name:"DiamondLocusToken",details:"This MUST aggregate all of the faucets interfaces, to be able to grasp a full view of ABI in one place.",notice:'IMPORTANT: all of the collective diamond interfaces MUST be prefixed with "Diamond" word.',events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"SelectorUsageStatusSet(address,bytes4,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"entity",type:"address"},{indexed:!0,internalType:"bytes4",name:"selector",type:"bytes4"},{indexed:!0,internalType:"bool",name:"status",type:"bool"}],name:"SelectorUsageStatusSet",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}."},"addReceiver(address,uint256,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"},{internalType:"bool",name:"status",type:"bool"}],name:"addReceiver",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"A share that the receiver has to acquire.",status:"A status if the receiver is blocked (excluded from the distribution) or not."},notice:"Adds a receiver into a token (fee) distribution."},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"areAutocratsReign()":{inputs:[],name:"areAutocratsReign",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"burn(address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function"},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function"},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the decimals places of the token."},"defeatAutocracyForever()":{inputs:[],name:"defeatAutocracyForever",outputs:[],stateMutability:"nonpayable",type:"function"},"delegateTo(address)":{inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegateTo",outputs:[],stateMutability:"nonpayable",type:"function"},"distribute(uint256,address)":{inputs:[{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"contract IERC20",name:"token",type:"address"}],name:"distribute",outputs:[],stateMutability:"nonpayable",type:"function",params:{amount:"An amount of `token` to distribute.",token:"A token to distribute."},notice:"Performs distribution of any tokens that that is holding in the diamond according to tokens receivers their shares."},"enablePolitics()":{inputs:[],name:"enablePolitics",outputs:[],stateMutability:"nonpayable",type:"function",notice:"To be able to vote for something by themselves a holder must call it first to delegate all voting power they have to themselves."},"enforceAutocracyGovernmentDelegatee(address,bytes4)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes4",name:"selector",type:"bytes4"}],name:"enforceAutocracyGovernmentDelegatee",outputs:[],stateMutability:"view",type:"function"},"establishAutocracy()":{inputs:[],name:"establishAutocracy",outputs:[],stateMutability:"nonpayable",type:"function"},"getDelegatee(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getDelegatee",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPastVotingPower(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastVotingPower",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getReceiversByAddresses(uint256,uint256,address[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"address[]",name:"addresses",type:"address[]"}],name:"getReceiversByAddresses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{addresses:"A group of addresses to search for.",offset:"An amount of indicies to skip before the window scan.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their addresses."},"getReceiversByShares(uint256,uint256,uint256[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"uint256[]",name:"shares",type:"uint256[]"}],name:"getReceiversByShares",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",shares:"A group of share balances to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their shares."},"getReceiversByStatuses(uint256,uint256,bool[])":{inputs:[{internalType:"uint256",name:"offset",type:"uint256"},{internalType:"uint256",name:"windowSize",type:"uint256"},{internalType:"bool[]",name:"statuses",type:"bool[]"}],name:"getReceiversByStatuses",outputs:[{internalType:"uint256[]",name:"indicies",type:"uint256[]"}],stateMutability:"view",type:"function",params:{offset:"An amount of indicies to skip before the window scan.",statuses:"A group of statuses to search for.",windowSize:"A size of a window inside which the search would occur."},returns:{indicies:"A group of indicies at which the addresses are in the main array."},notice:"Returns indicies of token receivers in the main array based on their status (whether they're blocked or not)."},"getVotingPower(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getVotingPower",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"grantRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"grantRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"grantRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"grantRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Revokes from a group of entities a group of roles."},"hasRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"hasRole",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Checks if an entity has a role."},"initialize(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"An address who can end and rule autocracy, and mint inflation of LCS tokens."},notice:"An initializer function for Locus Token owner and starting state of the inflation."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"mintInflation()":{inputs:[],name:"mintInflation",outputs:[],stateMutability:"nonpayable",type:"function"},"mintTo(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mintTo",outputs:[],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"nonces(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the current nonce for `owner`. This value must be included whenever a signature is generated for {permit}. Every successful call to {permit} increases ``owner``'s nonce by one. This prevents a signature from being used multiple times."},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function",details:"Sets `value` as the allowance of `spender` over ``owner``'s tokens, given ``owner``'s signed approval. IMPORTANT: The same issues {IERC20-approve} has related to transaction ordering also apply here. Emits an {Approval} event. Requirements: - `spender` cannot be the zero address. - `deadline` must be a timestamp in the future. - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner` over the EIP712-formatted function arguments. - the signature must use ``owner``'s current nonce (see {nonces}). For more information on the signature format, see the https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP section]."},"revokeRole(address,bytes32)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes32",name:"role",type:"bytes32"}],name:"revokeRole",outputs:[],stateMutability:"nonpayable",type:"function",params:{role:"A role (OZ AccessControl like).",who:"An entity address."},notice:"Grants role to an entity."},"revokeRoles(address[],bytes32[])":{inputs:[{internalType:"address[]",name:"entities",type:"address[]"},{internalType:"bytes32[]",name:"roles",type:"bytes32[]"}],name:"revokeRoles",outputs:[],stateMutability:"nonpayable",type:"function",params:{entities:"The entities.",roles:"The roles."},notice:"Grants a group of roles (OZ AccessControl like) to a group of entities."},"setReceiverShare(address,uint256)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"uint256",name:"share",type:"uint256"}],name:"setReceiverShare",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",share:"New share to be set."},notice:"A tokens receivers share setter."},"setReceiverStatus(address,bool)":{inputs:[{internalType:"address",name:"feeReceiver",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setReceiverStatus",outputs:[],stateMutability:"nonpayable",type:"function",params:{feeReceiver:"A receiver entity address.",status:"New status to be set."},notice:"A tokens receivers status setter. If status is True - the address does not receive any distribution parts. Otherwise, it does."},"setStatusOfMintingBurningSelectorsFor(address,bool)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setStatusOfMintingBurningSelectorsFor",outputs:[],stateMutability:"nonpayable",type:"function"},"setStatusOfSelectorUsageTo(address,bytes4,bool)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes4",name:"selector",type:"bytes4"},{internalType:"bool",name:"status",type:"bool"}],name:"setStatusOfSelectorUsageTo",outputs:[],stateMutability:"nonpayable",type:"function"},"setupInflation(address[],uint256[],uint32[],uint256[][])":{inputs:[{internalType:"address[]",name:"distributionReceivers",type:"address[]"},{internalType:"uint256[]",name:"distributionReceiversShares",type:"uint256[]"},{internalType:"uint32[]",name:"distributionDurationPoints",type:"uint32[]"},{internalType:"uint256[][]",name:"amountsPerEpochs",type:"uint256[][]"}],name:"setupInflation",outputs:[],stateMutability:"nonpayable",type:"function",params:{amountsPerEpochs:"An amount of Locus Tokens to be minted per epoch.",distributionDurationPoints:"Durations from the start of inflation.  (If time between epochs is constant, like month for example, then all of the values would be equal to month is seconds.)",distributionReceivers:"Addresses of receivers (ex. Locus Staking or Vault Token Staking contracts.)",distributionReceiversShares:"Shares of addresses of `distributionReceivers`."},notice:"A setter function for Locus Token inflation receivers."},"setupTokenInfo()":{inputs:[],name:"setupTokenInfo",outputs:[],stateMutability:"nonpayable",type:"function"},"setupTokenInfoAndEstablishAutocracy()":{inputs:[],name:"setupTokenInfoAndEstablishAutocracy",outputs:[],stateMutability:"nonpayable",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/diamonds/locusToken/LTLib.sol:LTLib":{source:"contracts/diamonds/locusToken/LTLib.sol",name:"LTLib",events:{"EpochAmountIsEmptyOrInflationHasntStarted()":{anonymous:!1,inputs:[],name:"EpochAmountIsEmptyOrInflationHasntStarted",type:"event"}},methods:{"ALLOWANCE_FREE_ROLE()":{inputs:[],name:"ALLOWANCE_FREE_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"INITIAL_SUPPLY()":{inputs:[],name:"INITIAL_SUPPLY",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"originalName()":{inputs:[],name:"originalName",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"originalSymbol()":{inputs:[],name:"originalSymbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"}}},"contracts/diamonds/locusToken/v1/LTERC20Facet.sol:LTERC20Facet":{source:"contracts/diamonds/locusToken/v1/LTERC20Facet.sol",name:"LTERC20Facet",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"DelegateChanged(address,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"delegator",type:"address"},{indexed:!0,internalType:"address",name:"fromDelegate",type:"address"},{indexed:!0,internalType:"address",name:"toDelegate",type:"address"}],name:"DelegateChanged",type:"event",details:"Emitted when an account changes their delegate."},"DelegateVotesChanged(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"delegate",type:"address"},{indexed:!1,internalType:"uint256",name:"previousBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newBalance",type:"uint256"}],name:"DelegateVotesChanged",type:"event",details:"Emitted when a token transfer or delegate change results in changes to a delegate's number of votes."},"EIP712DomainChanged()":{anonymous:!1,inputs:[],name:"EIP712DomainChanged",type:"event",details:"MAY be emitted to signal that the domain could have changed."},"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"CLOCK_MODE()":{inputs:[],name:"CLOCK_MODE",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Description of the clock"},"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"See {IERC20Permit-DOMAIN_SEPARATOR}."},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function"},"cap()":{inputs:[],name:"cap",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the cap on the token's total supply."},"checkpoints(address,uint32)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint32",name:"pos",type:"uint32"}],name:"checkpoints",outputs:[{components:[{internalType:"uint32",name:"fromBlock",type:"uint32"},{internalType:"uint224",name:"votes",type:"uint224"}],internalType:"struct ERC20VotesUpgradeable.Checkpoint",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Get the `pos`-th checkpoint for `account`."},"clock()":{inputs:[],name:"clock",outputs:[{internalType:"uint48",name:"",type:"uint48"}],stateMutability:"view",type:"function",details:"Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting)."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"delegate(address)":{inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegate",outputs:[],stateMutability:"nonpayable",type:"function",details:"Delegate votes from the sender to `delegatee`."},"delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"delegatee",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"delegateBySig",outputs:[],stateMutability:"nonpayable",type:"function",details:"Delegates votes from signer to `delegatee`"},"delegateTo(address)":{inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegateTo",outputs:[],stateMutability:"nonpayable",type:"function"},"delegates(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"delegates",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Get the address `account` is currently delegating to."},"eip712Domain()":{inputs:[],name:"eip712Domain",outputs:[{internalType:"bytes1",name:"fields",type:"bytes1"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"version",type:"string"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"verifyingContract",type:"address"},{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256[]",name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function",details:"See {EIP-5267}. _Available since v4.9._"},"enablePolitics()":{inputs:[],name:"enablePolitics",outputs:[],stateMutability:"nonpayable",type:"function",notice:"To be able to vote for something by themselves a holder must call it first to delegate all voting power they have to themselves."},"getDelegatee(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getDelegatee",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPastTotalSupply(uint256)":{inputs:[{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastTotalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances. It is NOT the sum of all the delegated votes! Requirements: - `timepoint` must be in the past"},"getPastVotes(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Retrieve the number of votes for `account` at the end of `timepoint`. Requirements: - `timepoint` must be in the past"},"getPastVotingPower(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastVotingPower",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVotes(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Gets the current votes balance for `account`"},"getVotingPower(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getVotingPower",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mintTo(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mintTo",outputs:[],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"nonces(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20Permit-nonces}."},"numCheckpoints(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"numCheckpoints",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",details:"Get number of checkpoints for `account`."},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC20Permit-permit}."},"setupTokenInfo()":{inputs:[],name:"setupTokenInfo",outputs:[],stateMutability:"nonpayable",type:"function"},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."}}},"contracts/diamonds/locusToken/v1/LTEmissionControlFacet.sol:LTEmissionControlFacet":{source:"contracts/diamonds/locusToken/v1/LTEmissionControlFacet.sol",name:"LTEmissionControlFacet",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"mintInflation()":{inputs:[],name:"mintInflation",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/diamonds/locusToken/v1/LTInitializerFacet.sol:LTInitializerFacet":{source:"contracts/diamonds/locusToken/v1/LTInitializerFacet.sol",name:"LTInitializerFacet",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"initialize(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"An address who can end and rule autocracy, and mint inflation of LCS tokens."},notice:"An initializer function for Locus Token owner and starting state of the inflation."},"setupInflation(address[],uint256[],uint32[],uint256[][])":{inputs:[{internalType:"address[]",name:"distributionReceivers",type:"address[]"},{internalType:"uint256[]",name:"distributionReceiversShares",type:"uint256[]"},{internalType:"uint32[]",name:"distributionDurationPoints",type:"uint32[]"},{internalType:"uint256[][]",name:"amountsPerEpochs",type:"uint256[][]"}],name:"setupInflation",outputs:[],stateMutability:"nonpayable",type:"function",params:{amountsPerEpochs:"An amount of Locus Tokens to be minted per epoch.",distributionDurationPoints:"Durations from the start of inflation.  (If time between epochs is constant, like month for example, then all of the values would be equal to month is seconds.)",distributionReceivers:"Addresses of receivers (ex. Locus Staking or Vault Token Staking contracts.)",distributionReceiversShares:"Shares of addresses of `distributionReceivers`."},notice:"A setter function for Locus Token inflation receivers."},"setupTokenInfoAndEstablishAutocracy()":{inputs:[],name:"setupTokenInfoAndEstablishAutocracy",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/diamonds/locusToken/v1/autocracy/LTAutocracyFacet.sol:LTAutocracyFacet":{source:"contracts/diamonds/locusToken/v1/autocracy/LTAutocracyFacet.sol",name:"LTAutocracyFacet",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."}},methods:{"areAutocratsReign()":{inputs:[],name:"areAutocratsReign",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"burn(address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function"},"defeatAutocracyForever()":{inputs:[],name:"defeatAutocracyForever",outputs:[],stateMutability:"nonpayable",type:"function"},"establishAutocracy()":{inputs:[],name:"establishAutocracy",outputs:[],stateMutability:"nonpayable",type:"function"},"mint(address,uint256)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/diamonds/locusToken/v1/autocracy/LTAutocracyGovernmentFacet.sol:LTAutocracyGovernmentFacet":{source:"contracts/diamonds/locusToken/v1/autocracy/LTAutocracyGovernmentFacet.sol",name:"LTAutocracyGovernmentFacet",events:{"Initialized(uint8)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint8",name:"version",type:"uint8"}],name:"Initialized",type:"event",details:"Triggered when the contract has been initialized or reinitialized."},"SelectorUsageStatusSet(address,bytes4,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"entity",type:"address"},{indexed:!0,internalType:"bytes4",name:"selector",type:"bytes4"},{indexed:!0,internalType:"bool",name:"status",type:"bool"}],name:"SelectorUsageStatusSet",type:"event"}},methods:{"enforceAutocracyGovernmentDelegatee(address,bytes4)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes4",name:"selector",type:"bytes4"}],name:"enforceAutocracyGovernmentDelegatee",outputs:[],stateMutability:"view",type:"function"},"setStatusOfMintingBurningSelectorsFor(address,bool)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setStatusOfMintingBurningSelectorsFor",outputs:[],stateMutability:"nonpayable",type:"function"},"setStatusOfSelectorUsageTo(address,bytes4,bool)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes4",name:"selector",type:"bytes4"},{internalType:"bool",name:"status",type:"bool"}],name:"setStatusOfSelectorUsageTo",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/diamonds/locusToken/v1/autocracy/interfaces/ILTAutocracyFacet.sol:ILTAutocracyFacet":{source:"contracts/diamonds/locusToken/v1/autocracy/interfaces/ILTAutocracyFacet.sol",name:"ILTAutocracyFacet",methods:{"areAutocratsReign()":{inputs:[],name:"areAutocratsReign",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function"},"burn(address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burn",outputs:[],stateMutability:"nonpayable",type:"function"},"defeatAutocracyForever()":{inputs:[],name:"defeatAutocracyForever",outputs:[],stateMutability:"nonpayable",type:"function"},"establishAutocracy()":{inputs:[],name:"establishAutocracy",outputs:[],stateMutability:"nonpayable",type:"function"},"mint(address,uint256)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/diamonds/locusToken/v1/autocracy/interfaces/ILTAutocracyGovernmentFacet.sol:ILTAutocracyGovernmentFacet":{source:"contracts/diamonds/locusToken/v1/autocracy/interfaces/ILTAutocracyGovernmentFacet.sol",name:"ILTAutocracyGovernmentFacet",events:{"SelectorUsageStatusSet(address,bytes4,bool)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"entity",type:"address"},{indexed:!0,internalType:"bytes4",name:"selector",type:"bytes4"},{indexed:!0,internalType:"bool",name:"status",type:"bool"}],name:"SelectorUsageStatusSet",type:"event"}},methods:{"enforceAutocracyGovernmentDelegatee(address,bytes4)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes4",name:"selector",type:"bytes4"}],name:"enforceAutocracyGovernmentDelegatee",outputs:[],stateMutability:"view",type:"function"},"setStatusOfMintingBurningSelectorsFor(address,bool)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bool",name:"status",type:"bool"}],name:"setStatusOfMintingBurningSelectorsFor",outputs:[],stateMutability:"nonpayable",type:"function"},"setStatusOfSelectorUsageTo(address,bytes4,bool)":{inputs:[{internalType:"address",name:"who",type:"address"},{internalType:"bytes4",name:"selector",type:"bytes4"},{internalType:"bool",name:"status",type:"bool"}],name:"setStatusOfSelectorUsageTo",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/diamonds/locusToken/v1/autocracy/libraries/AutocracyGovernmentLib.sol:AutocracyGovernmentLib":{source:"contracts/diamonds/locusToken/v1/autocracy/libraries/AutocracyGovernmentLib.sol",name:"AutocracyGovernmentLib"},"contracts/diamonds/locusToken/v1/autocracy/libraries/AutocracyLib.sol:AutocracyLib":{source:"contracts/diamonds/locusToken/v1/autocracy/libraries/AutocracyLib.sol",name:"AutocracyLib",methods:{"AUTOCRAT_ROLE()":{inputs:[],name:"AUTOCRAT_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"REVOLUTIONARY_ROLE()":{inputs:[],name:"REVOLUTIONARY_ROLE",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"}}},"contracts/diamonds/locusToken/v1/interfaces/ILTERC20Facet.sol:ILTERC20Facet":{source:"contracts/diamonds/locusToken/v1/interfaces/ILTERC20Facet.sol",name:"ILTERC20Facet",methods:{"burnFrom(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"burnFrom",outputs:[],stateMutability:"nonpayable",type:"function"},"delegateTo(address)":{inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegateTo",outputs:[],stateMutability:"nonpayable",type:"function"},"enablePolitics()":{inputs:[],name:"enablePolitics",outputs:[],stateMutability:"nonpayable",type:"function",notice:"To be able to vote for something by themselves a holder must call it first to delegate all voting power they have to themselves."},"getDelegatee(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getDelegatee",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"getPastVotingPower(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastVotingPower",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"getVotingPower(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getVotingPower",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"mintTo(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mintTo",outputs:[],stateMutability:"nonpayable",type:"function"},"setupTokenInfo()":{inputs:[],name:"setupTokenInfo",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/diamonds/locusToken/v1/interfaces/ILTEmissionControlFacet.sol:ILTEmissionControlFacet":{source:"contracts/diamonds/locusToken/v1/interfaces/ILTEmissionControlFacet.sol",name:"ILTEmissionControlFacet",methods:{"mintInflation()":{inputs:[],name:"mintInflation",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/diamonds/locusToken/v1/interfaces/ILTInitializerFacet.sol:ILTInitializerFacet":{source:"contracts/diamonds/locusToken/v1/interfaces/ILTInitializerFacet.sol",name:"ILTInitializerFacet",methods:{"initialize(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"initialize",outputs:[],stateMutability:"nonpayable",type:"function",params:{owner:"An address who can end and rule autocracy, and mint inflation of LCS tokens."},notice:"An initializer function for Locus Token owner and starting state of the inflation."},"setupInflation(address[],uint256[],uint32[],uint256[][])":{inputs:[{internalType:"address[]",name:"distributionReceivers",type:"address[]"},{internalType:"uint256[]",name:"distributionReceiversShares",type:"uint256[]"},{internalType:"uint32[]",name:"distributionDurationPoints",type:"uint32[]"},{internalType:"uint256[][]",name:"amountsPerEpochs",type:"uint256[][]"}],name:"setupInflation",outputs:[],stateMutability:"nonpayable",type:"function",params:{amountsPerEpochs:"An amount of Locus Tokens to be minted per epoch.",distributionDurationPoints:"Durations from the start of inflation.  (If time between epochs is constant, like month for example, then all of the values would be equal to month is seconds.)",distributionReceivers:"Addresses of receivers (ex. Locus Staking or Vault Token Staking contracts.)",distributionReceiversShares:"Shares of addresses of `distributionReceivers`."},notice:"A setter function for Locus Token inflation receivers."},"setupTokenInfoAndEstablishAutocracy()":{inputs:[],name:"setupTokenInfoAndEstablishAutocracy",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/notDiamonds/LocusGovernor.sol:LocusGovernor":{source:"contracts/notDiamonds/LocusGovernor.sol",name:"LocusGovernor",constructor:{inputs:[{internalType:"address",name:"wrappedStakingLocus",type:"address"},{internalType:"uint48",name:"initialVotingDelay",type:"uint48"},{internalType:"uint32",name:"initialVotingPeriod",type:"uint32"},{internalType:"uint256",name:"initialProposalThresholdInLocusTokens",type:"uint256"},{internalType:"uint256",name:"quorumFractionInPercents",type:"uint256"},{internalType:"string",name:"governorName",type:"string"}],stateMutability:"nonpayable",type:"constructor"},receive:{stateMutability:"payable",type:"receive"},events:{"EIP712DomainChanged()":{anonymous:!1,inputs:[],name:"EIP712DomainChanged",type:"event",details:"MAY be emitted to signal that the domain could have changed."},"ProposalCanceled(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"proposalId",type:"uint256"}],name:"ProposalCanceled",type:"event",details:"Emitted when a proposal is canceled."},"ProposalCreated(uint256,address,address[],uint256[],string[],bytes[],uint256,uint256,string)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"proposalId",type:"uint256"},{indexed:!1,internalType:"address",name:"proposer",type:"address"},{indexed:!1,internalType:"address[]",name:"targets",type:"address[]"},{indexed:!1,internalType:"uint256[]",name:"values",type:"uint256[]"},{indexed:!1,internalType:"string[]",name:"signatures",type:"string[]"},{indexed:!1,internalType:"bytes[]",name:"calldatas",type:"bytes[]"},{indexed:!1,internalType:"uint256",name:"voteStart",type:"uint256"},{indexed:!1,internalType:"uint256",name:"voteEnd",type:"uint256"},{indexed:!1,internalType:"string",name:"description",type:"string"}],name:"ProposalCreated",type:"event",details:"Emitted when a proposal is created."},"ProposalExecuted(uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"proposalId",type:"uint256"}],name:"ProposalExecuted",type:"event",details:"Emitted when a proposal is executed."},"ProposalThresholdSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldProposalThreshold",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newProposalThreshold",type:"uint256"}],name:"ProposalThresholdSet",type:"event"},"QuorumNumeratorUpdated(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldQuorumNumerator",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newQuorumNumerator",type:"uint256"}],name:"QuorumNumeratorUpdated",type:"event"},"VoteCast(address,uint256,uint8,uint256,string)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"voter",type:"address"},{indexed:!1,internalType:"uint256",name:"proposalId",type:"uint256"},{indexed:!1,internalType:"uint8",name:"support",type:"uint8"},{indexed:!1,internalType:"uint256",name:"weight",type:"uint256"},{indexed:!1,internalType:"string",name:"reason",type:"string"}],name:"VoteCast",type:"event",details:"Emitted when a vote is cast without params. Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used."},"VoteCastWithParams(address,uint256,uint8,uint256,string,bytes)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"voter",type:"address"},{indexed:!1,internalType:"uint256",name:"proposalId",type:"uint256"},{indexed:!1,internalType:"uint8",name:"support",type:"uint8"},{indexed:!1,internalType:"uint256",name:"weight",type:"uint256"},{indexed:!1,internalType:"string",name:"reason",type:"string"},{indexed:!1,internalType:"bytes",name:"params",type:"bytes"}],name:"VoteCastWithParams",type:"event",details:"Emitted when a vote is cast with params. Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used. `params` are additional encoded parameters. Their interpepretation also depends on the voting module used."},"VotingDelaySet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldVotingDelay",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newVotingDelay",type:"uint256"}],name:"VotingDelaySet",type:"event"},"VotingPeriodSet(uint256,uint256)":{anonymous:!1,inputs:[{indexed:!1,internalType:"uint256",name:"oldVotingPeriod",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newVotingPeriod",type:"uint256"}],name:"VotingPeriodSet",type:"event"}},methods:{"BALLOT_TYPEHASH()":{inputs:[],name:"BALLOT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"CLOCK_MODE()":{inputs:[],name:"CLOCK_MODE",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Machine-readable description of the clock as specified in EIP-6372."},"COUNTING_MODE()":{inputs:[],name:"COUNTING_MODE",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"pure",type:"function",details:"See {IGovernor-COUNTING_MODE}."},"EXTENDED_BALLOT_TYPEHASH()":{inputs:[],name:"EXTENDED_BALLOT_TYPEHASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"cancel(address[],uint256[],bytes[],bytes32)":{inputs:[{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"calldatas",type:"bytes[]"},{internalType:"bytes32",name:"descriptionHash",type:"bytes32"}],name:"cancel",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"See {IGovernor-cancel}."},"castVote(uint256,uint8)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"},{internalType:"uint8",name:"support",type:"uint8"}],name:"castVote",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"See {IGovernor-castVote}."},"castVoteBySig(uint256,uint8,uint8,bytes32,bytes32)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"castVoteBySig",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"See {IGovernor-castVoteBySig}."},"castVoteWithReason(uint256,uint8,string)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"string",name:"reason",type:"string"}],name:"castVoteWithReason",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"See {IGovernor-castVoteWithReason}."},"castVoteWithReasonAndParams(uint256,uint8,string,bytes)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"string",name:"reason",type:"string"},{internalType:"bytes",name:"params",type:"bytes"}],name:"castVoteWithReasonAndParams",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"See {IGovernor-castVoteWithReasonAndParams}."},"castVoteWithReasonAndParamsBySig(uint256,uint8,string,bytes,uint8,bytes32,bytes32)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"},{internalType:"uint8",name:"support",type:"uint8"},{internalType:"string",name:"reason",type:"string"},{internalType:"bytes",name:"params",type:"bytes"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"castVoteWithReasonAndParamsBySig",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"See {IGovernor-castVoteWithReasonAndParamsBySig}."},"clock()":{inputs:[],name:"clock",outputs:[{internalType:"uint48",name:"",type:"uint48"}],stateMutability:"view",type:"function",details:"Clock (as specified in EIP-6372) is set to match the token's clock. Fallback to block numbers if the token does not implement EIP-6372."},"eip712Domain()":{inputs:[],name:"eip712Domain",outputs:[{internalType:"bytes1",name:"fields",type:"bytes1"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"version",type:"string"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"verifyingContract",type:"address"},{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256[]",name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function",details:"See {EIP-5267}. _Available since v4.9._"},"execute(address[],uint256[],bytes[],bytes32)":{inputs:[{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"calldatas",type:"bytes[]"},{internalType:"bytes32",name:"descriptionHash",type:"bytes32"}],name:"execute",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"payable",type:"function",details:"See {IGovernor-execute}."},"getVotes(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IGovernor-getVotes}."},"getVotesWithParams(address,uint256,bytes)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"},{internalType:"bytes",name:"params",type:"bytes"}],name:"getVotesWithParams",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IGovernor-getVotesWithParams}."},"hasVoted(uint256,address)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"},{internalType:"address",name:"account",type:"address"}],name:"hasVoted",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IGovernor-hasVoted}."},"hashProposal(address[],uint256[],bytes[],bytes32)":{inputs:[{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"calldatas",type:"bytes[]"},{internalType:"bytes32",name:"descriptionHash",type:"bytes32"}],name:"hashProposal",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"pure",type:"function",details:"See {IGovernor-hashProposal}. The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in advance, before the proposal is submitted. Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the same proposal (with same operation and same description) will have the same id if submitted on multiple governors across multiple networks. This also means that in order to execute the same operation twice (on the same governor) the proposer will have to change the description in order to avoid proposal id conflicts."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IGovernor-name}."},"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"uint256[]",name:"",type:"uint256[]"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155BatchReceived",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC1155Receiver-onERC1155BatchReceived}."},"onERC1155Received(address,address,uint256,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC1155Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC1155Receiver-onERC1155Received}."},"onERC721Received(address,address,uint256,bytes)":{inputs:[{internalType:"address",name:"",type:"address"},{internalType:"address",name:"",type:"address"},{internalType:"uint256",name:"",type:"uint256"},{internalType:"bytes",name:"",type:"bytes"}],name:"onERC721Received",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"nonpayable",type:"function",details:"See {IERC721Receiver-onERC721Received}."},"proposalDeadline(uint256)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"}],name:"proposalDeadline",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IGovernor-proposalDeadline}."},"proposalProposer(uint256)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"}],name:"proposalProposer",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the account that created a given proposal."},"proposalSnapshot(uint256)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"}],name:"proposalSnapshot",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IGovernor-proposalSnapshot}."},"proposalThreshold()":{inputs:[],name:"proposalThreshold",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"proposalVotes(uint256)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"}],name:"proposalVotes",outputs:[{internalType:"uint256",name:"againstVotes",type:"uint256"},{internalType:"uint256",name:"forVotes",type:"uint256"},{internalType:"uint256",name:"abstainVotes",type:"uint256"}],stateMutability:"view",type:"function",details:"Accessor to the internal vote counts."},"propose(address[],uint256[],bytes[],string)":{inputs:[{internalType:"address[]",name:"targets",type:"address[]"},{internalType:"uint256[]",name:"values",type:"uint256[]"},{internalType:"bytes[]",name:"calldatas",type:"bytes[]"},{internalType:"string",name:"description",type:"string"}],name:"propose",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"See {IGovernor-propose}. This function has opt-in frontrunning protection, described in {_isValidDescriptionForProposer}."},"quorum(uint256)":{inputs:[{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"quorum",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the quorum for a timepoint, in terms of number of votes: `supply * numerator / denominator`."},"quorumDenominator()":{inputs:[],name:"quorumDenominator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the quorum denominator. Defaults to 100, but may be overridden."},"quorumNumerator(uint256)":{inputs:[{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"quorumNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the quorum numerator at a specific timepoint. See {quorumDenominator}."},"quorumNumerator()":{inputs:[],name:"quorumNumerator",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the current quorum numerator. See {quorumDenominator}."},"relay(address,uint256,bytes)":{inputs:[{internalType:"address",name:"target",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"bytes",name:"data",type:"bytes"}],name:"relay",outputs:[],stateMutability:"payable",type:"function",details:"Relays a transaction or function call to an arbitrary target. In cases where the governance executor is some contract other than the governor itself, like when using a timelock, this function can be invoked in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake. Note that if the executor is simply the governor itself, use of `relay` is redundant."},"setProposalThreshold(uint256)":{inputs:[{internalType:"uint256",name:"newProposalThreshold",type:"uint256"}],name:"setProposalThreshold",outputs:[],stateMutability:"nonpayable",type:"function",details:"Update the proposal threshold. This operation can only be performed through a governance proposal. Emits a {ProposalThresholdSet} event."},"setVotingDelay(uint256)":{inputs:[{internalType:"uint256",name:"newVotingDelay",type:"uint256"}],name:"setVotingDelay",outputs:[],stateMutability:"nonpayable",type:"function",details:"Update the voting delay. This operation can only be performed through a governance proposal. Emits a {VotingDelaySet} event."},"setVotingPeriod(uint256)":{inputs:[{internalType:"uint256",name:"newVotingPeriod",type:"uint256"}],name:"setVotingPeriod",outputs:[],stateMutability:"nonpayable",type:"function",details:"Update the voting period. This operation can only be performed through a governance proposal. Emits a {VotingPeriodSet} event."},"state(uint256)":{inputs:[{internalType:"uint256",name:"proposalId",type:"uint256"}],name:"state",outputs:[{internalType:"enum IGovernor.ProposalState",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"See {IGovernor-state}."},"supportsInterface(bytes4)":{inputs:[{internalType:"bytes4",name:"interfaceId",type:"bytes4"}],name:"supportsInterface",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"view",type:"function",details:"See {IERC165-supportsInterface}."},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IERC5805",name:"",type:"address"}],stateMutability:"view",type:"function"},"updateQuorumNumerator(uint256)":{inputs:[{internalType:"uint256",name:"newQuorumNumerator",type:"uint256"}],name:"updateQuorumNumerator",outputs:[],stateMutability:"nonpayable",type:"function",details:"Changes the quorum numerator. Emits a {QuorumNumeratorUpdated} event. Requirements: - Must be called through a governance proposal. - New numerator must be smaller or equal to the denominator."},"version()":{inputs:[],name:"version",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"See {IGovernor-version}."},"votingDelay()":{inputs:[],name:"votingDelay",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IGovernor-votingDelay}."},"votingPeriod()":{inputs:[],name:"votingPeriod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IGovernor-votingPeriod}."}}},"contracts/notDiamonds/MidasClaim.sol:MidasClaim":{source:"contracts/notDiamonds/MidasClaim.sol",name:"MidasClaim",constructor:{inputs:[{internalType:"address",name:"_token",type:"address"},{internalType:"address",name:"_stLocus",type:"address"},{internalType:"bytes32",name:"_merkleRoot",type:"bytes32"},{internalType:"address",name:"_treasury",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"EmergencyExitCalled()":{anonymous:!1,inputs:[],name:"EmergencyExitCalled",type:"event"},"MerkleRootChanged(bytes32,bytes32)":{anonymous:!1,inputs:[{indexed:!0,internalType:"bytes32",name:"oldRoot",type:"bytes32"},{indexed:!0,internalType:"bytes32",name:"newRoot",type:"bytes32"}],name:"MerkleRootChanged",type:"event"},"NewClaimingTokenSet(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldToken",type:"address"},{indexed:!0,internalType:"address",name:"newToken",type:"address"}],name:"NewClaimingTokenSet",type:"event"},"NewTreasurySet(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"oldToken",type:"address"},{indexed:!0,internalType:"address",name:"newToken",type:"address"}],name:"NewTreasurySet",type:"event"},"OwnershipTransferred(address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"previousOwner",type:"address"},{indexed:!0,internalType:"address",name:"newOwner",type:"address"}],name:"OwnershipTransferred",type:"event"}},methods:{"claim(address,uint256,bytes32[])":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"},{internalType:"bytes32[]",name:"merkleProof",type:"bytes32[]"}],name:"claim",outputs:[],stateMutability:"nonpayable",type:"function"},"claimed(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"claimed",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"emergencyExit()":{inputs:[],name:"emergencyExit",outputs:[],stateMutability:"nonpayable",type:"function"},"merkleRoot()":{inputs:[],name:"merkleRoot",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"owner()":{inputs:[],name:"owner",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Returns the address of the current owner."},"renounceOwnership()":{inputs:[],name:"renounceOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Leaves the contract without owner. It will not be possible to call `onlyOwner` functions. Can only be called by the current owner. NOTE: Renouncing ownership will leave the contract without an owner, thereby disabling any functionality that is only available to the owner."},"setNewMerkleRoot(bytes32)":{inputs:[{internalType:"bytes32",name:"_newRoot",type:"bytes32"}],name:"setNewMerkleRoot",outputs:[],stateMutability:"nonpayable",type:"function"},"setNewToken(address)":{inputs:[{internalType:"address",name:"_newToken",type:"address"}],name:"setNewToken",outputs:[],stateMutability:"nonpayable",type:"function"},"setNewTreasury(address)":{inputs:[{internalType:"address",name:"_newTreasury",type:"address"}],name:"setNewTreasury",outputs:[],stateMutability:"nonpayable",type:"function"},"stLocus()":{inputs:[],name:"stLocus",outputs:[{internalType:"contract ILSDepositaryFacet",name:"",type:"address"}],stateMutability:"view",type:"function"},"token()":{inputs:[],name:"token",outputs:[{internalType:"contract IERC20",name:"",type:"address"}],stateMutability:"view",type:"function"},"transferOwnership(address)":{inputs:[{internalType:"address",name:"newOwner",type:"address"}],name:"transferOwnership",outputs:[],stateMutability:"nonpayable",type:"function",details:"Transfers ownership of the contract to a new account (`newOwner`). Can only be called by the current owner."},"treasury()":{inputs:[],name:"treasury",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"}}},"contracts/notDiamonds/WrappedStakingLocus.sol:WrappedStakingLocus":{source:"contracts/notDiamonds/WrappedStakingLocus.sol",name:"WrappedStakingLocus",constructor:{inputs:[{internalType:"contract ILSLoupeFacet",name:"_locusStakingDiamond",type:"address"},{internalType:"contract IERC20Metadata",name:"_locusDiamond",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"DelegateChanged(address,address,address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"delegator",type:"address"},{indexed:!0,internalType:"address",name:"fromDelegate",type:"address"},{indexed:!0,internalType:"address",name:"toDelegate",type:"address"}],name:"DelegateChanged",type:"event",details:"Emitted when an account changes their delegate."},"DelegateVotesChanged(address,uint256,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"delegate",type:"address"},{indexed:!1,internalType:"uint256",name:"previousBalance",type:"uint256"},{indexed:!1,internalType:"uint256",name:"newBalance",type:"uint256"}],name:"DelegateVotesChanged",type:"event",details:"Emitted when a token transfer or delegate change results in changes to a delegate's number of votes."},"EIP712DomainChanged()":{anonymous:!1,inputs:[],name:"EIP712DomainChanged",type:"event",details:"MAY be emitted to signal that the domain could have changed."},"PoliticsDisabled(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"who",type:"address"}],name:"PoliticsDisabled",type:"event"},"PoliticsEnabled(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"who",type:"address"}],name:"PoliticsEnabled",type:"event"},"PoliticsRemainedUnchanged(address)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"who",type:"address"}],name:"PoliticsRemainedUnchanged",type:"event"},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"CLOCK_MODE()":{inputs:[],name:"CLOCK_MODE",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Description of the clock"},"DOMAIN_SEPARATOR()":{inputs:[],name:"DOMAIN_SEPARATOR",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function",details:"See {IERC20Permit-DOMAIN_SEPARATOR}."},"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"checkpoints(address,uint32)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint32",name:"pos",type:"uint32"}],name:"checkpoints",outputs:[{components:[{internalType:"uint32",name:"fromBlock",type:"uint32"},{internalType:"uint224",name:"votes",type:"uint224"}],internalType:"struct ERC20Votes.Checkpoint",name:"",type:"tuple"}],stateMutability:"view",type:"function",details:"Get the `pos`-th checkpoint for `account`."},"clock()":{inputs:[],name:"clock",outputs:[{internalType:"uint48",name:"",type:"uint48"}],stateMutability:"view",type:"function",details:"Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting)."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function"},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"delegate(address)":{inputs:[{internalType:"address",name:"delegatee",type:"address"}],name:"delegate",outputs:[],stateMutability:"nonpayable",type:"function",details:"Delegate votes from the sender to `delegatee`."},"delegateBySig(address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"delegatee",type:"address"},{internalType:"uint256",name:"nonce",type:"uint256"},{internalType:"uint256",name:"expiry",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"delegateBySig",outputs:[],stateMutability:"nonpayable",type:"function",details:"Delegates votes from signer to `delegatee`"},"delegates(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"delegates",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function",details:"Get the address `account` is currently delegating to."},"eip712Domain()":{inputs:[],name:"eip712Domain",outputs:[{internalType:"bytes1",name:"fields",type:"bytes1"},{internalType:"string",name:"name",type:"string"},{internalType:"string",name:"version",type:"string"},{internalType:"uint256",name:"chainId",type:"uint256"},{internalType:"address",name:"verifyingContract",type:"address"},{internalType:"bytes32",name:"salt",type:"bytes32"},{internalType:"uint256[]",name:"extensions",type:"uint256[]"}],stateMutability:"view",type:"function",details:"See {EIP-5267}. _Available since v4.9._"},"getPastTotalSupply(uint256)":{inputs:[{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastTotalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Retrieve the `totalSupply` at the end of `timepoint`. Note, this value is the sum of all balances. It is NOT the sum of all the delegated votes! Requirements: - `timepoint` must be in the past"},"getPastVotes(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"timepoint",type:"uint256"}],name:"getPastVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Retrieve the number of votes for `account` at the end of `timepoint`. Requirements: - `timepoint` must be in the past"},"getVotes(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"getVotes",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Gets the current votes balance for `account`"},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"locusDiamond()":{inputs:[],name:"locusDiamond",outputs:[{internalType:"contract IERC20Metadata",name:"",type:"address"}],stateMutability:"view",type:"function"},"locusStakingDiamond()":{inputs:[],name:"locusStakingDiamond",outputs:[{internalType:"contract ILSLoupeFacet",name:"",type:"address"}],stateMutability:"view",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"nonces(address)":{inputs:[{internalType:"address",name:"owner",type:"address"}],name:"nonces",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20Permit-nonces}."},"numCheckpoints(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"numCheckpoints",outputs:[{internalType:"uint32",name:"",type:"uint32"}],stateMutability:"view",type:"function",details:"Get number of checkpoints for `account`."},"permit(address,address,uint256,uint256,uint8,bytes32,bytes32)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"value",type:"uint256"},{internalType:"uint256",name:"deadline",type:"uint256"},{internalType:"uint8",name:"v",type:"uint8"},{internalType:"bytes32",name:"r",type:"bytes32"},{internalType:"bytes32",name:"s",type:"bytes32"}],name:"permit",outputs:[],stateMutability:"nonpayable",type:"function",details:"See {IERC20Permit-permit}."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function"},"syncBalanceOnStake(address)":{inputs:[{internalType:"address",name:"who",type:"address"}],name:"syncBalanceOnStake",outputs:[],stateMutability:"nonpayable",type:"function"},"syncBalanceOnWithdraw(address)":{inputs:[{internalType:"address",name:"who",type:"address"}],name:"syncBalanceOnWithdraw",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."}}},"contracts/notDiamonds/interfaces/IMockContract.sol:IMockContract":{source:"contracts/notDiamonds/interfaces/IMockContract.sol",name:"IMockContract",methods:{"givenAnyReturn(bytes)":{inputs:[{internalType:"bytes",name:"response",type:"bytes"}],name:"givenAnyReturn",outputs:[],stateMutability:"nonpayable",type:"function",details:"After calling this method, the mock will return `response` when it is called with any calldata that is not mocked more specifically below (e.g. using givenMethodReturn).",params:{response:"ABI encoded response that will be returned if method is invoked"}},"givenAnyReturnAddress(address)":{inputs:[{internalType:"address",name:"response",type:"address"}],name:"givenAnyReturnAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"givenAnyReturnBool(bool)":{inputs:[{internalType:"bool",name:"response",type:"bool"}],name:"givenAnyReturnBool",outputs:[],stateMutability:"nonpayable",type:"function"},"givenAnyReturnUint(uint256)":{inputs:[{internalType:"uint256",name:"response",type:"uint256"}],name:"givenAnyReturnUint",outputs:[],stateMutability:"nonpayable",type:"function"},"givenAnyRevert()":{inputs:[],name:"givenAnyRevert",outputs:[],stateMutability:"nonpayable",type:"function"},"givenAnyRevertWithMessage(string)":{inputs:[{internalType:"string",name:"message",type:"string"}],name:"givenAnyRevertWithMessage",outputs:[],stateMutability:"nonpayable",type:"function"},"givenAnyRunOutOfGas()":{inputs:[],name:"givenAnyRunOutOfGas",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataReturn(bytes,bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"bytes",name:"response",type:"bytes"}],name:"givenCalldataReturn",outputs:[],stateMutability:"nonpayable",type:"function",details:"After calling this method, the mock will return `response` when the given methodId is called with matching arguments. These exact calldataMocks will take precedence over all other calldataMocks.",params:{call:"ABI encoded calldata (methodId and arguments)",response:"ABI encoded response that will be returned if contract is invoked with calldata"}},"givenCalldataReturnAddress(bytes,address)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"address",name:"response",type:"address"}],name:"givenCalldataReturnAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataReturnBool(bytes,bool)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"bool",name:"response",type:"bool"}],name:"givenCalldataReturnBool",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataReturnUint(bytes,uint256)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"uint256",name:"response",type:"uint256"}],name:"givenCalldataReturnUint",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataRevert(bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"}],name:"givenCalldataRevert",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataRevertWithMessage(bytes,string)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"string",name:"message",type:"string"}],name:"givenCalldataRevertWithMessage",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataRunOutOfGas(bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"}],name:"givenCalldataRunOutOfGas",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodReturn(bytes,bytes)":{inputs:[{internalType:"bytes",name:"method",type:"bytes"},{internalType:"bytes",name:"response",type:"bytes"}],name:"givenMethodReturn",outputs:[],stateMutability:"nonpayable",type:"function",details:"After calling this method, the mock will return `response` when the given methodId is called regardless of arguments. If the methodId and arguments are mocked more specifically (using `givenMethodAndArguments`) the latter will take precedence.",params:{method:"ABI encoded methodId. It is valid to pass full calldata (including arguments). The mock will extract the methodId from it",response:"ABI encoded response that will be returned if method is invoked"}},"givenMethodReturnAddress(bytes,address)":{inputs:[{internalType:"bytes",name:"method",type:"bytes"},{internalType:"address",name:"response",type:"address"}],name:"givenMethodReturnAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodReturnBool(bytes,bool)":{inputs:[{internalType:"bytes",name:"method",type:"bytes"},{internalType:"bool",name:"response",type:"bool"}],name:"givenMethodReturnBool",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodReturnUint(bytes,uint256)":{inputs:[{internalType:"bytes",name:"method",type:"bytes"},{internalType:"uint256",name:"response",type:"uint256"}],name:"givenMethodReturnUint",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodRevert(bytes)":{inputs:[{internalType:"bytes",name:"method",type:"bytes"}],name:"givenMethodRevert",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodRevertWithMessage(bytes,string)":{inputs:[{internalType:"bytes",name:"method",type:"bytes"},{internalType:"string",name:"message",type:"string"}],name:"givenMethodRevertWithMessage",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodRunOutOfGas(bytes)":{inputs:[{internalType:"bytes",name:"method",type:"bytes"}],name:"givenMethodRunOutOfGas",outputs:[],stateMutability:"nonpayable",type:"function"},"invocationCount()":{inputs:[],name:"invocationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Returns the number of times anything has been called on this mock since last reset"},"invocationCountForCalldata(bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"}],name:"invocationCountForCalldata",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Returns the number of times this mock has been called with the exact calldata since last reset.",params:{call:"ABI encoded calldata (methodId and arguments)"}},"invocationCountForMethod(bytes)":{inputs:[{internalType:"bytes",name:"method",type:"bytes"}],name:"invocationCountForMethod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"nonpayable",type:"function",details:"Returns the number of times the given method has been called on this mock since last reset",params:{method:"ABI encoded methodId. It is valid to pass full calldata (including arguments). The mock will extract the methodId from it"}},"reset()":{inputs:[],name:"reset",outputs:[],stateMutability:"nonpayable",type:"function",details:"Resets all mocked methods and invocation counts."}}},"contracts/notDiamonds/interfaces/IWrappedStakingLocus.sol:IWrappedStakingLocus":{source:"contracts/notDiamonds/interfaces/IWrappedStakingLocus.sol",name:"IWrappedStakingLocus",events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens owned by `account`."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the decimals places of the token."},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token."},"syncBalanceOnStake(address)":{inputs:[{internalType:"address",name:"who",type:"address"}],name:"syncBalanceOnStake",outputs:[],stateMutability:"nonpayable",type:"function"},"syncBalanceOnWithdraw(address)":{inputs:[{internalType:"address",name:"who",type:"address"}],name:"syncBalanceOnWithdraw",outputs:[],stateMutability:"nonpayable",type:"function"},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the amount of tokens in existence."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from the caller's account to `to`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Moves `amount` tokens from `from` to `to` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event."}}},"contracts/notDiamonds/mock/MockContract.sol:MockContract":{source:"contracts/notDiamonds/mock/MockContract.sol",name:"MockContract",constructor:{inputs:[],stateMutability:"nonpayable",type:"constructor"},fallback:{stateMutability:"payable",type:"fallback"},receive:{stateMutability:"payable",type:"receive"},methods:{"DEFAULT_FALLBACK_VALUE()":{inputs:[],name:"DEFAULT_FALLBACK_VALUE",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function"},"MOCKS_LIST_END()":{inputs:[],name:"MOCKS_LIST_END",outputs:[{internalType:"bytes",name:"",type:"bytes"}],stateMutability:"view",type:"function"},"MOCKS_LIST_END_HASH()":{inputs:[],name:"MOCKS_LIST_END_HASH",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"MOCKS_LIST_START()":{inputs:[],name:"MOCKS_LIST_START",outputs:[{internalType:"bytes32",name:"",type:"bytes32"}],stateMutability:"view",type:"function"},"SENTINEL_ANY_MOCKS()":{inputs:[],name:"SENTINEL_ANY_MOCKS",outputs:[{internalType:"bytes4",name:"",type:"bytes4"}],stateMutability:"view",type:"function"},"givenAnyReturn(bytes)":{inputs:[{internalType:"bytes",name:"response",type:"bytes"}],name:"givenAnyReturn",outputs:[],stateMutability:"nonpayable",type:"function",details:"After calling this method, the mock will return `response` when it is called with any calldata that is not mocked more specifically below (e.g. using givenMethodReturn).",params:{response:"ABI encoded response that will be returned if method is invoked"}},"givenAnyReturnAddress(address)":{inputs:[{internalType:"address",name:"response",type:"address"}],name:"givenAnyReturnAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"givenAnyReturnBool(bool)":{inputs:[{internalType:"bool",name:"response",type:"bool"}],name:"givenAnyReturnBool",outputs:[],stateMutability:"nonpayable",type:"function"},"givenAnyReturnUint(uint256)":{inputs:[{internalType:"uint256",name:"response",type:"uint256"}],name:"givenAnyReturnUint",outputs:[],stateMutability:"nonpayable",type:"function"},"givenAnyRevert()":{inputs:[],name:"givenAnyRevert",outputs:[],stateMutability:"nonpayable",type:"function"},"givenAnyRevertWithMessage(string)":{inputs:[{internalType:"string",name:"message",type:"string"}],name:"givenAnyRevertWithMessage",outputs:[],stateMutability:"nonpayable",type:"function"},"givenAnyRunOutOfGas()":{inputs:[],name:"givenAnyRunOutOfGas",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataReturn(bytes,bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"bytes",name:"response",type:"bytes"}],name:"givenCalldataReturn",outputs:[],stateMutability:"nonpayable",type:"function",details:"After calling this method, the mock will return `response` when the given methodId is called with matching arguments. These exact calldataMocks will take precedence over all other calldataMocks.",params:{call:"ABI encoded calldata (methodId and arguments)",response:"ABI encoded response that will be returned if contract is invoked with calldata"}},"givenCalldataReturnAddress(bytes,address)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"address",name:"response",type:"address"}],name:"givenCalldataReturnAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataReturnBool(bytes,bool)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"bool",name:"response",type:"bool"}],name:"givenCalldataReturnBool",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataReturnUint(bytes,uint256)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"uint256",name:"response",type:"uint256"}],name:"givenCalldataReturnUint",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataRevert(bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"}],name:"givenCalldataRevert",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataRevertWithMessage(bytes,string)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"string",name:"message",type:"string"}],name:"givenCalldataRevertWithMessage",outputs:[],stateMutability:"nonpayable",type:"function"},"givenCalldataRunOutOfGas(bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"}],name:"givenCalldataRunOutOfGas",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodReturn(bytes,bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"bytes",name:"response",type:"bytes"}],name:"givenMethodReturn",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodReturnAddress(bytes,address)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"address",name:"response",type:"address"}],name:"givenMethodReturnAddress",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodReturnBool(bytes,bool)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"bool",name:"response",type:"bool"}],name:"givenMethodReturnBool",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodReturnUint(bytes,uint256)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"uint256",name:"response",type:"uint256"}],name:"givenMethodReturnUint",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodRevert(bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"}],name:"givenMethodRevert",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodRevertWithMessage(bytes,string)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"},{internalType:"string",name:"message",type:"string"}],name:"givenMethodRevertWithMessage",outputs:[],stateMutability:"nonpayable",type:"function"},"givenMethodRunOutOfGas(bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"}],name:"givenMethodRunOutOfGas",outputs:[],stateMutability:"nonpayable",type:"function"},"invocationCount()":{inputs:[],name:"invocationCount",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of times anything has been called on this mock since last reset"},"invocationCountForCalldata(bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"}],name:"invocationCountForCalldata",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"Returns the number of times this mock has been called with the exact calldata since last reset.",params:{call:"ABI encoded calldata (methodId and arguments)"}},"invocationCountForMethod(bytes)":{inputs:[{internalType:"bytes",name:"call",type:"bytes"}],name:"invocationCountForMethod",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"reset()":{inputs:[],name:"reset",outputs:[],stateMutability:"nonpayable",type:"function",details:"Resets all mocked methods and invocation counts."},"updateInvocationCount(bytes4,bytes)":{inputs:[{internalType:"bytes4",name:"methodId",type:"bytes4"},{internalType:"bytes",name:"originalMsgData",type:"bytes"}],name:"updateInvocationCount",outputs:[],stateMutability:"nonpayable",type:"function"}}},"contracts/notDiamonds/mock/MockLocus.sol:MockLocus":{source:"contracts/notDiamonds/mock/MockLocus.sol",name:"MockLocus",constructor:{inputs:[{internalType:"address",name:"initialOwner",type:"address"}],stateMutability:"nonpayable",type:"constructor"},events:{"Approval(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"owner",type:"address"},{indexed:!0,internalType:"address",name:"spender",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Approval",type:"event",details:"Emitted when the allowance of a `spender` for an `owner` is set by a call to {approve}. `value` is the new allowance."},"Transfer(address,address,uint256)":{anonymous:!1,inputs:[{indexed:!0,internalType:"address",name:"from",type:"address"},{indexed:!0,internalType:"address",name:"to",type:"address"},{indexed:!1,internalType:"uint256",name:"value",type:"uint256"}],name:"Transfer",type:"event",details:"Emitted when `value` tokens are moved from one account (`from`) to another (`to`). Note that `value` may be zero."}},methods:{"allowance(address,address)":{inputs:[{internalType:"address",name:"owner",type:"address"},{internalType:"address",name:"spender",type:"address"}],name:"allowance",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-allowance}."},"approve(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"approve",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-approve}. NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on `transferFrom`. This is semantically equivalent to an infinite approval. Requirements: - `spender` cannot be the zero address."},"balanceOf(address)":{inputs:[{internalType:"address",name:"account",type:"address"}],name:"balanceOf",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-balanceOf}."},"decimals()":{inputs:[],name:"decimals",outputs:[{internalType:"uint8",name:"",type:"uint8"}],stateMutability:"view",type:"function",details:"Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5.05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the default value returned by this function, unless it's overridden. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}."},"decreaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"subtractedValue",type:"uint256"}],name:"decreaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`."},"increaseAllowance(address,uint256)":{inputs:[{internalType:"address",name:"spender",type:"address"},{internalType:"uint256",name:"addedValue",type:"uint256"}],name:"increaseAllowance",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address."},"mint(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"mint",outputs:[],stateMutability:"nonpayable",type:"function"},"name()":{inputs:[],name:"name",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the name of the token."},"symbol()":{inputs:[],name:"symbol",outputs:[{internalType:"string",name:"",type:"string"}],stateMutability:"view",type:"function",details:"Returns the symbol of the token, usually a shorter version of the name."},"totalSupply()":{inputs:[],name:"totalSupply",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function",details:"See {IERC20-totalSupply}."},"transfer(address,uint256)":{inputs:[{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transfer",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transfer}. Requirements: - `to` cannot be the zero address. - the caller must have a balance of at least `amount`."},"transferFrom(address,address,uint256)":{inputs:[{internalType:"address",name:"from",type:"address"},{internalType:"address",name:"to",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"transferFrom",outputs:[{internalType:"bool",name:"",type:"bool"}],stateMutability:"nonpayable",type:"function",details:"See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. NOTE: Does not update the allowance if the current allowance is the maximum `uint256`. Requirements: - `from` and `to` cannot be the zero address. - `from` must have a balance of at least `amount`. - the caller must have allowance for ``from``'s tokens of at least `amount`."}}},"contracts/notDiamonds/mock/MockStaking.sol:MockStaking":{source:"contracts/notDiamonds/mock/MockStaking.sol",name:"MockStaking",constructor:{inputs:[{internalType:"address",name:"_token",type:"address"}],stateMutability:"nonpayable",type:"constructor"},methods:{"locusToken()":{inputs:[],name:"locusToken",outputs:[{internalType:"address",name:"",type:"address"}],stateMutability:"view",type:"function"},"sent(address)":{inputs:[{internalType:"address",name:"",type:"address"}],name:"sent",outputs:[{internalType:"uint256",name:"",type:"uint256"}],stateMutability:"view",type:"function"},"stakeFor(address,uint256)":{inputs:[{internalType:"address",name:"account",type:"address"},{internalType:"uint256",name:"amount",type:"uint256"}],name:"stakeFor",outputs:[],stateMutability:"nonpayable",type:"function"}}}};new Qn({el:"#app",router:new Rd({routes:[{path:"/",component:Hd,props:()=>({json:Wd})},{path:"*",component:qd,props:e=>({json:Wd[e.path.slice(1)]})}]}),mounted(){document.dispatchEvent(new Event("render-event"))},render:e=>e(Dd)})})()})();